"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_services_astrology-service_ts"],{

/***/ "(app-pages-browser)/./services/astrology-api-service.ts":
/*!*******************************************!*\
  !*** ./services/astrology-api-service.ts ***!
  \*******************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   clearAuthErrors: () => (/* binding */ clearAuthErrors),\n/* harmony export */   fetchNatalChart: () => (/* binding */ fetchNatalChart),\n/* harmony export */   fetchNatalWheelChart: () => (/* binding */ fetchNatalWheelChart),\n/* harmony export */   fetchNatalWheelChartSVG: () => (/* binding */ fetchNatalWheelChartSVG),\n/* harmony export */   geocodeLocation: () => (/* binding */ geocodeLocation),\n/* harmony export */   getDailyHoroscope: () => (/* binding */ getDailyHoroscope),\n/* harmony export */   getNatalChartInterpretation: () => (/* binding */ getNatalChartInterpretation)\n/* harmony export */ });\n/* harmony import */ var _utils_fallback_chart__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/utils/fallback-chart */ \"(app-pages-browser)/./utils/fallback-chart.ts\");\n/* harmony import */ var _utils_safe_storage__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/utils/safe-storage */ \"(app-pages-browser)/./utils/safe-storage.ts\");\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"(app-pages-browser)/./node_modules/next/dist/compiled/buffer/index.js\")[\"Buffer\"];\n/**\n * AstrologyAPI Service\n * Handles all interactions with the astrologyapi.com API\n */ \n\n// API configuration - using the provided credentials\nconst USER_ID = process.env.USER_ID || \"640668\";\nconst API_KEY = process.env.API_KEY || \"f54e96a1b5d0607f65433e754ae9a4f94fa5a9f8\";\nconst ASTROLOGY_API_BASE_URL = \"https://json.astrologyapi.com/v1\";\n// Check if API credentials are properly configured\nconst hasValidCredentials = ()=>{\n    const hasCredentials = USER_ID && API_KEY && USER_ID.length > 0 && API_KEY.length > 0;\n    console.log(\"Debug - Has Valid Credentials:\", hasCredentials);\n    console.log(\"Debug - User ID Length:\", USER_ID.length);\n    console.log(\"Debug - API Key Length:\", API_KEY.length);\n    return hasCredentials;\n};\n// Store authentication error status in session storage to avoid repeated failed attempts\nconst setAuthError = (hasError)=>{\n    (0,_utils_safe_storage__WEBPACK_IMPORTED_MODULE_1__.safeSetSessionItem)(\"astrology_api_auth_error\", hasError ? \"true\" : \"false\");\n    console.log(\"Debug - Set Auth Error:\", hasError);\n};\n// Check if we've already encountered an authentication error\nconst hasAuthError = ()=>{\n    const hasError = (0,_utils_safe_storage__WEBPACK_IMPORTED_MODULE_1__.safeGetSessionItem)(\"astrology_api_auth_error\") === \"true\";\n    console.log(\"Debug - Has Auth Error:\", hasError);\n    return hasError;\n};\n// Clear any stored authentication errors\nconst clearAuthErrors = ()=>{\n    (0,_utils_safe_storage__WEBPACK_IMPORTED_MODULE_1__.safeRemoveSessionItem)(\"astrology_api_auth_error\");\n    console.log(\"Debug - Cleared Auth Errors\");\n};\n/**\n * Creates Basic Auth headers for API requests\n * Implements the same approach as the successful Python example\n */ const getAuthHeaders = ()=>{\n    try {\n        // Create the auth string in the format \"userId:apiKey\"\n        const authString = \"\".concat(USER_ID, \":\").concat(API_KEY);\n        console.log(\"Debug - Auth String Format:\", \"\".concat(USER_ID, \":API_KEY\"));\n        // Encode to base64 - similar to Python's HTTPBasicAuth\n        let base64Auth = \"\";\n        if ( true && window.btoa) {\n            base64Auth = window.btoa(authString);\n            console.log(\"Debug - Using window.btoa for encoding\");\n        } else if (typeof Buffer !== \"undefined\") {\n            base64Auth = Buffer.from(authString).toString(\"base64\");\n            console.log(\"Debug - Using Buffer for encoding\");\n        } else {\n            console.error(\"Debug - No method available for base64 encoding\");\n            throw new Error(\"Base64 encoding not available\");\n        }\n        console.log(\"Debug - Base64 Auth (first 10 chars):\", base64Auth.substring(0, 10) + \"...\");\n        // Return headers with Basic Auth\n        return {\n            Authorization: \"Basic \".concat(base64Auth),\n            \"Content-Type\": \"application/json\"\n        };\n    } catch (error) {\n        console.error(\"Error creating auth headers:\", error);\n        return {\n            \"Content-Type\": \"application/json\",\n            \"Authorization\": \"\"\n        };\n    }\n};\n/**\n * Fetches natal chart data from AstrologyAPI\n */ async function fetchNatalChart(birthDate, birthTime, latitude, longitude) {\n    let timezone = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 5.5;\n    try {\n        // Check for previous auth errors to avoid repeated failed API calls\n        if (hasAuthError()) {\n            console.warn(\"Skipping API call due to previous authentication error\");\n            throw new Error(\"API authentication error - using fallback data\");\n        }\n        // Check credentials first\n        if (!hasValidCredentials()) {\n            setAuthError(true);\n            throw new Error(\"API credentials not configured\");\n        }\n        // Format date and time for API\n        const [year, month, day] = birthDate.split(\"-\").map(Number);\n        const [hour, minute] = birthTime.split(\":\").map(Number);\n        // Prepare the request body\n        const requestBody = {\n            day,\n            month,\n            year,\n            hour,\n            min: minute,\n            lat: latitude,\n            lon: longitude,\n            tzone: timezone\n        };\n        console.log(\"Fetching natal chart with params:\", requestBody);\n        console.log(\"Using auth headers:\", getAuthHeaders());\n        // Make the API request for planets\n        const planetsResponse = await fetch(\"\".concat(ASTROLOGY_API_BASE_URL, \"/planets\"), {\n            method: \"POST\",\n            headers: getAuthHeaders(),\n            body: JSON.stringify(requestBody)\n        });\n        // Parse the response even if status is not OK to check for auth errors\n        const planetsData = await planetsResponse.json();\n        // Check for authentication error in response\n        if (planetsData.status === false && planetsData.msg) {\n            console.error(\"API error:\", planetsData.msg);\n            // Check if it's an authentication error\n            if (planetsData.msg.includes(\"invalid\") || planetsData.msg.includes(\"User ID\")) {\n                setAuthError(true);\n            }\n            throw new Error(planetsData.msg);\n        }\n        if (!planetsResponse.ok) {\n            throw new Error(\"Planets API error: \".concat(planetsResponse.status, \" \").concat(planetsResponse.statusText));\n        }\n        // Fetch houses data\n        const housesResponse = await fetch(\"\".concat(ASTROLOGY_API_BASE_URL, \"/houses\"), {\n            method: \"POST\",\n            headers: getAuthHeaders(),\n            body: JSON.stringify(requestBody)\n        });\n        const housesData = await housesResponse.json();\n        if (housesData.status === false && housesData.msg) {\n            throw new Error(housesData.msg);\n        }\n        if (!housesResponse.ok) {\n            throw new Error(\"Houses API error: \".concat(housesResponse.status, \" \").concat(housesResponse.statusText));\n        }\n        // Fetch aspects data\n        const aspectsResponse = await fetch(\"\".concat(ASTROLOGY_API_BASE_URL, \"/aspects\"), {\n            method: \"POST\",\n            headers: getAuthHeaders(),\n            body: JSON.stringify(requestBody)\n        });\n        let aspectsData = [];\n        if (aspectsResponse.ok) {\n            aspectsData = await aspectsResponse.json();\n        }\n        // Format the data into our application's structure\n        return formatNatalChartResponse(planetsData, housesData, aspectsData, {\n            date: birthDate,\n            time: birthTime,\n            location: {\n                latitude,\n                longitude,\n                name: \"\"\n            }\n        });\n    } catch (error) {\n        console.error(\"Error fetching natal chart:\", error);\n        throw error;\n    }\n}\n/**\n * Fetches natal wheel chart from AstrologyAPI\n * Updated to handle the new response format that returns a chart URL\n */ async function fetchNatalWheelChart(birthDate, birthTime, latitude, longitude) {\n    let timezone = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 5.5, sign_icon_color = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : \"WHITE\", sign_background = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : [\n        \"clear\",\n        \"clear\",\n        \"clear\",\n        \"clear\",\n        \"clear\",\n        \"clear\",\n        \"clear\",\n        \"clear\",\n        \"clear\",\n        \"clear\",\n        \"clear\",\n        \"clear\"\n    ];\n    try {\n        console.log(\"Debug - fetchNatalWheelChart called with:\", {\n            birthDate,\n            birthTime,\n            latitude,\n            longitude,\n            timezone\n        });\n        // Check for previous auth errors to avoid repeated failed API calls\n        if (hasAuthError()) {\n            console.warn(\"Skipping API call due to previous authentication error\");\n            // Use the general fallback SVG for other charts\n            return {\n                chartUrl: \"\",\n                svgContent: (0,_utils_fallback_chart__WEBPACK_IMPORTED_MODULE_0__.getFallbackNatalChart)()\n            };\n        }\n        // Check credentials first\n        if (!hasValidCredentials()) {\n            console.warn(\"Missing API credentials for AstrologyAPI\");\n            setAuthError(true);\n            throw new Error(\"API credentials not configured\");\n        }\n        // Format date and time for API\n        const [year, month, day] = birthDate.split(\"-\").map(Number);\n        const [hour, minute] = birthTime.split(\":\").map(Number);\n        // Prepare the request body\n        const requestBody = {\n            day,\n            month,\n            year,\n            hour,\n            min: minute,\n            lat: latitude,\n            lon: longitude,\n            tzone: timezone,\n            planet_icon_color: \"Black\",\n            sign_icon_color: \"Black\",\n            sign_background: [\n                \"#F4FAFC\",\n                \"#F4FAFC\",\n                \"#F4FAFC\",\n                \"#F4FAFC\",\n                \"#F4FAFC\",\n                \"#F4FAFC\",\n                \"#F4FAFC\",\n                \"#F4FAFC\",\n                \"#F4FAFC\",\n                \"#F4FAFC\",\n                \"#F4FAFC\",\n                \"#F4FAFC\"\n            ],\n            inner_circle_background: \"#F4FAFC\",\n            outer_circle_background: \"#F4FAFC\",\n            chart_size: 1000,\n            image_type: \"svg\"\n        };\n        console.log(\"Debug - Request Body:\", requestBody);\n        // Get auth headers\n        const headers = getAuthHeaders();\n        console.log(\"Debug - Headers:\", {\n            Authorization: headers.Authorization ? \"Basic ***\" : \"Missing\",\n            \"Content-Type\": headers[\"Content-Type\"]\n        });\n        // Make the API request\n        console.log(\"Debug - Fetching from URL:\", \"\".concat(ASTROLOGY_API_BASE_URL, \"/natal_wheel_chart\"));\n        const response = await fetch(\"\".concat(ASTROLOGY_API_BASE_URL, \"/natal_wheel_chart\"), {\n            method: \"POST\",\n            headers,\n            body: JSON.stringify(requestBody)\n        });\n        // Log the response status for debugging\n        console.log(\"Debug - API Response Status: \".concat(response.status, \" \").concat(response.statusText));\n        // Get the raw response text first for debugging\n        const rawResponseText = await response.text();\n        console.log(\"Debug - Raw Response (first 200 chars):\", rawResponseText.substring(0, 200));\n        // Try to parse the response as JSON\n        let data;\n        try {\n            data = JSON.parse(rawResponseText);\n            console.log(\"Debug - Response Keys:\", Object.keys(data));\n        } catch (e) {\n            console.error(\"Debug - Failed to parse response as JSON:\", e);\n            throw new Error(\"Failed to parse API response as JSON: \".concat(rawResponseText.substring(0, 100), \"...\"));\n        }\n        // Check for error in response\n        if (data.status === false && data.msg) {\n            console.error(\"API error:\", data.msg);\n            // Check if it's an authentication error\n            if (data.msg.includes(\"invalid\") || data.msg.includes(\"User ID\")) {\n                setAuthError(true);\n            }\n            throw new Error(data.msg);\n        }\n        if (!response.ok) {\n            throw new Error(\"Natal wheel chart API error: \".concat(response.status, \" \").concat(response.statusText));\n        }\n        // Check if we have the chart_url in the response\n        if (data.chart_url) {\n            console.log(\"Debug - Successfully retrieved chart URL:\", data.chart_url);\n            // Clear any stored auth errors since the request succeeded\n            clearAuthErrors();\n            return {\n                chartUrl: data.chart_url\n            };\n        } else if (data.svg) {\n            console.log(\"Debug - Retrieved SVG content instead of URL, length:\", data.svg.length);\n            // Clear any stored auth errors since the request succeeded\n            clearAuthErrors();\n            return {\n                chartUrl: \"\",\n                svgContent: data.svg\n            };\n        } else {\n            console.error(\"API response missing chart_url and svg data:\", data);\n            throw new Error(\"No chart data returned from the API\");\n        }\n    } catch (error) {\n        console.error(\"Error fetching natal wheel chart:\", error);\n        // Use the general fallback SVG for other charts\n        return {\n            chartUrl: \"\",\n            svgContent: (0,_utils_fallback_chart__WEBPACK_IMPORTED_MODULE_0__.getFallbackNatalChart)()\n        };\n    }\n}\n// Keep the old function for backward compatibility\nasync function fetchNatalWheelChartSVG(birthDate, birthTime, latitude, longitude) {\n    let timezone = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 5.5;\n    try {\n        const result = await fetchNatalWheelChart(birthDate, birthTime, latitude, longitude, timezone);\n        // If we have SVG content, return it\n        if (result.svgContent) {\n            return result.svgContent;\n        }\n        // If we have a chart URL, fetch the SVG content\n        if (result.chartUrl) {\n            console.log(\"Debug - Fetching SVG content from URL:\", result.chartUrl);\n            try {\n                const svgResponse = await fetch(result.chartUrl);\n                if (!svgResponse.ok) {\n                    throw new Error(\"Failed to fetch SVG from URL: \".concat(svgResponse.status, \" \").concat(svgResponse.statusText));\n                }\n                const svgContent = await svgResponse.text();\n                console.log(\"Debug - Successfully fetched SVG content, length:\", svgContent.length);\n                return svgContent;\n            } catch (error) {\n                console.error(\"Error fetching SVG from URL:\", error);\n                // Return fallback SVG if we can't fetch from URL\n                return (0,_utils_fallback_chart__WEBPACK_IMPORTED_MODULE_0__.getFallbackNatalChart)();\n            }\n        }\n        // Return fallback SVG if no chart data available\n        return (0,_utils_fallback_chart__WEBPACK_IMPORTED_MODULE_0__.getFallbackNatalChart)();\n    } catch (error) {\n        console.error(\"Error in fetchNatalWheelChartSVG:\", error);\n        // Return fallback SVG for other charts\n        return (0,_utils_fallback_chart__WEBPACK_IMPORTED_MODULE_0__.getFallbackNatalChart)();\n    }\n}\n/**\n * Geocodes a location string to get latitude and longitude using AstrologyAPI\n */ async function geocodeLocation(location) {\n    try {\n        console.log(\"Geocoding location:\", location);\n        if (!hasValidCredentials()) {\n            console.warn(\"Missing API credentials for AstrologyAPI\");\n            setAuthError(true);\n            throw new Error(\"API credentials not configured\");\n        }\n        const headers = getAuthHeaders();\n        console.log(\"Using auth headers:\", headers);\n        // Use GET, not POST\n        const url = \"\".concat(ASTROLOGY_API_BASE_URL, \"/geo_details?place=\").concat(encodeURIComponent(location));\n        const response = await fetch(url, {\n            method: \"GET\",\n            headers\n        });\n        if (!response.ok) {\n            console.error(\"Geocoding API error:\", response.status);\n            throw new Error(\"Geocoding API error: \".concat(response.status));\n        }\n        const data = await response.json();\n        if (!data || !data.latitude || !data.longitude) {\n            console.error(\"Invalid geocoding response:\", data);\n            throw new Error(\"Invalid geocoding response\");\n        }\n        return {\n            latitude: data.latitude,\n            longitude: data.longitude,\n            name: data.name || location\n        };\n    } catch (error) {\n        console.error(\"Error geocoding location:\", error);\n        // Fallback: Las Vegas\n        return {\n            latitude: 36.1699,\n            longitude: -115.1398,\n            name: location\n        };\n    }\n}\n/**\n * Formats the API response into our application's data structure\n */ function formatNatalChartResponse(planetsData, housesData, aspectsData, birthDetails) {\n    // Extract and format planet positions\n    const planets = planetsData.map((planet)=>{\n        // Convert planet name to our format\n        const planetName = convertPlanetName(planet.name);\n        return {\n            name: planetName,\n            sign: planet.sign.toLowerCase(),\n            degree: planet.norm_degree,\n            house: planet.house,\n            retrograde: planet.is_retrograde === 1,\n            aspectsToOtherPlanets: []\n        };\n    });\n    // Extract and format houses\n    const houses = Object.keys(housesData).map((key)=>{\n        const house = housesData[key];\n        return {\n            number: Number.parseInt(key.replace(\"house\", \"\")),\n            sign: house.sign.toLowerCase(),\n            degree: house.degree,\n            cusp: true\n        };\n    });\n    // Extract and format angles (Ascendant, Midheaven, etc.)\n    const angles = {\n        ascendant: {\n            sign: housesData.ascendant.sign.toLowerCase(),\n            degree: housesData.ascendant.degree\n        },\n        midheaven: {\n            sign: housesData.midheaven.sign.toLowerCase(),\n            degree: housesData.midheaven.degree\n        },\n        descendant: {\n            sign: getOppositeSign(housesData.ascendant.sign.toLowerCase()),\n            degree: (housesData.ascendant.degree + 180) % 360\n        },\n        imumCoeli: {\n            sign: getOppositeSign(housesData.midheaven.sign.toLowerCase()),\n            degree: (housesData.midheaven.degree + 180) % 360\n        }\n    };\n    // Format aspects data\n    const aspects = aspectsData.map((aspect)=>({\n            aspect: aspect.aspect.toLowerCase(),\n            planet1: convertPlanetName(aspect.planet1),\n            planet2: convertPlanetName(aspect.planet2),\n            orb: aspect.orb,\n            applying: aspect.applying === 1\n        }));\n    return {\n        planets,\n        houses,\n        angles,\n        aspects,\n        birthDetails\n    };\n}\n/**\n * Converts AstrologyAPI planet names to our application's format\n */ function convertPlanetName(apiPlanetName) {\n    const planetMap = {\n        Sun: \"sun\",\n        Moon: \"moon\",\n        Mercury: \"mercury\",\n        Venus: \"venus\",\n        Mars: \"mars\",\n        Jupiter: \"jupiter\",\n        Saturn: \"saturn\",\n        Uranus: \"uranus\",\n        Neptune: \"neptune\",\n        Pluto: \"pluto\",\n        Rahu: \"north_node\",\n        Ketu: \"south_node\"\n    };\n    return planetMap[apiPlanetName] || apiPlanetName.toLowerCase();\n}\n/**\n * Gets the opposite zodiac sign\n */ function getOppositeSign(sign) {\n    const zodiacSigns = [\n        \"aries\",\n        \"taurus\",\n        \"gemini\",\n        \"cancer\",\n        \"leo\",\n        \"virgo\",\n        \"libra\",\n        \"scorpio\",\n        \"sagittarius\",\n        \"capricorn\",\n        \"aquarius\",\n        \"pisces\"\n    ];\n    const index = zodiacSigns.indexOf(sign);\n    if (index === -1) return \"aries\" // Default fallback\n    ;\n    const oppositeIndex = (index + 6) % 12;\n    return zodiacSigns[oppositeIndex];\n}\n/**\n * Gets interpretations for a natal chart\n */ async function getNatalChartInterpretation(natalChart) {\n    try {\n        // This would be implemented to fetch interpretations from AstrologyAPI\n        // For now, we'll return a placeholder interpretation\n        return {\n            overview: {\n                title: \"Your Cosmic Blueprint\",\n                description: \"Your natal chart reveals your unique cosmic blueprint, showing the positions of the planets at the moment of your birth. This celestial snapshot offers insights into your personality, strengths, challenges, and life path.\"\n            },\n            sunSign: {\n                title: \"Sun Sign\",\n                description: \"Your Sun sign represents your core essence and life purpose.\",\n                keywords: [\n                    \"identity\",\n                    \"purpose\",\n                    \"vitality\"\n                ]\n            },\n            moonSign: {\n                title: \"Moon Sign\",\n                description: \"Your Moon sign reflects your emotional nature and subconscious patterns.\",\n                keywords: [\n                    \"emotions\",\n                    \"instincts\",\n                    \"comfort\"\n                ]\n            },\n            ascendantSign: {\n                title: \"Ascendant\",\n                description: \"Your Ascendant represents how you present yourself to the world.\",\n                keywords: [\n                    \"appearance\",\n                    \"first impressions\",\n                    \"personal style\"\n                ]\n            },\n            planetPositions: {\n                sun: {\n                    description: \"Your Sun placement indicates your core identity and purpose in life.\",\n                    keywords: [\n                        \"identity\",\n                        \"purpose\",\n                        \"vitality\"\n                    ]\n                },\n                moon: {\n                    description: \"Your Moon placement reveals your emotional nature and subconscious patterns.\",\n                    keywords: [\n                        \"emotions\",\n                        \"instincts\",\n                        \"comfort\"\n                    ]\n                },\n                mercury: {\n                    description: \"Your Mercury placement shows how you think and communicate.\",\n                    keywords: [\n                        \"communication\",\n                        \"thinking\",\n                        \"learning\"\n                    ]\n                },\n                venus: {\n                    description: \"Your Venus placement indicates how you express and receive love and beauty.\",\n                    keywords: [\n                        \"love\",\n                        \"beauty\",\n                        \"values\"\n                    ]\n                },\n                mars: {\n                    description: \"Your Mars placement shows how you assert yourself and take action.\",\n                    keywords: [\n                        \"action\",\n                        \"desire\",\n                        \"energy\"\n                    ]\n                },\n                jupiter: {\n                    description: \"Your Jupiter placement reveals where you find growth and expansion.\",\n                    keywords: [\n                        \"growth\",\n                        \"luck\",\n                        \"abundance\"\n                    ]\n                },\n                saturn: {\n                    description: \"Your Saturn placement indicates where you face challenges and learn discipline.\",\n                    keywords: [\n                        \"discipline\",\n                        \"responsibility\",\n                        \"structure\"\n                    ]\n                },\n                uranus: {\n                    description: \"Your Uranus placement shows where you seek freedom and innovation.\",\n                    keywords: [\n                        \"innovation\",\n                        \"rebellion\",\n                        \"change\"\n                    ]\n                },\n                neptune: {\n                    description: \"Your Neptune placement reveals your spiritual and creative aspirations.\",\n                    keywords: [\n                        \"spirituality\",\n                        \"dreams\",\n                        \"illusion\"\n                    ]\n                },\n                pluto: {\n                    description: \"Your Pluto placement indicates where you experience transformation and power.\",\n                    keywords: [\n                        \"transformation\",\n                        \"power\",\n                        \"rebirth\"\n                    ]\n                }\n            },\n            houses: {\n                1: {\n                    description: \"The 1st house represents your self-image and how you present yourself to the world.\"\n                },\n                2: {\n                    description: \"The 2nd house represents your values, possessions, and resources.\"\n                },\n                3: {\n                    description: \"The 3rd house represents communication, learning, and your immediate environment.\"\n                },\n                4: {\n                    description: \"The 4th house represents your home, family, and emotional foundations.\"\n                },\n                5: {\n                    description: \"The 5th house represents creativity, pleasure, and self-expression.\"\n                },\n                6: {\n                    description: \"The 6th house represents work, health, and daily routines.\"\n                },\n                7: {\n                    description: \"The 7th house represents partnerships, relationships, and open enemies.\"\n                },\n                8: {\n                    description: \"The 8th house represents transformation, shared resources, and the occult.\"\n                },\n                9: {\n                    description: \"The 9th house represents higher education, philosophy, and long-distance travel.\"\n                },\n                10: {\n                    description: \"The 10th house represents career, public image, and authority.\"\n                },\n                11: {\n                    description: \"The 11th house represents friendships, groups, and aspirations.\"\n                },\n                12: {\n                    description: \"The 12th house represents the unconscious, spirituality, and hidden enemies.\"\n                }\n            }\n        };\n    } catch (error) {\n        console.error(\"Error getting chart interpretation:\", error);\n        throw error;\n    }\n}\n/**\n * Gets a daily horoscope for a zodiac sign\n */ async function getDailyHoroscope(sign) {\n    try {\n        // Check credentials first\n        if (!hasValidCredentials()) {\n            throw new Error(\"API credentials not configured\");\n        }\n        // Make the API request\n        const response = await fetch(\"\".concat(ASTROLOGY_API_BASE_URL, \"/horoscope_prediction/daily/\").concat(sign), {\n            method: \"POST\",\n            headers: getAuthHeaders(),\n            body: JSON.stringify({})\n        });\n        const data = await response.json();\n        // Check for error in response\n        if (data.status === false && data.msg) {\n            throw new Error(data.msg);\n        }\n        if (!response.ok) {\n            throw new Error(\"Horoscope error: \".concat(response.status, \" \").concat(response.statusText));\n        }\n        // Format the response to match our application's structure\n        return {\n            sign: sign,\n            date: new Date().toISOString().split(\"T\")[0],\n            prediction: data.prediction || \"Your horoscope for today is not available.\",\n            lucky_number: data.lucky_number || \"7\",\n            lucky_color: data.lucky_color || \"Blue\",\n            mood: data.mood || \"Reflective\",\n            compatibility: data.compatibility || \"Libra\"\n        };\n    } catch (error) {\n        console.error(\"Error getting daily horoscope:\", error);\n        throw error;\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NlcnZpY2VzL2FzdHJvbG9neS1hcGktc2VydmljZS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUFBOzs7Q0FHQyxHQUc2RDtBQUNzQztBQUVwRyxxREFBcUQ7QUFDckQsTUFBTUksVUFBVUMsT0FBT0EsQ0FBQ0MsR0FBRyxDQUFDRixPQUFPLElBQUk7QUFDdkMsTUFBTUcsVUFBVUYsT0FBT0EsQ0FBQ0MsR0FBRyxDQUFDQyxPQUFPLElBQUk7QUFDdkMsTUFBTUMseUJBQXlCO0FBRS9CLG1EQUFtRDtBQUNuRCxNQUFNQyxzQkFBc0I7SUFDMUIsTUFBTUMsaUJBQWlCTixXQUFXRyxXQUFXSCxRQUFRTyxNQUFNLEdBQUcsS0FBS0osUUFBUUksTUFBTSxHQUFHO0lBRXBGQyxRQUFRQyxHQUFHLENBQUMsa0NBQWtDSDtJQUM5Q0UsUUFBUUMsR0FBRyxDQUFDLDJCQUEyQlQsUUFBUU8sTUFBTTtJQUNyREMsUUFBUUMsR0FBRyxDQUFDLDJCQUEyQk4sUUFBUUksTUFBTTtJQUVyRCxPQUFPRDtBQUNUO0FBRUEseUZBQXlGO0FBQ3pGLE1BQU1JLGVBQWUsQ0FBQ0M7SUFDcEJiLHVFQUFrQkEsQ0FBQyw0QkFBNEJhLFdBQVcsU0FBUztJQUNuRUgsUUFBUUMsR0FBRyxDQUFDLDJCQUEyQkU7QUFDekM7QUFFQSw2REFBNkQ7QUFDN0QsTUFBTUMsZUFBZTtJQUNuQixNQUFNRCxXQUFXZCx1RUFBa0JBLENBQUMsZ0NBQWdDO0lBQ3BFVyxRQUFRQyxHQUFHLENBQUMsMkJBQTJCRTtJQUN2QyxPQUFPQTtBQUNUO0FBRUEseUNBQXlDO0FBQ2xDLE1BQU1FLGtCQUFrQjtJQUM3QmQsMEVBQXFCQSxDQUFDO0lBQ3RCUyxRQUFRQyxHQUFHLENBQUM7QUFDZCxFQUFDO0FBRUQ7OztDQUdDLEdBQ0QsTUFBTUssaUJBQWlCO0lBQ3JCLElBQUk7UUFDRix1REFBdUQ7UUFDdkQsTUFBTUMsYUFBYSxHQUFjWixPQUFYSCxTQUFRLEtBQVcsT0FB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Q05uQyxNQUFNLElBQUlvRyxPQUFPQyxXQUFXLEdBQUdsSSxLQUFLLENBQUMsSUFBSSxDQUFDLEVBQUU7WUFDNUNtSSxZQUFZckYsS0FBS3FGLFVBQVUsSUFBSTtZQUMvQkMsY0FBY3RGLEtBQUtzRixZQUFZLElBQUk7WUFDbkNDLGFBQWF2RixLQUFLdUYsV0FBVyxJQUFJO1lBQ2pDQyxNQUFNeEYsS0FBS3dGLElBQUksSUFBSTtZQUNuQkMsZUFBZXpGLEtBQUt5RixhQUFhLElBQUk7UUFDdkM7SUFDRixFQUFFLE9BQU9ySixPQUFPO1FBQ2RkLFFBQVFjLEtBQUssQ0FBQyxrQ0FBa0NBO1FBQ2hELE1BQU1BO0lBQ1I7QUFDRiIsInNvdXJjZXMiOlsiL1VzZXJzL21hcmtvbm92YWtvdnNraS9Eb2N1bWVudHMvVmlzdWFsIENvZGUvQXN0cm9Cb29rL0FzdHJvQm9vay9zZXJ2aWNlcy9hc3Ryb2xvZ3ktYXBpLXNlcnZpY2UudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBBc3Ryb2xvZ3lBUEkgU2VydmljZVxuICogSGFuZGxlcyBhbGwgaW50ZXJhY3Rpb25zIHdpdGggdGhlIGFzdHJvbG9neWFwaS5jb20gQVBJXG4gKi9cblxuaW1wb3J0IHR5cGUgeyBOYXRhbENoYXJ0LCBQbGFuZXRQb3NpdGlvbiwgWm9kaWFjU2lnbiwgSG91c2UsIEFuZ2xlIH0gZnJvbSBcIkAvdHlwZXMvYXN0cm9sb2d5XCJcbmltcG9ydCB7IGdldEZhbGxiYWNrTmF0YWxDaGFydCB9IGZyb20gXCJAL3V0aWxzL2ZhbGxiYWNrLWNoYXJ0XCJcbmltcG9ydCB7IHNhZmVHZXRTZXNzaW9uSXRlbSwgc2FmZVNldFNlc3Npb25JdGVtLCBzYWZlUmVtb3ZlU2Vzc2lvbkl0ZW0gfSBmcm9tIFwiQC91dGlscy9zYWZlLXN0b3JhZ2VcIlxuXG4vLyBBUEkgY29uZmlndXJhdGlvbiAtIHVzaW5nIHRoZSBwcm92aWRlZCBjcmVkZW50aWFsc1xuY29uc3QgVVNFUl9JRCA9IHByb2Nlc3MuZW52LlVTRVJfSUQgfHwgXCI2NDA2NjhcIlxuY29uc3QgQVBJX0tFWSA9IHByb2Nlc3MuZW52LkFQSV9LRVkgfHwgXCJmNTRlOTZhMWI1ZDA2MDdmNjU0MzNlNzU0YWU5YTRmOTRmYTVhOWY4XCJcbmNvbnN0IEFTVFJPTE9HWV9BUElfQkFTRV9VUkwgPSBcImh0dHBzOi8vanNvbi5hc3Ryb2xvZ3lhcGkuY29tL3YxXCJcblxuLy8gQ2hlY2sgaWYgQVBJIGNyZWRlbnRpYWxzIGFyZSBwcm9wZXJseSBjb25maWd1cmVkXG5jb25zdCBoYXNWYWxpZENyZWRlbnRpYWxzID0gKCkgPT4ge1xuICBjb25zdCBoYXNDcmVkZW50aWFscyA9IFVTRVJfSUQgJiYgQVBJX0tFWSAmJiBVU0VSX0lELmxlbmd0aCA+IDAgJiYgQVBJX0tFWS5sZW5ndGggPiAwXG5cbiAgY29uc29sZS5sb2coXCJEZWJ1ZyAtIEhhcyBWYWxpZCBDcmVkZW50aWFsczpcIiwgaGFzQ3JlZGVudGlhbHMpXG4gIGNvbnNvbGUubG9nKFwiRGVidWcgLSBVc2VyIElEIExlbmd0aDpcIiwgVVNFUl9JRC5sZW5ndGgpXG4gIGNvbnNvbGUubG9nKFwiRGVidWcgLSBBUEkgS2V5IExlbmd0aDpcIiwgQVBJX0tFWS5sZW5ndGgpXG5cbiAgcmV0dXJuIGhhc0NyZWRlbnRpYWxzXG59XG5cbi8vIFN0b3JlIGF1dGhlbnRpY2F0aW9uIGVycm9yIHN0YXR1cyBpbiBzZXNzaW9uIHN0b3JhZ2UgdG8gYXZvaWQgcmVwZWF0ZWQgZmFpbGVkIGF0dGVtcHRzXG5jb25zdCBzZXRBdXRoRXJyb3IgPSAoaGFzRXJyb3I6IGJvb2xlYW4pID0+IHtcbiAgc2FmZVNldFNlc3Npb25JdGVtKFwiYXN0cm9sb2d5X2FwaV9hdXRoX2Vycm9yXCIsIGhhc0Vycm9yID8gXCJ0cnVlXCIgOiBcImZhbHNlXCIpO1xuICBjb25zb2xlLmxvZyhcIkRlYnVnIC0gU2V0IEF1dGggRXJyb3I6XCIsIGhhc0Vycm9yKTtcbn1cblxuLy8gQ2hlY2sgaWYgd2UndmUgYWxyZWFkeSBlbmNvdW50ZXJlZCBhbiBhdXRoZW50aWNhdGlvbiBlcnJvclxuY29uc3QgaGFzQXV0aEVycm9yID0gKCk6IGJvb2xlYW4gPT4ge1xuICBjb25zdCBoYXNFcnJvciA9IHNhZmVHZXRTZXNzaW9uSXRlbShcImFzdHJvbG9neV9hcGlfYXV0aF9lcnJvclwiKSA9PT0gXCJ0cnVlXCI7XG4gIGNvbnNvbGUubG9nKFwiRGVidWcgLSBIYXMgQXV0aCBFcnJvcjpcIiwgaGFzRXJyb3IpO1xuICByZXR1cm4gaGFzRXJyb3I7XG59XG5cbi8vIENsZWFyIGFueSBzdG9yZWQgYXV0aGVudGljYXRpb24gZXJyb3JzXG5leHBvcnQgY29uc3QgY2xlYXJBdXRoRXJyb3JzID0gKCkgPT4ge1xuICBzYWZlUmVtb3ZlU2Vzc2lvbkl0ZW0oXCJhc3Ryb2xvZ3lfYXBpX2F1dGhfZXJyb3JcIik7XG4gIGNvbnNvbGUubG9nKFwiRGVidWcgLSBDbGVhcmVkIEF1dGggRXJyb3JzXCIpO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgQmFzaWMgQXV0aCBoZWFkZXJzIGZvciBBUEkgcmVxdWVzdHNcbiAqIEltcGxlbWVudHMgdGhlIHNhbWUgYXBwcm9hY2ggYXMgdGhlIHN1Y2Nlc3NmdWwgUHl0aG9uIGV4YW1wbGVcbiAqL1xuY29uc3QgZ2V0QXV0aEhlYWRlcnMgPSAoKTogUmVjb3JkPHN0cmluZywgc3RyaW5nPiA9PiB7XG4gIHRyeSB7XG4gICAgLy8gQ3JlYXRlIHRoZSBhdXRoIHN0cmluZyBpbiB0aGUgZm9ybWF0IFwidXNlcklkOmFwaUtleVwiXG4gICAgY29uc3QgYXV0aFN0cmluZyA9IGAke1VTRVJfSUR9OiR7QVBJX0tFWX1gXG4gICAgY29uc29sZS5sb2coXCJEZWJ1ZyAtIEF1dGggU3RyaW5nIEZvcm1hdDpcIiwgYCR7VVNFUl9JRH06QVBJX0tFWWApXG5cbiAgICAvLyBFbmNvZGUgdG8gYmFzZTY0IC0gc2ltaWxhciB0byBQeXRob24ncyBIVFRQQmFzaWNBdXRoXG4gICAgbGV0IGJhc2U2NEF1dGggPSBcIlwiXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93LmJ0b2EpIHtcbiAgICAgIGJhc2U2NEF1dGggPSB3aW5kb3cuYnRvYShhdXRoU3RyaW5nKVxuICAgICAgY29uc29sZS5sb2coXCJEZWJ1ZyAtIFVzaW5nIHdpbmRvdy5idG9hIGZvciBlbmNvZGluZ1wiKVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIEJ1ZmZlciAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgYmFzZTY0QXV0aCA9IEJ1ZmZlci5mcm9tKGF1dGhTdHJpbmcpLnRvU3RyaW5nKFwiYmFzZTY0XCIpXG4gICAgICBjb25zb2xlLmxvZyhcIkRlYnVnIC0gVXNpbmcgQnVmZmVyIGZvciBlbmNvZGluZ1wiKVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRGVidWcgLSBObyBtZXRob2QgYXZhaWxhYmxlIGZvciBiYXNlNjQgZW5jb2RpbmdcIilcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkJhc2U2NCBlbmNvZGluZyBub3QgYXZhaWxhYmxlXCIpXG4gICAgfVxuXG4gICAgY29uc29sZS5sb2coXCJEZWJ1ZyAtIEJhc2U2NCBBdXRoIChmaXJzdCAxMCBjaGFycyk6XCIsIGJhc2U2NEF1dGguc3Vic3RyaW5nKDAsIDEwKSArIFwiLi4uXCIpXG5cbiAgICAvLyBSZXR1cm4gaGVhZGVycyB3aXRoIEJhc2ljIEF1dGhcbiAgICByZXR1cm4ge1xuICAgICAgQXV0aG9yaXphdGlvbjogYEJhc2ljICR7YmFzZTY0QXV0aH1gLFxuICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBjcmVhdGluZyBhdXRoIGhlYWRlcnM6XCIsIGVycm9yKVxuICAgIHJldHVybiB7XG4gICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgIFwiQXV0aG9yaXphdGlvblwiOiBcIlwiLCAvLyBSZXR1cm4gZW1wdHkgc3RyaW5nIGluc3RlYWQgb2YgdW5kZWZpbmVkXG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogRmV0Y2hlcyBuYXRhbCBjaGFydCBkYXRhIGZyb20gQXN0cm9sb2d5QVBJXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBmZXRjaE5hdGFsQ2hhcnQoXG4gIGJpcnRoRGF0ZTogc3RyaW5nLFxuICBiaXJ0aFRpbWU6IHN0cmluZyxcbiAgbGF0aXR1ZGU6IG51bWJlcixcbiAgbG9uZ2l0dWRlOiBudW1iZXIsXG4gIHRpbWV6b25lID0gNS41LCAvLyBEZWZhdWx0IHRvIElTVFxuKTogUHJvbWlzZTxOYXRhbENoYXJ0PiB7XG4gIHRyeSB7XG4gICAgLy8gQ2hlY2sgZm9yIHByZXZpb3VzIGF1dGggZXJyb3JzIHRvIGF2b2lkIHJlcGVhdGVkIGZhaWxlZCBBUEkgY2FsbHNcbiAgICBpZiAoaGFzQXV0aEVycm9yKCkpIHtcbiAgICAgIGNvbnNvbGUud2FybihcIlNraXBwaW5nIEFQSSBjYWxsIGR1ZSB0byBwcmV2aW91cyBhdXRoZW50aWNhdGlvbiBlcnJvclwiKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQVBJIGF1dGhlbnRpY2F0aW9uIGVycm9yIC0gdXNpbmcgZmFsbGJhY2sgZGF0YVwiKVxuICAgIH1cblxuICAgIC8vIENoZWNrIGNyZWRlbnRpYWxzIGZpcnN0XG4gICAgaWYgKCFoYXNWYWxpZENyZWRlbnRpYWxzKCkpIHtcbiAgICAgIHNldEF1dGhFcnJvcih0cnVlKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQVBJIGNyZWRlbnRpYWxzIG5vdCBjb25maWd1cmVkXCIpXG4gICAgfVxuXG4gICAgLy8gRm9ybWF0IGRhdGUgYW5kIHRpbWUgZm9yIEFQSVxuICAgIGNvbnN0IFt5ZWFyLCBtb250aCwgZGF5XSA9IGJpcnRoRGF0ZS5zcGxpdChcIi1cIikubWFwKE51bWJlcilcbiAgICBjb25zdCBbaG91ciwgbWludXRlXSA9IGJpcnRoVGltZS5zcGxpdChcIjpcIikubWFwKE51bWJlcilcblxuICAgIC8vIFByZXBhcmUgdGhlIHJlcXVlc3QgYm9keVxuICAgIGNvbnN0IHJlcXVlc3RCb2R5ID0ge1xuICAgICAgZGF5LFxuICAgICAgbW9udGgsXG4gICAgICB5ZWFyLFxuICAgICAgaG91cixcbiAgICAgIG1pbjogbWludXRlLFxuICAgICAgbGF0OiBsYXRpdHVkZSxcbiAgICAgIGxvbjogbG9uZ2l0dWRlLFxuICAgICAgdHpvbmU6IHRpbWV6b25lLFxuICAgIH1cblxuICAgIGNvbnNvbGUubG9nKFwiRmV0Y2hpbmcgbmF0YWwgY2hhcnQgd2l0aCBwYXJhbXM6XCIsIHJlcXVlc3RCb2R5KVxuICAgIGNvbnNvbGUubG9nKFwiVXNpbmcgYXV0aCBoZWFkZXJzOlwiLCBnZXRBdXRoSGVhZGVycygpKVxuXG4gICAgLy8gTWFrZSB0aGUgQVBJIHJlcXVlc3QgZm9yIHBsYW5ldHNcbiAgICBjb25zdCBwbGFuZXRzUmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtBU1RST0xPR1lfQVBJX0JBU0VfVVJMfS9wbGFuZXRzYCwge1xuICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgIGhlYWRlcnM6IGdldEF1dGhIZWFkZXJzKCksXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShyZXF1ZXN0Qm9keSksXG4gICAgfSlcblxuICAgIC8vIFBhcnNlIHRoZSByZXNwb25zZSBldmVuIGlmIHN0YXR1cyBpcyBub3QgT0sgdG8gY2hlY2sgZm9yIGF1dGggZXJyb3JzXG4gICAgY29uc3QgcGxhbmV0c0RhdGEgPSBhd2FpdCBwbGFuZXRzUmVzcG9uc2UuanNvbigpXG5cbiAgICAvLyBDaGVjayBmb3IgYXV0aGVudGljYXRpb24gZXJyb3IgaW4gcmVzcG9uc2VcbiAgICBpZiAocGxhbmV0c0RhdGEuc3RhdHVzID09PSBmYWxzZSAmJiBwbGFuZXRzRGF0YS5tc2cpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJBUEkgZXJyb3I6XCIsIHBsYW5ldHNEYXRhLm1zZylcblxuICAgICAgLy8gQ2hlY2sgaWYgaXQncyBhbiBhdXRoZW50aWNhdGlvbiBlcnJvclxuICAgICAgaWYgKHBsYW5ldHNEYXRhLm1zZy5pbmNsdWRlcyhcImludmFsaWRcIikgfHwgcGxhbmV0c0RhdGEubXNnLmluY2x1ZGVzKFwiVXNlciBJRFwiKSkge1xuICAgICAgICBzZXRBdXRoRXJyb3IodHJ1ZSlcbiAgICAgIH1cblxuICAgICAgdGhyb3cgbmV3IEVycm9yKHBsYW5ldHNEYXRhLm1zZylcbiAgICB9XG5cbiAgICBpZiAoIXBsYW5ldHNSZXNwb25zZS5vaykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBQbGFuZXRzIEFQSSBlcnJvcjogJHtwbGFuZXRzUmVzcG9uc2Uuc3RhdHVzfSAke3BsYW5ldHNSZXNwb25zZS5zdGF0dXNUZXh0fWApXG4gICAgfVxuXG4gICAgLy8gRmV0Y2ggaG91c2VzIGRhdGFcbiAgICBjb25zdCBob3VzZXNSZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke0FTVFJPTE9HWV9BUElfQkFTRV9VUkx9L2hvdXNlc2AsIHtcbiAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICBoZWFkZXJzOiBnZXRBdXRoSGVhZGVycygpLFxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkocmVxdWVzdEJvZHkpLFxuICAgIH0pXG5cbiAgICBjb25zdCBob3VzZXNEYXRhID0gYXdhaXQgaG91c2VzUmVzcG9uc2UuanNvbigpXG5cbiAgICBpZiAoaG91c2VzRGF0YS5zdGF0dXMgPT09IGZhbHNlICYmIGhvdXNlc0RhdGEubXNnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoaG91c2VzRGF0YS5tc2cpXG4gICAgfVxuXG4gICAgaWYgKCFob3VzZXNSZXNwb25zZS5vaykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBIb3VzZXMgQVBJIGVycm9yOiAke2hvdXNlc1Jlc3BvbnNlLnN0YXR1c30gJHtob3VzZXNSZXNwb25zZS5zdGF0dXNUZXh0fWApXG4gICAgfVxuXG4gICAgLy8gRmV0Y2ggYXNwZWN0cyBkYXRhXG4gICAgY29uc3QgYXNwZWN0c1Jlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7QVNUUk9MT0dZX0FQSV9CQVNFX1VSTH0vYXNwZWN0c2AsIHtcbiAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICBoZWFkZXJzOiBnZXRBdXRoSGVhZGVycygpLFxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkocmVxdWVzdEJvZHkpLFxuICAgIH0pXG5cbiAgICBsZXQgYXNwZWN0c0RhdGEgPSBbXVxuICAgIGlmIChhc3BlY3RzUmVzcG9uc2Uub2spIHtcbiAgICAgIGFzcGVjdHNEYXRhID0gYXdhaXQgYXNwZWN0c1Jlc3BvbnNlLmpzb24oKVxuICAgIH1cblxuICAgIC8vIEZvcm1hdCB0aGUgZGF0YSBpbnRvIG91ciBhcHBsaWNhdGlvbidzIHN0cnVjdHVyZVxuICAgIHJldHVybiBmb3JtYXROYXRhbENoYXJ0UmVzcG9uc2UocGxhbmV0c0RhdGEsIGhvdXNlc0RhdGEsIGFzcGVjdHNEYXRhLCB7XG4gICAgICBkYXRlOiBiaXJ0aERhdGUsXG4gICAgICB0aW1lOiBiaXJ0aFRpbWUsXG4gICAgICBsb2NhdGlvbjoge1xuICAgICAgICBsYXRpdHVkZSxcbiAgICAgICAgbG9uZ2l0dWRlLFxuICAgICAgICBuYW1lOiBcIlwiLFxuICAgICAgfSxcbiAgICB9KVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBmZXRjaGluZyBuYXRhbCBjaGFydDpcIiwgZXJyb3IpXG4gICAgdGhyb3cgZXJyb3JcbiAgfVxufVxuXG4vKipcbiAqIEZldGNoZXMgbmF0YWwgd2hlZWwgY2hhcnQgZnJvbSBBc3Ryb2xvZ3lBUElcbiAqIFVwZGF0ZWQgdG8gaGFuZGxlIHRoZSBuZXcgcmVzcG9uc2UgZm9ybWF0IHRoYXQgcmV0dXJucyBhIGNoYXJ0IFVSTFxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZmV0Y2hOYXRhbFdoZWVsQ2hhcnQoXG4gIGJpcnRoRGF0ZTogc3RyaW5nLFxuICBiaXJ0aFRpbWU6IHN0cmluZyxcbiAgbGF0aXR1ZGU6IG51bWJlcixcbiAgbG9uZ2l0dWRlOiBudW1iZXIsXG4gIHRpbWV6b25lID0gNS41LCAvLyBEZWZhdWx0IHRvIElTVFxuICBzaWduX2ljb25fY29sb3I6IHN0cmluZyA9IFwiV0hJVEVcIixcbiAgc2lnbl9iYWNrZ3JvdW5kOiBzdHJpbmdbXSA9IFtcbiAgICBcImNsZWFyXCIsIFwiY2xlYXJcIiwgXCJjbGVhclwiLCBcImNsZWFyXCIsIFwiY2xlYXJcIiwgXCJjbGVhclwiLFxuICAgIFwiY2xlYXJcIiwgXCJjbGVhclwiLCBcImNsZWFyXCIsIFwiY2xlYXJcIiwgXCJjbGVhclwiLCBcImNsZWFyXCJcbiAgXVxuKTogUHJvbWlzZTx7IGNoYXJ0VXJsOiBzdHJpbmc7IHN2Z0NvbnRlbnQ/OiBzdHJpbmcgfT4ge1xuICB0cnkge1xuICAgIGNvbnNvbGUubG9nKFwiRGVidWcgLSBmZXRjaE5hdGFsV2hlZWxDaGFydCBjYWxsZWQgd2l0aDpcIiwgeyBiaXJ0aERhdGUsIGJpcnRoVGltZSwgbGF0aXR1ZGUsIGxvbmdpdHVkZSwgdGltZXpvbmUgfSlcblxuICAgIC8vIENoZWNrIGZvciBwcmV2aW91cyBhdXRoIGVycm9ycyB0byBhdm9pZCByZXBlYXRlZCBmYWlsZWQgQVBJIGNhbGxzXG4gICAgaWYgKGhhc0F1dGhFcnJvcigpKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJTa2lwcGluZyBBUEkgY2FsbCBkdWUgdG8gcHJldmlvdXMgYXV0aGVudGljYXRpb24gZXJyb3JcIilcblxuICAgICAgLy8gVXNlIHRoZSBnZW5lcmFsIGZhbGxiYWNrIFNWRyBmb3Igb3RoZXIgY2hhcnRzXG4gICAgICByZXR1cm4ge1xuICAgICAgICBjaGFydFVybDogXCJcIixcbiAgICAgICAgc3ZnQ29udGVudDogZ2V0RmFsbGJhY2tOYXRhbENoYXJ0KCksXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgY3JlZGVudGlhbHMgZmlyc3RcbiAgICBpZiAoIWhhc1ZhbGlkQ3JlZGVudGlhbHMoKSkge1xuICAgICAgY29uc29sZS53YXJuKFwiTWlzc2luZyBBUEkgY3JlZGVudGlhbHMgZm9yIEFzdHJvbG9neUFQSVwiKVxuICAgICAgc2V0QXV0aEVycm9yKHRydWUpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBUEkgY3JlZGVudGlhbHMgbm90IGNvbmZpZ3VyZWRcIilcbiAgICB9XG5cbiAgICAvLyBGb3JtYXQgZGF0ZSBhbmQgdGltZSBmb3IgQVBJXG4gICAgY29uc3QgW3llYXIsIG1vbnRoLCBkYXldID0gYmlydGhEYXRlLnNwbGl0KFwiLVwiKS5tYXAoTnVtYmVyKVxuICAgIGNvbnN0IFtob3VyLCBtaW51dGVdID0gYmlydGhUaW1lLnNwbGl0KFwiOlwiKS5tYXAoTnVtYmVyKVxuXG4gICAgLy8gUHJlcGFyZSB0aGUgcmVxdWVzdCBib2R5XG4gICAgY29uc3QgcmVxdWVzdEJvZHkgPSB7XG4gICAgICBkYXksXG4gICAgICBtb250aCxcbiAgICAgIHllYXIsXG4gICAgICBob3VyLFxuICAgICAgbWluOiBtaW51dGUsXG4gICAgICBsYXQ6IGxhdGl0dWRlLFxuICAgICAgbG9uOiBsb25naXR1ZGUsXG4gICAgICB0em9uZTogdGltZXpvbmUsXG4gICAgICBwbGFuZXRfaWNvbl9jb2xvcjogXCJCbGFja1wiLFxuICAgICAgc2lnbl9pY29uX2NvbG9yOiBcIkJsYWNrXCIsXG4gICAgICBzaWduX2JhY2tncm91bmQ6IFtcbiAgICAgICAgXCIjRjRGQUZDXCIsIFwiI0Y0RkFGQ1wiLCBcIiNGNEZBRkNcIiwgXCIjRjRGQUZDXCIsIFwiI0Y0RkFGQ1wiLCBcIiNGNEZBRkNcIixcbiAgICAgICAgXCIjRjRGQUZDXCIsIFwiI0Y0RkFGQ1wiLCBcIiNGNEZBRkNcIiwgXCIjRjRGQUZDXCIsIFwiI0Y0RkFGQ1wiLCBcIiNGNEZBRkNcIlxuICAgICAgXSxcbiAgICAgIGlubmVyX2NpcmNsZV9iYWNrZ3JvdW5kOiBcIiNGNEZBRkNcIixcbiAgICAgIG91dGVyX2NpcmNsZV9iYWNrZ3JvdW5kOiBcIiNGNEZBRkNcIixcbiAgICAgIGNoYXJ0X3NpemU6IDEwMDAsXG4gICAgICBpbWFnZV90eXBlOiBcInN2Z1wiXG4gICAgfVxuXG4gICAgY29uc29sZS5sb2coXCJEZWJ1ZyAtIFJlcXVlc3QgQm9keTpcIiwgcmVxdWVzdEJvZHkpXG5cbiAgICAvLyBHZXQgYXV0aCBoZWFkZXJzXG4gICAgY29uc3QgaGVhZGVycyA9IGdldEF1dGhIZWFkZXJzKClcbiAgICBjb25zb2xlLmxvZyhcIkRlYnVnIC0gSGVhZGVyczpcIiwge1xuICAgICAgQXV0aG9yaXphdGlvbjogaGVhZGVycy5BdXRob3JpemF0aW9uID8gXCJCYXNpYyAqKipcIiA6IFwiTWlzc2luZ1wiLFxuICAgICAgXCJDb250ZW50LVR5cGVcIjogaGVhZGVyc1tcIkNvbnRlbnQtVHlwZVwiXSxcbiAgICB9KVxuXG4gICAgLy8gTWFrZSB0aGUgQVBJIHJlcXVlc3RcbiAgICBjb25zb2xlLmxvZyhcIkRlYnVnIC0gRmV0Y2hpbmcgZnJvbSBVUkw6XCIsIGAke0FTVFJPTE9HWV9BUElfQkFTRV9VUkx9L25hdGFsX3doZWVsX2NoYXJ0YClcblxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7QVNUUk9MT0dZX0FQSV9CQVNFX1VSTH0vbmF0YWxfd2hlZWxfY2hhcnRgLCB7XG4gICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgaGVhZGVycyxcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHJlcXVlc3RCb2R5KSxcbiAgICB9KVxuXG4gICAgLy8gTG9nIHRoZSByZXNwb25zZSBzdGF0dXMgZm9yIGRlYnVnZ2luZ1xuICAgIGNvbnNvbGUubG9nKGBEZWJ1ZyAtIEFQSSBSZXNwb25zZSBTdGF0dXM6ICR7cmVzcG9uc2Uuc3RhdHVzfSAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YClcblxuICAgIC8vIEdldCB0aGUgcmF3IHJlc3BvbnNlIHRleHQgZmlyc3QgZm9yIGRlYnVnZ2luZ1xuICAgIGNvbnN0IHJhd1Jlc3BvbnNlVGV4dCA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKVxuICAgIGNvbnNvbGUubG9nKFwiRGVidWcgLSBSYXcgUmVzcG9uc2UgKGZpcnN0IDIwMCBjaGFycyk6XCIsIHJhd1Jlc3BvbnNlVGV4dC5zdWJzdHJpbmcoMCwgMjAwKSlcblxuICAgIC8vIFRyeSB0byBwYXJzZSB0aGUgcmVzcG9uc2UgYXMgSlNPTlxuICAgIGxldCBkYXRhXG4gICAgdHJ5IHtcbiAgICAgIGRhdGEgPSBKU09OLnBhcnNlKHJhd1Jlc3BvbnNlVGV4dClcbiAgICAgIGNvbnNvbGUubG9nKFwiRGVidWcgLSBSZXNwb25zZSBLZXlzOlwiLCBPYmplY3Qua2V5cyhkYXRhKSlcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRGVidWcgLSBGYWlsZWQgdG8gcGFyc2UgcmVzcG9uc2UgYXMgSlNPTjpcIiwgZSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIHBhcnNlIEFQSSByZXNwb25zZSBhcyBKU09OOiAke3Jhd1Jlc3BvbnNlVGV4dC5zdWJzdHJpbmcoMCwgMTAwKX0uLi5gKVxuICAgIH1cblxuICAgIC8vIENoZWNrIGZvciBlcnJvciBpbiByZXNwb25zZVxuICAgIGlmIChkYXRhLnN0YXR1cyA9PT0gZmFsc2UgJiYgZGF0YS5tc2cpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJBUEkgZXJyb3I6XCIsIGRhdGEubXNnKVxuXG4gICAgICAvLyBDaGVjayBpZiBpdCdzIGFuIGF1dGhlbnRpY2F0aW9uIGVycm9yXG4gICAgICBpZiAoZGF0YS5tc2cuaW5jbHVkZXMoXCJpbnZhbGlkXCIpIHx8IGRhdGEubXNnLmluY2x1ZGVzKFwiVXNlciBJRFwiKSkge1xuICAgICAgICBzZXRBdXRoRXJyb3IodHJ1ZSlcbiAgICAgIH1cblxuICAgICAgdGhyb3cgbmV3IEVycm9yKGRhdGEubXNnKVxuICAgIH1cblxuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgTmF0YWwgd2hlZWwgY2hhcnQgQVBJIGVycm9yOiAke3Jlc3BvbnNlLnN0YXR1c30gJHtyZXNwb25zZS5zdGF0dXNUZXh0fWApXG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgaWYgd2UgaGF2ZSB0aGUgY2hhcnRfdXJsIGluIHRoZSByZXNwb25zZVxuICAgIGlmIChkYXRhLmNoYXJ0X3VybCkge1xuICAgICAgY29uc29sZS5sb2coXCJEZWJ1ZyAtIFN1Y2Nlc3NmdWxseSByZXRyaWV2ZWQgY2hhcnQgVVJMOlwiLCBkYXRhLmNoYXJ0X3VybClcblxuICAgICAgLy8gQ2xlYXIgYW55IHN0b3JlZCBhdXRoIGVycm9ycyBzaW5jZSB0aGUgcmVxdWVzdCBzdWNjZWVkZWRcbiAgICAgIGNsZWFyQXV0aEVycm9ycygpXG5cbiAgICAgIHJldHVybiB7IGNoYXJ0VXJsOiBkYXRhLmNoYXJ0X3VybCB9XG4gICAgfVxuICAgIC8vIEZhbGxiYWNrIHRvIHRoZSBvbGQgZm9ybWF0IGlmIHN2ZyBwcm9wZXJ0eSBleGlzdHNcbiAgICBlbHNlIGlmIChkYXRhLnN2Zykge1xuICAgICAgY29uc29sZS5sb2coXCJEZWJ1ZyAtIFJldHJpZXZlZCBTVkcgY29udGVudCBpbnN0ZWFkIG9mIFVSTCwgbGVuZ3RoOlwiLCBkYXRhLnN2Zy5sZW5ndGgpXG5cbiAgICAgIC8vIENsZWFyIGFueSBzdG9yZWQgYXV0aCBlcnJvcnMgc2luY2UgdGhlIHJlcXVlc3Qgc3VjY2VlZGVkXG4gICAgICBjbGVhckF1dGhFcnJvcnMoKVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBjaGFydFVybDogXCJcIixcbiAgICAgICAgc3ZnQ29udGVudDogZGF0YS5zdmcsXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJBUEkgcmVzcG9uc2UgbWlzc2luZyBjaGFydF91cmwgYW5kIHN2ZyBkYXRhOlwiLCBkYXRhKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gY2hhcnQgZGF0YSByZXR1cm5lZCBmcm9tIHRoZSBBUElcIilcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihcIkVycm9yIGZldGNoaW5nIG5hdGFsIHdoZWVsIGNoYXJ0OlwiLCBlcnJvcilcblxuICAgIC8vIFVzZSB0aGUgZ2VuZXJhbCBmYWxsYmFjayBTVkcgZm9yIG90aGVyIGNoYXJ0c1xuICAgIHJldHVybiB7XG4gICAgICBjaGFydFVybDogXCJcIixcbiAgICAgIHN2Z0NvbnRlbnQ6IGdldEZhbGxiYWNrTmF0YWxDaGFydCgpLFxuICAgIH1cbiAgfVxufVxuXG4vLyBLZWVwIHRoZSBvbGQgZnVuY3Rpb24gZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHlcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBmZXRjaE5hdGFsV2hlZWxDaGFydFNWRyhcbiAgYmlydGhEYXRlOiBzdHJpbmcsXG4gIGJpcnRoVGltZTogc3RyaW5nLFxuICBsYXRpdHVkZTogbnVtYmVyLFxuICBsb25naXR1ZGU6IG51bWJlcixcbiAgdGltZXpvbmUgPSA1LjUsIC8vIERlZmF1bHQgdG8gSVNUXG4pOiBQcm9taXNlPHN0cmluZz4ge1xuICB0cnkge1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGZldGNoTmF0YWxXaGVlbENoYXJ0KGJpcnRoRGF0ZSwgYmlydGhUaW1lLCBsYXRpdHVkZSwgbG9uZ2l0dWRlLCB0aW1lem9uZSlcblxuICAgIC8vIElmIHdlIGhhdmUgU1ZHIGNvbnRlbnQsIHJldHVybiBpdFxuICAgIGlmIChyZXN1bHQuc3ZnQ29udGVudCkge1xuICAgICAgcmV0dXJuIHJlc3VsdC5zdmdDb250ZW50XG4gICAgfVxuXG4gICAgLy8gSWYgd2UgaGF2ZSBhIGNoYXJ0IFVSTCwgZmV0Y2ggdGhlIFNWRyBjb250ZW50XG4gICAgaWYgKHJlc3VsdC5jaGFydFVybCkge1xuICAgICAgY29uc29sZS5sb2coXCJEZWJ1ZyAtIEZldGNoaW5nIFNWRyBjb250ZW50IGZyb20gVVJMOlwiLCByZXN1bHQuY2hhcnRVcmwpXG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHN2Z1Jlc3BvbnNlID0gYXdhaXQgZmV0Y2gocmVzdWx0LmNoYXJ0VXJsKVxuICAgICAgICBpZiAoIXN2Z1Jlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZmV0Y2ggU1ZHIGZyb20gVVJMOiAke3N2Z1Jlc3BvbnNlLnN0YXR1c30gJHtzdmdSZXNwb25zZS5zdGF0dXNUZXh0fWApXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBzdmdDb250ZW50ID0gYXdhaXQgc3ZnUmVzcG9uc2UudGV4dCgpXG4gICAgICAgIGNvbnNvbGUubG9nKFwiRGVidWcgLSBTdWNjZXNzZnVsbHkgZmV0Y2hlZCBTVkcgY29udGVudCwgbGVuZ3RoOlwiLCBzdmdDb250ZW50Lmxlbmd0aClcblxuICAgICAgICByZXR1cm4gc3ZnQ29udGVudFxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGZldGNoaW5nIFNWRyBmcm9tIFVSTDpcIiwgZXJyb3IpXG5cbiAgICAgICAgLy8gUmV0dXJuIGZhbGxiYWNrIFNWRyBpZiB3ZSBjYW4ndCBmZXRjaCBmcm9tIFVSTFxuICAgICAgICByZXR1cm4gZ2V0RmFsbGJhY2tOYXRhbENoYXJ0KClcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSZXR1cm4gZmFsbGJhY2sgU1ZHIGlmIG5vIGNoYXJ0IGRhdGEgYXZhaWxhYmxlXG4gICAgcmV0dXJuIGdldEZhbGxiYWNrTmF0YWxDaGFydCgpXG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihcIkVycm9yIGluIGZldGNoTmF0YWxXaGVlbENoYXJ0U1ZHOlwiLCBlcnJvcilcblxuICAgIC8vIFJldHVybiBmYWxsYmFjayBTVkcgZm9yIG90aGVyIGNoYXJ0c1xuICAgIHJldHVybiBnZXRGYWxsYmFja05hdGFsQ2hhcnQoKVxuICB9XG59XG5cbi8qKlxuICogR2VvY29kZXMgYSBsb2NhdGlvbiBzdHJpbmcgdG8gZ2V0IGxhdGl0dWRlIGFuZCBsb25naXR1ZGUgdXNpbmcgQXN0cm9sb2d5QVBJXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZW9jb2RlTG9jYXRpb24obG9jYXRpb246IHN0cmluZyk6IFByb21pc2U8eyBsYXRpdHVkZTogbnVtYmVyOyBsb25naXR1ZGU6IG51bWJlcjsgbmFtZTogc3RyaW5nIH0+IHtcbiAgdHJ5IHtcbiAgICBjb25zb2xlLmxvZyhcIkdlb2NvZGluZyBsb2NhdGlvbjpcIiwgbG9jYXRpb24pO1xuXG4gICAgaWYgKCFoYXNWYWxpZENyZWRlbnRpYWxzKCkpIHtcbiAgICAgIGNvbnNvbGUud2FybihcIk1pc3NpbmcgQVBJIGNyZWRlbnRpYWxzIGZvciBBc3Ryb2xvZ3lBUElcIik7XG4gICAgICBzZXRBdXRoRXJyb3IodHJ1ZSk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBUEkgY3JlZGVudGlhbHMgbm90IGNvbmZpZ3VyZWRcIik7XG4gICAgfVxuXG4gICAgY29uc3QgaGVhZGVycyA9IGdldEF1dGhIZWFkZXJzKCk7XG4gICAgY29uc29sZS5sb2coXCJVc2luZyBhdXRoIGhlYWRlcnM6XCIsIGhlYWRlcnMpO1xuXG4gICAgLy8gVXNlIEdFVCwgbm90IFBPU1RcbiAgICBjb25zdCB1cmwgPSBgJHtBU1RST0xPR1lfQVBJX0JBU0VfVVJMfS9nZW9fZGV0YWlscz9wbGFjZT0ke2VuY29kZVVSSUNvbXBvbmVudChsb2NhdGlvbil9YDtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwge1xuICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgaGVhZGVycyxcbiAgICB9KTtcblxuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJHZW9jb2RpbmcgQVBJIGVycm9yOlwiLCByZXNwb25zZS5zdGF0dXMpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBHZW9jb2RpbmcgQVBJIGVycm9yOiAke3Jlc3BvbnNlLnN0YXR1c31gKTtcbiAgICB9XG5cbiAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuXG4gICAgaWYgKCFkYXRhIHx8ICFkYXRhLmxhdGl0dWRlIHx8ICFkYXRhLmxvbmdpdHVkZSkge1xuICAgICAgY29uc29sZS5lcnJvcihcIkludmFsaWQgZ2VvY29kaW5nIHJlc3BvbnNlOlwiLCBkYXRhKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgZ2VvY29kaW5nIHJlc3BvbnNlXCIpO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBsYXRpdHVkZTogZGF0YS5sYXRpdHVkZSxcbiAgICAgIGxvbmdpdHVkZTogZGF0YS5sb25naXR1ZGUsXG4gICAgICBuYW1lOiBkYXRhLm5hbWUgfHwgbG9jYXRpb24sXG4gICAgfTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgZ2VvY29kaW5nIGxvY2F0aW9uOlwiLCBlcnJvcik7XG4gICAgLy8gRmFsbGJhY2s6IExhcyBWZWdhc1xuICAgIHJldHVybiB7XG4gICAgICBsYXRpdHVkZTogMzYuMTY5OSxcbiAgICAgIGxvbmdpdHVkZTogLTExNS4xMzk4LFxuICAgICAgbmFtZTogbG9jYXRpb24sXG4gICAgfTtcbiAgfVxufVxuXG4vKipcbiAqIEZvcm1hdHMgdGhlIEFQSSByZXNwb25zZSBpbnRvIG91ciBhcHBsaWNhdGlvbidzIGRhdGEgc3RydWN0dXJlXG4gKi9cbmZ1bmN0aW9uIGZvcm1hdE5hdGFsQ2hhcnRSZXNwb25zZShcbiAgcGxhbmV0c0RhdGE6IGFueVtdLFxuICBob3VzZXNEYXRhOiBhbnksXG4gIGFzcGVjdHNEYXRhOiBhbnlbXSxcbiAgYmlydGhEZXRhaWxzOiBhbnksXG4pOiBOYXRhbENoYXJ0IHtcbiAgLy8gRXh0cmFjdCBhbmQgZm9ybWF0IHBsYW5ldCBwb3NpdGlvbnNcbiAgY29uc3QgcGxhbmV0czogUGxhbmV0UG9zaXRpb25bXSA9IHBsYW5ldHNEYXRhLm1hcCgocGxhbmV0KSA9PiB7XG4gICAgLy8gQ29udmVydCBwbGFuZXQgbmFtZSB0byBvdXIgZm9ybWF0XG4gICAgY29uc3QgcGxhbmV0TmFtZSA9IGNvbnZlcnRQbGFuZXROYW1lKHBsYW5ldC5uYW1lKVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6IHBsYW5ldE5hbWUsXG4gICAgICBzaWduOiBwbGFuZXQuc2lnbi50b0xvd2VyQ2FzZSgpIGFzIFpvZGlhY1NpZ24sXG4gICAgICBkZWdyZWU6IHBsYW5ldC5ub3JtX2RlZ3JlZSxcbiAgICAgIGhvdXNlOiBwbGFuZXQuaG91c2UsXG4gICAgICByZXRyb2dyYWRlOiBwbGFuZXQuaXNfcmV0cm9ncmFkZSA9PT0gMSxcbiAgICAgIGFzcGVjdHNUb090aGVyUGxhbmV0czogW10sXG4gICAgfVxuICB9KVxuXG4gIC8vIEV4dHJhY3QgYW5kIGZvcm1hdCBob3VzZXNcbiAgY29uc3QgaG91c2VzOiBIb3VzZVtdID0gT2JqZWN0LmtleXMoaG91c2VzRGF0YSkubWFwKChrZXkpID0+IHtcbiAgICBjb25zdCBob3VzZSA9IGhvdXNlc0RhdGFba2V5XVxuICAgIHJldHVybiB7XG4gICAgICBudW1iZXI6IE51bWJlci5wYXJzZUludChrZXkucmVwbGFjZShcImhvdXNlXCIsIFwiXCIpKSxcbiAgICAgIHNpZ246IGhvdXNlLnNpZ24udG9Mb3dlckNhc2UoKSBhcyBab2RpYWNTaWduLFxuICAgICAgZGVncmVlOiBob3VzZS5kZWdyZWUsXG4gICAgICBjdXNwOiB0cnVlLFxuICAgIH1cbiAgfSlcblxuICAvLyBFeHRyYWN0IGFuZCBmb3JtYXQgYW5nbGVzIChBc2NlbmRhbnQsIE1pZGhlYXZlbiwgZXRjLilcbiAgY29uc3QgYW5nbGVzOiBSZWNvcmQ8c3RyaW5nLCBBbmdsZT4gPSB7XG4gICAgYXNjZW5kYW50OiB7XG4gICAgICBzaWduOiBob3VzZXNEYXRhLmFzY2VuZGFudC5zaWduLnRvTG93ZXJDYXNlKCkgYXMgWm9kaWFjU2lnbixcbiAgICAgIGRlZ3JlZTogaG91c2VzRGF0YS5hc2NlbmRhbnQuZGVncmVlLFxuICAgIH0sXG4gICAgbWlkaGVhdmVuOiB7XG4gICAgICBzaWduOiBob3VzZXNEYXRhLm1pZGhlYXZlbi5zaWduLnRvTG93ZXJDYXNlKCkgYXMgWm9kaWFjU2lnbixcbiAgICAgIGRlZ3JlZTogaG91c2VzRGF0YS5taWRoZWF2ZW4uZGVncmVlLFxuICAgIH0sXG4gICAgZGVzY2VuZGFudDoge1xuICAgICAgc2lnbjogZ2V0T3Bwb3NpdGVTaWduKGhvdXNlc0RhdGEuYXNjZW5kYW50LnNpZ24udG9Mb3dlckNhc2UoKSBhcyBab2RpYWNTaWduKSxcbiAgICAgIGRlZ3JlZTogKGhvdXNlc0RhdGEuYXNjZW5kYW50LmRlZ3JlZSArIDE4MCkgJSAzNjAsXG4gICAgfSxcbiAgICBpbXVtQ29lbGk6IHtcbiAgICAgIHNpZ246IGdldE9wcG9zaXRlU2lnbihob3VzZXNEYXRhLm1pZGhlYXZlbi5zaWduLnRvTG93ZXJDYXNlKCkgYXMgWm9kaWFjU2lnbiksXG4gICAgICBkZWdyZWU6IChob3VzZXNEYXRhLm1pZGhlYXZlbi5kZWdyZWUgKyAxODApICUgMzYwLFxuICAgIH0sXG4gIH1cblxuICAvLyBGb3JtYXQgYXNwZWN0cyBkYXRhXG4gIGNvbnN0IGFzcGVjdHMgPSBhc3BlY3RzRGF0YS5tYXAoKGFzcGVjdCkgPT4gKHtcbiAgICBhc3BlY3Q6IGFzcGVjdC5hc3BlY3QudG9Mb3dlckNhc2UoKSxcbiAgICBwbGFuZXQxOiBjb252ZXJ0UGxhbmV0TmFtZShhc3BlY3QucGxhbmV0MSksXG4gICAgcGxhbmV0MjogY29udmVydFBsYW5ldE5hbWUoYXNwZWN0LnBsYW5ldDIpLFxuICAgIG9yYjogYXNwZWN0Lm9yYixcbiAgICBhcHBseWluZzogYXNwZWN0LmFwcGx5aW5nID09PSAxLFxuICB9KSlcblxuICByZXR1cm4ge1xuICAgIHBsYW5ldHMsXG4gICAgaG91c2VzLFxuICAgIGFuZ2xlcyxcbiAgICBhc3BlY3RzLFxuICAgIGJpcnRoRGV0YWlscyxcbiAgfVxufVxuXG4vKipcbiAqIENvbnZlcnRzIEFzdHJvbG9neUFQSSBwbGFuZXQgbmFtZXMgdG8gb3VyIGFwcGxpY2F0aW9uJ3MgZm9ybWF0XG4gKi9cbmZ1bmN0aW9uIGNvbnZlcnRQbGFuZXROYW1lKGFwaVBsYW5ldE5hbWU6IHN0cmluZyk6IHN0cmluZyB7XG4gIGNvbnN0IHBsYW5ldE1hcDogUmVjb3JkPHN0cmluZywgc3RyaW5nPiA9IHtcbiAgICBTdW46IFwic3VuXCIsXG4gICAgTW9vbjogXCJtb29uXCIsXG4gICAgTWVyY3VyeTogXCJtZXJjdXJ5XCIsXG4gICAgVmVudXM6IFwidmVudXNcIixcbiAgICBNYXJzOiBcIm1hcnNcIixcbiAgICBKdXBpdGVyOiBcImp1cGl0ZXJcIixcbiAgICBTYXR1cm46IFwic2F0dXJuXCIsXG4gICAgVXJhbnVzOiBcInVyYW51c1wiLFxuICAgIE5lcHR1bmU6IFwibmVwdHVuZVwiLFxuICAgIFBsdXRvOiBcInBsdXRvXCIsXG4gICAgUmFodTogXCJub3J0aF9ub2RlXCIsXG4gICAgS2V0dTogXCJzb3V0aF9ub2RlXCIsXG4gIH1cblxuICByZXR1cm4gcGxhbmV0TWFwW2FwaVBsYW5ldE5hbWVdIHx8IGFwaVBsYW5ldE5hbWUudG9Mb3dlckNhc2UoKVxufVxuXG4vKipcbiAqIEdldHMgdGhlIG9wcG9zaXRlIHpvZGlhYyBzaWduXG4gKi9cbmZ1bmN0aW9uIGdldE9wcG9zaXRlU2lnbihzaWduOiBab2RpYWNTaWduKTogWm9kaWFjU2lnbiB7XG4gIGNvbnN0IHpvZGlhY1NpZ25zOiBab2RpYWNTaWduW10gPSBbXG4gICAgXCJhcmllc1wiLFxuICAgIFwidGF1cnVzXCIsXG4gICAgXCJnZW1pbmlcIixcbiAgICBcImNhbmNlclwiLFxuICAgIFwibGVvXCIsXG4gICAgXCJ2aXJnb1wiLFxuICAgIFwibGlicmFcIixcbiAgICBcInNjb3JwaW9cIixcbiAgICBcInNhZ2l0dGFyaXVzXCIsXG4gICAgXCJjYXByaWNvcm5cIixcbiAgICBcImFxdWFyaXVzXCIsXG4gICAgXCJwaXNjZXNcIixcbiAgXVxuXG4gIGNvbnN0IGluZGV4ID0gem9kaWFjU2lnbnMuaW5kZXhPZihzaWduKVxuICBpZiAoaW5kZXggPT09IC0xKSByZXR1cm4gXCJhcmllc1wiIC8vIERlZmF1bHQgZmFsbGJhY2tcblxuICBjb25zdCBvcHBvc2l0ZUluZGV4ID0gKGluZGV4ICsgNikgJSAxMlxuICByZXR1cm4gem9kaWFjU2lnbnNbb3Bwb3NpdGVJbmRleF1cbn1cblxuLyoqXG4gKiBHZXRzIGludGVycHJldGF0aW9ucyBmb3IgYSBuYXRhbCBjaGFydFxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0TmF0YWxDaGFydEludGVycHJldGF0aW9uKG5hdGFsQ2hhcnQ6IE5hdGFsQ2hhcnQpOiBQcm9taXNlPGFueT4ge1xuICB0cnkge1xuICAgIC8vIFRoaXMgd291bGQgYmUgaW1wbGVtZW50ZWQgdG8gZmV0Y2ggaW50ZXJwcmV0YXRpb25zIGZyb20gQXN0cm9sb2d5QVBJXG4gICAgLy8gRm9yIG5vdywgd2UnbGwgcmV0dXJuIGEgcGxhY2Vob2xkZXIgaW50ZXJwcmV0YXRpb25cbiAgICByZXR1cm4ge1xuICAgICAgb3ZlcnZpZXc6IHtcbiAgICAgICAgdGl0bGU6IFwiWW91ciBDb3NtaWMgQmx1ZXByaW50XCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOlxuICAgICAgICAgIFwiWW91ciBuYXRhbCBjaGFydCByZXZlYWxzIHlvdXIgdW5pcXVlIGNvc21pYyBibHVlcHJpbnQsIHNob3dpbmcgdGhlIHBvc2l0aW9ucyBvZiB0aGUgcGxhbmV0cyBhdCB0aGUgbW9tZW50IG9mIHlvdXIgYmlydGguIFRoaXMgY2VsZXN0aWFsIHNuYXBzaG90IG9mZmVycyBpbnNpZ2h0cyBpbnRvIHlvdXIgcGVyc29uYWxpdHksIHN0cmVuZ3RocywgY2hhbGxlbmdlcywgYW5kIGxpZmUgcGF0aC5cIixcbiAgICAgIH0sXG4gICAgICBzdW5TaWduOiB7XG4gICAgICAgIHRpdGxlOiBcIlN1biBTaWduXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIllvdXIgU3VuIHNpZ24gcmVwcmVzZW50cyB5b3VyIGNvcmUgZXNzZW5jZSBhbmQgbGlmZSBwdXJwb3NlLlwiLFxuICAgICAgICBrZXl3b3JkczogW1wiaWRlbnRpdHlcIiwgXCJwdXJwb3NlXCIsIFwidml0YWxpdHlcIl0sXG4gICAgICB9LFxuICAgICAgbW9vblNpZ246IHtcbiAgICAgICAgdGl0bGU6IFwiTW9vbiBTaWduXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIllvdXIgTW9vbiBzaWduIHJlZmxlY3RzIHlvdXIgZW1vdGlvbmFsIG5hdHVyZSBhbmQgc3ViY29uc2Npb3VzIHBhdHRlcm5zLlwiLFxuICAgICAgICBrZXl3b3JkczogW1wiZW1vdGlvbnNcIiwgXCJpbnN0aW5jdHNcIiwgXCJjb21mb3J0XCJdLFxuICAgICAgfSxcbiAgICAgIGFzY2VuZGFudFNpZ246IHtcbiAgICAgICAgdGl0bGU6IFwiQXNjZW5kYW50XCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIllvdXIgQXNjZW5kYW50IHJlcHJlc2VudHMgaG93IHlvdSBwcmVzZW50IHlvdXJzZWxmIHRvIHRoZSB3b3JsZC5cIixcbiAgICAgICAga2V5d29yZHM6IFtcImFwcGVhcmFuY2VcIiwgXCJmaXJzdCBpbXByZXNzaW9uc1wiLCBcInBlcnNvbmFsIHN0eWxlXCJdLFxuICAgICAgfSxcbiAgICAgIHBsYW5ldFBvc2l0aW9uczoge1xuICAgICAgICBzdW46IHtcbiAgICAgICAgICBkZXNjcmlwdGlvbjogXCJZb3VyIFN1biBwbGFjZW1lbnQgaW5kaWNhdGVzIHlvdXIgY29yZSBpZGVudGl0eSBhbmQgcHVycG9zZSBpbiBsaWZlLlwiLFxuICAgICAgICAgIGtleXdvcmRzOiBbXCJpZGVudGl0eVwiLCBcInB1cnBvc2VcIiwgXCJ2aXRhbGl0eVwiXSxcbiAgICAgICAgfSxcbiAgICAgICAgbW9vbjoge1xuICAgICAgICAgIGRlc2NyaXB0aW9uOiBcIllvdXIgTW9vbiBwbGFjZW1lbnQgcmV2ZWFscyB5b3VyIGVtb3Rpb25hbCBuYXR1cmUgYW5kIHN1YmNvbnNjaW91cyBwYXR0ZXJucy5cIixcbiAgICAgICAgICBrZXl3b3JkczogW1wiZW1vdGlvbnNcIiwgXCJpbnN0aW5jdHNcIiwgXCJjb21mb3J0XCJdLFxuICAgICAgICB9LFxuICAgICAgICBtZXJjdXJ5OiB7XG4gICAgICAgICAgZGVzY3JpcHRpb246IFwiWW91ciBNZXJjdXJ5IHBsYWNlbWVudCBzaG93cyBob3cgeW91IHRoaW5rIGFuZCBjb21tdW5pY2F0ZS5cIixcbiAgICAgICAgICBrZXl3b3JkczogW1wiY29tbXVuaWNhdGlvblwiLCBcInRoaW5raW5nXCIsIFwibGVhcm5pbmdcIl0sXG4gICAgICAgIH0sXG4gICAgICAgIHZlbnVzOiB7XG4gICAgICAgICAgZGVzY3JpcHRpb246IFwiWW91ciBWZW51cyBwbGFjZW1lbnQgaW5kaWNhdGVzIGhvdyB5b3UgZXhwcmVzcyBhbmQgcmVjZWl2ZSBsb3ZlIGFuZCBiZWF1dHkuXCIsXG4gICAgICAgICAga2V5d29yZHM6IFtcImxvdmVcIiwgXCJiZWF1dHlcIiwgXCJ2YWx1ZXNcIl0sXG4gICAgICAgIH0sXG4gICAgICAgIG1hcnM6IHtcbiAgICAgICAgICBkZXNjcmlwdGlvbjogXCJZb3VyIE1hcnMgcGxhY2VtZW50IHNob3dzIGhvdyB5b3UgYXNzZXJ0IHlvdXJzZWxmIGFuZCB0YWtlIGFjdGlvbi5cIixcbiAgICAgICAgICBrZXl3b3JkczogW1wiYWN0aW9uXCIsIFwiZGVzaXJlXCIsIFwiZW5lcmd5XCJdLFxuICAgICAgICB9LFxuICAgICAgICBqdXBpdGVyOiB7XG4gICAgICAgICAgZGVzY3JpcHRpb246IFwiWW91ciBKdXBpdGVyIHBsYWNlbWVudCByZXZlYWxzIHdoZXJlIHlvdSBmaW5kIGdyb3d0aCBhbmQgZXhwYW5zaW9uLlwiLFxuICAgICAgICAgIGtleXdvcmRzOiBbXCJncm93dGhcIiwgXCJsdWNrXCIsIFwiYWJ1bmRhbmNlXCJdLFxuICAgICAgICB9LFxuICAgICAgICBzYXR1cm46IHtcbiAgICAgICAgICBkZXNjcmlwdGlvbjogXCJZb3VyIFNhdHVybiBwbGFjZW1lbnQgaW5kaWNhdGVzIHdoZXJlIHlvdSBmYWNlIGNoYWxsZW5nZXMgYW5kIGxlYXJuIGRpc2NpcGxpbmUuXCIsXG4gICAgICAgICAga2V5d29yZHM6IFtcImRpc2NpcGxpbmVcIiwgXCJyZXNwb25zaWJpbGl0eVwiLCBcInN0cnVjdHVyZVwiXSxcbiAgICAgICAgfSxcbiAgICAgICAgdXJhbnVzOiB7XG4gICAgICAgICAgZGVzY3JpcHRpb246IFwiWW91ciBVcmFudXMgcGxhY2VtZW50IHNob3dzIHdoZXJlIHlvdSBzZWVrIGZyZWVkb20gYW5kIGlubm92YXRpb24uXCIsXG4gICAgICAgICAga2V5d29yZHM6IFtcImlubm92YXRpb25cIiwgXCJyZWJlbGxpb25cIiwgXCJjaGFuZ2VcIl0sXG4gICAgICAgIH0sXG4gICAgICAgIG5lcHR1bmU6IHtcbiAgICAgICAgICBkZXNjcmlwdGlvbjogXCJZb3VyIE5lcHR1bmUgcGxhY2VtZW50IHJldmVhbHMgeW91ciBzcGlyaXR1YWwgYW5kIGNyZWF0aXZlIGFzcGlyYXRpb25zLlwiLFxuICAgICAgICAgIGtleXdvcmRzOiBbXCJzcGlyaXR1YWxpdHlcIiwgXCJkcmVhbXNcIiwgXCJpbGx1c2lvblwiXSxcbiAgICAgICAgfSxcbiAgICAgICAgcGx1dG86IHtcbiAgICAgICAgICBkZXNjcmlwdGlvbjogXCJZb3VyIFBsdXRvIHBsYWNlbWVudCBpbmRpY2F0ZXMgd2hlcmUgeW91IGV4cGVyaWVuY2UgdHJhbnNmb3JtYXRpb24gYW5kIHBvd2VyLlwiLFxuICAgICAgICAgIGtleXdvcmRzOiBbXCJ0cmFuc2Zvcm1hdGlvblwiLCBcInBvd2VyXCIsIFwicmViaXJ0aFwiXSxcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgICBob3VzZXM6IHtcbiAgICAgICAgMToge1xuICAgICAgICAgIGRlc2NyaXB0aW9uOiBcIlRoZSAxc3QgaG91c2UgcmVwcmVzZW50cyB5b3VyIHNlbGYtaW1hZ2UgYW5kIGhvdyB5b3UgcHJlc2VudCB5b3Vyc2VsZiB0byB0aGUgd29ybGQuXCIsXG4gICAgICAgIH0sXG4gICAgICAgIDI6IHtcbiAgICAgICAgICBkZXNjcmlwdGlvbjogXCJUaGUgMm5kIGhvdXNlIHJlcHJlc2VudHMgeW91ciB2YWx1ZXMsIHBvc3Nlc3Npb25zLCBhbmQgcmVzb3VyY2VzLlwiLFxuICAgICAgICB9LFxuICAgICAgICAzOiB7XG4gICAgICAgICAgZGVzY3JpcHRpb246IFwiVGhlIDNyZCBob3VzZSByZXByZXNlbnRzIGNvbW11bmljYXRpb24sIGxlYXJuaW5nLCBhbmQgeW91ciBpbW1lZGlhdGUgZW52aXJvbm1lbnQuXCIsXG4gICAgICAgIH0sXG4gICAgICAgIDQ6IHtcbiAgICAgICAgICBkZXNjcmlwdGlvbjogXCJUaGUgNHRoIGhvdXNlIHJlcHJlc2VudHMgeW91ciBob21lLCBmYW1pbHksIGFuZCBlbW90aW9uYWwgZm91bmRhdGlvbnMuXCIsXG4gICAgICAgIH0sXG4gICAgICAgIDU6IHtcbiAgICAgICAgICBkZXNjcmlwdGlvbjogXCJUaGUgNXRoIGhvdXNlIHJlcHJlc2VudHMgY3JlYXRpdml0eSwgcGxlYXN1cmUsIGFuZCBzZWxmLWV4cHJlc3Npb24uXCIsXG4gICAgICAgIH0sXG4gICAgICAgIDY6IHtcbiAgICAgICAgICBkZXNjcmlwdGlvbjogXCJUaGUgNnRoIGhvdXNlIHJlcHJlc2VudHMgd29yaywgaGVhbHRoLCBhbmQgZGFpbHkgcm91dGluZXMuXCIsXG4gICAgICAgIH0sXG4gICAgICAgIDc6IHtcbiAgICAgICAgICBkZXNjcmlwdGlvbjogXCJUaGUgN3RoIGhvdXNlIHJlcHJlc2VudHMgcGFydG5lcnNoaXBzLCByZWxhdGlvbnNoaXBzLCBhbmQgb3BlbiBlbmVtaWVzLlwiLFxuICAgICAgICB9LFxuICAgICAgICA4OiB7XG4gICAgICAgICAgZGVzY3JpcHRpb246IFwiVGhlIDh0aCBob3VzZSByZXByZXNlbnRzIHRyYW5zZm9ybWF0aW9uLCBzaGFyZWQgcmVzb3VyY2VzLCBhbmQgdGhlIG9jY3VsdC5cIixcbiAgICAgICAgfSxcbiAgICAgICAgOToge1xuICAgICAgICAgIGRlc2NyaXB0aW9uOiBcIlRoZSA5dGggaG91c2UgcmVwcmVzZW50cyBoaWdoZXIgZWR1Y2F0aW9uLCBwaGlsb3NvcGh5LCBhbmQgbG9uZy1kaXN0YW5jZSB0cmF2ZWwuXCIsXG4gICAgICAgIH0sXG4gICAgICAgIDEwOiB7XG4gICAgICAgICAgZGVzY3JpcHRpb246IFwiVGhlIDEwdGggaG91c2UgcmVwcmVzZW50cyBjYXJlZXIsIHB1YmxpYyBpbWFnZSwgYW5kIGF1dGhvcml0eS5cIixcbiAgICAgICAgfSxcbiAgICAgICAgMTE6IHtcbiAgICAgICAgICBkZXNjcmlwdGlvbjogXCJUaGUgMTF0aCBob3VzZSByZXByZXNlbnRzIGZyaWVuZHNoaXBzLCBncm91cHMsIGFuZCBhc3BpcmF0aW9ucy5cIixcbiAgICAgICAgfSxcbiAgICAgICAgMTI6IHtcbiAgICAgICAgICBkZXNjcmlwdGlvbjogXCJUaGUgMTJ0aCBob3VzZSByZXByZXNlbnRzIHRoZSB1bmNvbnNjaW91cywgc3Bpcml0dWFsaXR5LCBhbmQgaGlkZGVuIGVuZW1pZXMuXCIsXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgZ2V0dGluZyBjaGFydCBpbnRlcnByZXRhdGlvbjpcIiwgZXJyb3IpXG4gICAgdGhyb3cgZXJyb3JcbiAgfVxufVxuXG4vKipcbiAqIEdldHMgYSBkYWlseSBob3Jvc2NvcGUgZm9yIGEgem9kaWFjIHNpZ25cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldERhaWx5SG9yb3Njb3BlKHNpZ246IFpvZGlhY1NpZ24pOiBQcm9taXNlPGFueT4ge1xuICB0cnkge1xuICAgIC8vIENoZWNrIGNyZWRlbnRpYWxzIGZpcnN0XG4gICAgaWYgKCFoYXNWYWxpZENyZWRlbnRpYWxzKCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkFQSSBjcmVkZW50aWFscyBub3QgY29uZmlndXJlZFwiKVxuICAgIH1cblxuICAgIC8vIE1ha2UgdGhlIEFQSSByZXF1ZXN0XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtBU1RST0xPR1lfQVBJX0JBU0VfVVJMfS9ob3Jvc2NvcGVfcHJlZGljdGlvbi9kYWlseS8ke3NpZ259YCwge1xuICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgIGhlYWRlcnM6IGdldEF1dGhIZWFkZXJzKCksXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7fSksXG4gICAgfSlcblxuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKClcblxuICAgIC8vIENoZWNrIGZvciBlcnJvciBpbiByZXNwb25zZVxuICAgIGlmIChkYXRhLnN0YXR1cyA9PT0gZmFsc2UgJiYgZGF0YS5tc2cpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihkYXRhLm1zZylcbiAgICB9XG5cbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEhvcm9zY29wZSBlcnJvcjogJHtyZXNwb25zZS5zdGF0dXN9ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gKVxuICAgIH1cblxuICAgIC8vIEZvcm1hdCB0aGUgcmVzcG9uc2UgdG8gbWF0Y2ggb3VyIGFwcGxpY2F0aW9uJ3Mgc3RydWN0dXJlXG4gICAgcmV0dXJuIHtcbiAgICAgIHNpZ246IHNpZ24sXG4gICAgICBkYXRlOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCkuc3BsaXQoXCJUXCIpWzBdLFxuICAgICAgcHJlZGljdGlvbjogZGF0YS5wcmVkaWN0aW9uIHx8IFwiWW91ciBob3Jvc2NvcGUgZm9yIHRvZGF5IGlzIG5vdCBhdmFpbGFibGUuXCIsXG4gICAgICBsdWNreV9udW1iZXI6IGRhdGEubHVja3lfbnVtYmVyIHx8IFwiN1wiLFxuICAgICAgbHVja3lfY29sb3I6IGRhdGEubHVja3lfY29sb3IgfHwgXCJCbHVlXCIsXG4gICAgICBtb29kOiBkYXRhLm1vb2QgfHwgXCJSZWZsZWN0aXZlXCIsXG4gICAgICBjb21wYXRpYmlsaXR5OiBkYXRhLmNvbXBhdGliaWxpdHkgfHwgXCJMaWJyYVwiLFxuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgZ2V0dGluZyBkYWlseSBob3Jvc2NvcGU6XCIsIGVycm9yKVxuICAgIHRocm93IGVycm9yXG4gIH1cbn1cblxuIl0sIm5hbWVzIjpbImdldEZhbGxiYWNrTmF0YWxDaGFydCIsInNhZmVHZXRTZXNzaW9uSXRlbSIsInNhZmVTZXRTZXNzaW9uSXRlbSIsInNhZmVSZW1vdmVTZXNzaW9uSXRlbSIsIlVTRVJfSUQiLCJwcm9jZXNzIiwiZW52IiwiQVBJX0tFWSIsIkFTVFJPTE9HWV9BUElfQkFTRV9VUkwiLCJoYXNWYWxpZENyZWRlbnRpYWxzIiwiaGFzQ3JlZGVudGlhbHMiLCJsZW5ndGgiLCJjb25zb2xlIiwibG9nIiwic2V0QXV0aEVycm9yIiwiaGFzRXJyb3IiLCJoYXNBdXRoRXJyb3IiLCJjbGVhckF1dGhFcnJvcnMiLCJnZXRBdXRoSGVhZGVycyIsImF1dGhTdHJpbmciLCJiYXNlNjRBdXRoIiwid2luZG93IiwiYnRvYSIsIkJ1ZmZlciIsImZyb20iLCJ0b1N0cmluZyIsImVycm9yIiwiRXJyb3IiLCJzdWJzdHJpbmciLCJBdXRob3JpemF0aW9uIiwiZmV0Y2hOYXRhbENoYXJ0IiwiYmlydGhEYXRlIiwiYmlydGhUaW1lIiwibGF0aXR1ZGUiLCJsb25naXR1ZGUiLCJ0aW1lem9uZSIsIndhcm4iLCJ5ZWFyIiwibW9udGgiLCJkYXkiLCJzcGxpdCIsIm1hcCIsIk51bWJlciIsImhvdXIiLCJtaW51dGUiLCJyZXF1ZXN0Qm9keSIsIm1pbiIsImxhdCIsImxvbiIsInR6b25lIiwicGxhbmV0c1Jlc3BvbnNlIiwiZmV0Y2giLCJtZXRob2QiLCJoZWFkZXJzIiwiYm9keSIsIkpTT04iLCJzdHJpbmdpZnkiLCJwbGFuZXRzRGF0YSIsImpzb24iLCJzdGF0dXMiLCJtc2ciLCJpbmNsdWRlcyIsIm9rIiwic3RhdHVzVGV4dCIsImhvdXNlc1Jlc3BvbnNlIiwiaG91c2VzRGF0YSIsImFzcGVjdHNSZXNwb25zZSIsImFzcGVjdHNEYXRhIiwiZm9ybWF0TmF0YWxDaGFydFJlc3BvbnNlIiwiZGF0ZSIsInRpbWUiLCJsb2NhdGlvbiIsIm5hbWUiLCJmZXRjaE5hdGFsV2hlZWxDaGFydCIsInNpZ25faWNvbl9jb2xvciIsInNpZ25fYmFja2dyb3VuZCIsImNoYXJ0VXJsIiwic3ZnQ29udGVudCIsInBsYW5ldF9pY29uX2NvbG9yIiwiaW5uZXJfY2lyY2xlX2JhY2tncm91bmQiLCJvdXRlcl9jaXJjbGVfYmFja2dyb3VuZCIsImNoYXJ0X3NpemUiLCJpbWFnZV90eXBlIiwicmVzcG9uc2UiLCJyYXdSZXNwb25zZVRleHQiLCJ0ZXh0IiwiZGF0YSIsInBhcnNlIiwiT2JqZWN0Iiwia2V5cyIsImUiLCJjaGFydF91cmwiLCJzdmciLCJmZXRjaE5hdGFsV2hlZWxDaGFydFNWRyIsInJlc3VsdCIsInN2Z1Jlc3BvbnNlIiwiZ2VvY29kZUxvY2F0aW9uIiwidXJsIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwiYmlydGhEZXRhaWxzIiwicGxhbmV0cyIsInBsYW5ldCIsInBsYW5ldE5hbWUiLCJjb252ZXJ0UGxhbmV0TmFtZSIsInNpZ24iLCJ0b0xvd2VyQ2FzZSIsImRlZ3JlZSIsIm5vcm1fZGVncmVlIiwiaG91c2UiLCJyZXRyb2dyYWRlIiwiaXNfcmV0cm9ncmFkZSIsImFzcGVjdHNUb090aGVyUGxhbmV0cyIsImhvdXNlcyIsImtleSIsIm51bWJlciIsInBhcnNlSW50IiwicmVwbGFjZSIsImN1c3AiLCJhbmdsZXMiLCJhc2NlbmRhbnQiLCJtaWRoZWF2ZW4iLCJkZXNjZW5kYW50IiwiZ2V0T3Bwb3NpdGVTaWduIiwiaW11bUNvZWxpIiwiYXNwZWN0cyIsImFzcGVjdCIsInBsYW5ldDEiLCJwbGFuZXQyIiwib3JiIiwiYXBwbHlpbmciLCJhcGlQbGFuZXROYW1lIiwicGxhbmV0TWFwIiwiU3VuIiwiTW9vbiIsIk1lcmN1cnkiLCJWZW51cyIsIk1hcnMiLCJKdXBpdGVyIiwiU2F0dXJuIiwiVXJhbnVzIiwiTmVwdHVuZSIsIlBsdXRvIiwiUmFodSIsIktldHUiLCJ6b2RpYWNTaWducyIsImluZGV4IiwiaW5kZXhPZiIsIm9wcG9zaXRlSW5kZXgiLCJnZXROYXRhbENoYXJ0SW50ZXJwcmV0YXRpb24iLCJuYXRhbENoYXJ0Iiwib3ZlcnZpZXciLCJ0aXRsZSIsImRlc2NyaXB0aW9uIiwic3VuU2lnbiIsImtleXdvcmRzIiwibW9vblNpZ24iLCJhc2NlbmRhbnRTaWduIiwicGxhbmV0UG9zaXRpb25zIiwic3VuIiwibW9vbiIsIm1lcmN1cnkiLCJ2ZW51cyIsIm1hcnMiLCJqdXBpdGVyIiwic2F0dXJuIiwidXJhbnVzIiwibmVwdHVuZSIsInBsdXRvIiwiZ2V0RGFpbHlIb3Jvc2NvcGUiLCJEYXRlIiwidG9JU09TdHJpbmciLCJwcmVkaWN0aW9uIiwibHVja3lfbnVtYmVyIiwibHVja3lfY29sb3IiLCJtb29kIiwiY29tcGF0aWJpbGl0eSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./services/astrology-api-service.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./services/astrology-service.ts":
/*!***************************************!*\
  !*** ./services/astrology-service.ts ***!
  \***************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fetchNatalChart: () => (/* binding */ fetchNatalChart),\n/* harmony export */   fetchNatalWheelChartSVG: () => (/* binding */ fetchNatalWheelChartSVG),\n/* harmony export */   geocodeLocation: () => (/* binding */ geocodeLocation),\n/* harmony export */   getDailyHoroscope: () => (/* binding */ getDailyHoroscope),\n/* harmony export */   getNatalChartInterpretation: () => (/* binding */ getNatalChartInterpretation)\n/* harmony export */ });\n/* harmony import */ var _astrology_api_service__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./astrology-api-service */ \"(app-pages-browser)/./services/astrology-api-service.ts\");\n/**\n * Astrology Service\n * Handles all interactions with astrology APIs and data processing\n */ \n/**\n * Fetches natal chart data\n */ async function fetchNatalChart(birthDate, birthTime, latitude, longitude) {\n    try {\n        // Calculate timezone from longitude (approximate)\n        // In a real app, you would use a timezone API or library\n        const timezone = Math.round(longitude / 15);\n        // Use the AstrologyAPI service\n        return await (0,_astrology_api_service__WEBPACK_IMPORTED_MODULE_0__.fetchNatalChart)(birthDate, birthTime, latitude, longitude, timezone);\n    } catch (error) {\n        console.error(\"Error fetching natal chart:\", error);\n        throw error;\n    }\n}\n/**\n * Fetches natal wheel chart SVG\n */ async function fetchNatalWheelChartSVG(birthDate, birthTime, latitude, longitude) {\n    try {\n        // Calculate timezone from longitude (approximate)\n        const timezone = Math.round(longitude / 15);\n        // Use the AstrologyAPI service\n        return await (0,_astrology_api_service__WEBPACK_IMPORTED_MODULE_0__.fetchNatalWheelChartSVG)(birthDate, birthTime, latitude, longitude, timezone);\n    } catch (error) {\n        console.error(\"Error fetching natal wheel chart SVG:\", error);\n        throw error;\n    }\n}\n/**\n * Geocodes a location string to get latitude and longitude\n */ async function geocodeLocation(locationString) {\n    try {\n        // Try to use a simple geocoding approach first\n        const simpleGeocode = getSimpleGeocoding(locationString);\n        if (simpleGeocode) {\n            console.log(\"Using simple geocoding for:\", locationString);\n            return simpleGeocode;\n        }\n        // Try the direct API call first\n        try {\n            const result = await (0,_astrology_api_service__WEBPACK_IMPORTED_MODULE_0__.geocodeLocation)(locationString);\n            if (result.latitude !== 0 || result.longitude !== 0) {\n                return result;\n            }\n        } catch (error) {\n            console.warn(\"Direct API geocoding failed, trying /api/geocode\", error);\n        }\n        // Fallback: use the custom /api/geocode endpoint with POST\n        try {\n            const response = await fetch(\"/api/geocode\", {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                },\n                body: JSON.stringify({\n                    location: locationString\n                })\n            });\n            if (response.ok) {\n                const data = await response.json();\n                return {\n                    latitude: data.latitude,\n                    longitude: data.longitude,\n                    name: data.name || locationString\n                };\n            }\n        } catch (error) {\n            console.error(\"Error using /api/geocode fallback:\", error);\n        }\n        // Final fallback\n        return {\n            latitude: 0,\n            longitude: 0,\n            name: locationString\n        };\n    } catch (error) {\n        console.error(\"Error in geocoding service:\", error);\n        return {\n            latitude: 0,\n            longitude: 0,\n            name: locationString\n        };\n    }\n}\n/**\n * Simple geocoding function for common locations\n * This serves as a fallback when the API fails\n */ function getSimpleGeocoding(locationString) {\n    let forceFallback = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;\n    // Normalize the input\n    const normalizedInput = locationString.toLowerCase().trim();\n    // Common city coordinates\n    const cityCoordinates = {\n        // North America\n        \"new york\": [\n            40.7128,\n            -74.006\n        ],\n        \"los angeles\": [\n            34.0522,\n            -118.2437\n        ],\n        chicago: [\n            41.8781,\n            -87.6298\n        ],\n        toronto: [\n            43.6532,\n            -79.3832\n        ],\n        \"mexico city\": [\n            19.4326,\n            -99.1332\n        ],\n        // Europe\n        london: [\n            51.5074,\n            -0.1278\n        ],\n        paris: [\n            48.8566,\n            2.3522\n        ],\n        berlin: [\n            52.52,\n            13.405\n        ],\n        madrid: [\n            40.4168,\n            -3.7038\n        ],\n        rome: [\n            41.9028,\n            12.4964\n        ],\n        amsterdam: [\n            52.3676,\n            4.9041\n        ],\n        vienna: [\n            48.2082,\n            16.3738\n        ],\n        hamburg: [\n            53.5511,\n            9.9937\n        ],\n        // Asia\n        tokyo: [\n            35.6762,\n            139.6503\n        ],\n        beijing: [\n            39.9042,\n            116.4074\n        ],\n        mumbai: [\n            19.076,\n            72.8777\n        ],\n        singapore: [\n            1.3521,\n            103.8198\n        ],\n        // Australia\n        sydney: [\n            -33.8688,\n            151.2093\n        ],\n        melbourne: [\n            -37.8136,\n            144.9631\n        ],\n        // South America\n        \"rio de janeiro\": [\n            -22.9068,\n            -43.1729\n        ],\n        \"buenos aires\": [\n            -34.6037,\n            -58.3816\n        ],\n        // Africa\n        cairo: [\n            30.0444,\n            31.2357\n        ],\n        \"cape town\": [\n            -33.9249,\n            18.4241\n        ]\n    };\n    // Check for exact matches\n    for (const [city, coordinates] of Object.entries(cityCoordinates)){\n        if (normalizedInput.includes(city)) {\n            return {\n                latitude: coordinates[0],\n                longitude: coordinates[1],\n                name: locationString\n            };\n        }\n    }\n    // If we're forcing a fallback or the input is very short, use a default\n    if (forceFallback || normalizedInput.length < 3) {\n        // Default to a central location (0,0 is in the Atlantic Ocean)\n        return {\n            latitude: 0,\n            longitude: 0,\n            name: locationString\n        };\n    }\n    // No match found\n    return null;\n}\n/**\n * Gets interpretations for a natal chart\n */ async function getNatalChartInterpretation(natalChart) {\n    try {\n        // Use the AstrologyAPI interpretation service\n        return await (0,_astrology_api_service__WEBPACK_IMPORTED_MODULE_0__.getNatalChartInterpretation)(natalChart);\n    } catch (error) {\n        console.error(\"Error getting chart interpretation:\", error);\n        throw error;\n    }\n}\n/**\n * Gets a daily horoscope for a zodiac sign\n */ async function getDailyHoroscope(sign) {\n    try {\n        // Use the AstrologyAPI horoscope service\n        return await (0,_astrology_api_service__WEBPACK_IMPORTED_MODULE_0__.getDailyHoroscope)(sign);\n    } catch (error) {\n        console.error(\"Error getting daily horoscope:\", error);\n        throw error;\n    }\n}\n// Define zodiacSymbols\nconst zodiacSymbols = {\n    aries: \"\",\n    taurus: \"\",\n    gemini: \"\",\n    cancer: \"\",\n    leo: \"\",\n    virgo: \"\",\n    libra: \"\",\n    scorpio: \"\",\n    sagittarius: \"\",\n    capricorn: \"\",\n    aquarius: \"\",\n    pisces: \"\"\n};\n// Add a function to create a placeholder chart when the API fails\nfunction createPlaceholderChart(birthDate, birthTime, latitude, longitude) {\n    // Create a basic placeholder chart with minimal data\n    const [year, month, day] = birthDate.split(\"-\").map(Number);\n    const [hour, minute] = birthTime.split(\":\").map(Number);\n    // Generate some placeholder planets\n    const planets = [\n        {\n            name: \"sun\",\n            sign: \"aries\",\n            degree: 15,\n            house: 1,\n            retrograde: false\n        },\n        {\n            name: \"moon\",\n            sign: \"taurus\",\n            degree: 25,\n            house: 2,\n            retrograde: false\n        },\n        {\n            name: \"mercury\",\n            sign: \"gemini\",\n            degree: 5,\n            house: 3,\n            retrograde: false\n        },\n        {\n            name: \"venus\",\n            sign: \"cancer\",\n            degree: 10,\n            house: 4,\n            retrograde: false\n        },\n        {\n            name: \"mars\",\n            sign: \"leo\",\n            degree: 20,\n            house: 5,\n            retrograde: false\n        },\n        {\n            name: \"jupiter\",\n            sign: \"virgo\",\n            degree: 15,\n            house: 6,\n            retrograde: false\n        },\n        {\n            name: \"saturn\",\n            sign: \"libra\",\n            degree: 5,\n            house: 7,\n            retrograde: true\n        }\n    ];\n    // Generate placeholder houses\n    const houses = Array.from({\n        length: 12\n    }, (_, i)=>({\n            number: i + 1,\n            sign: Object.keys(zodiacSymbols)[i % 12],\n            degree: i * 30 % 360,\n            cusp: true\n        }));\n    // Generate placeholder angles\n    const angles = {\n        ascendant: {\n            sign: \"aries\",\n            degree: 0\n        },\n        midheaven: {\n            sign: \"capricorn\",\n            degree: 270\n        },\n        descendant: {\n            sign: \"libra\",\n            degree: 180\n        },\n        imumCoeli: {\n            sign: \"cancer\",\n            degree: 90\n        }\n    };\n    return {\n        planets,\n        houses,\n        angles,\n        aspects: [],\n        birthDetails: {\n            date: birthDate,\n            time: birthTime,\n            location: {\n                latitude,\n                longitude,\n                name: \"Location data unavailable\"\n            }\n        }\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NlcnZpY2VzL2FzdHJvbG9neS1zZXJ2aWNlLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBOzs7Q0FHQyxHQVMrQjtBQUVoQzs7Q0FFQyxHQUNNLGVBQWVBLGdCQUNwQlUsU0FBaUIsRUFDakJDLFNBQWlCLEVBQ2pCQyxRQUFnQixFQUNoQkMsU0FBaUI7SUFFakIsSUFBSTtRQUNGLGtEQUFrRDtRQUNsRCx5REFBeUQ7UUFDekQsTUFBTUMsV0FBV0MsS0FBS0MsS0FBSyxDQUFDSCxZQUFZO1FBRXhDLCtCQUErQjtRQUMvQixPQUFPLE1BQU1aLHVFQUFzQkEsQ0FBQ1MsV0FBV0MsV0FBV0MsVUFBVUMsV0FBV0M7SUFDakYsRUFBRSxPQUFPRyxPQUFPO1FBQ2RDLFFBQVFELEtBQUssQ0FBQywrQkFBK0JBO1FBQzdDLE1BQU1BO0lBQ1I7QUFDRjtBQUVBOztDQUVDLEdBQ00sZUFBZVQsd0JBQ3BCRSxTQUFpQixFQUNqQkMsU0FBaUIsRUFDakJDLFFBQWdCLEVBQ2hCQyxTQUFpQjtJQUVqQixJQUFJO1FBQ0Ysa0RBQWtEO1FBQ2xELE1BQU1DLFdBQVdDLEtBQUtDLEtBQUssQ0FBQ0gsWUFBWTtRQUV4QywrQkFBK0I7UUFDL0IsT0FBTyxNQUFNSiwrRUFBOEJBLENBQUNDLFdBQVdDLFdBQVdDLFVBQVVDLFdBQVdDO0lBQ3pGLEVBQUUsT0FBT0csT0FBTztRQUNkQyxRQUFRRCxLQUFLLENBQUMseUNBQXlDQTtRQUN2RCxNQUFNQTtJQUNSO0FBQ0Y7QUFFQTs7Q0FFQyxHQUNNLGVBQWVmLGdCQUNwQmlCLGNBQXNCO0lBRXRCLElBQUk7UUFDRiwrQ0FBK0M7UUFDL0MsTUFBTUMsZ0JBQWdCQyxtQkFBbUJGO1FBQ3pDLElBQUlDLGVBQWU7WUFDakJGLFFBQVFJLEdBQUcsQ0FBQywrQkFBK0JIO1lBQzNDLE9BQU9DO1FBQ1Q7UUFFQSxnQ0FBZ0M7UUFDaEMsSUFBSTtZQUNGLE1BQU1HLFNBQVMsTUFBTXBCLHVFQUFzQkEsQ0FBQ2dC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TUFBTTtZQUFVd0IsUUFBUTtRQUFHO0lBQzFDO0lBRUEsT0FBTztRQUNMRDtRQUNBSTtRQUNBUTtRQUNBSyxTQUFTLEVBQUU7UUFDWEMsY0FBYztZQUNaQyxNQUFNbEc7WUFDTm1HLE1BQU1sRztZQUNOcUIsVUFBVTtnQkFDUnBCO2dCQUNBQztnQkFDQXVCLE1BQU07WUFDUjtRQUNGO0lBQ0Y7QUFDRiIsInNvdXJjZXMiOlsiL1VzZXJzL21hcmtvbm92YWtvdnNraS9Eb2N1bWVudHMvVmlzdWFsIENvZGUvQXN0cm9Cb29rL0FzdHJvQm9vay9zZXJ2aWNlcy9hc3Ryb2xvZ3ktc2VydmljZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEFzdHJvbG9neSBTZXJ2aWNlXG4gKiBIYW5kbGVzIGFsbCBpbnRlcmFjdGlvbnMgd2l0aCBhc3Ryb2xvZ3kgQVBJcyBhbmQgZGF0YSBwcm9jZXNzaW5nXG4gKi9cblxuaW1wb3J0IHR5cGUgeyBOYXRhbENoYXJ0LCBDaGFydEludGVycHJldGF0aW9uLCBab2RpYWNTaWduIH0gZnJvbSBcIkAvdHlwZXMvYXN0cm9sb2d5XCJcbmltcG9ydCB7XG4gIGZldGNoTmF0YWxDaGFydCBhcyBmZXRjaE5hdGFsQ2hhcnRGcm9tQVBJLFxuICBnZW9jb2RlTG9jYXRpb24gYXMgZ2VvY29kZUxvY2F0aW9uRnJvbUFQSSxcbiAgZ2V0TmF0YWxDaGFydEludGVycHJldGF0aW9uIGFzIGdldEludGVycHJldGF0aW9uRnJvbUFQSSxcbiAgZ2V0RGFpbHlIb3Jvc2NvcGUgYXMgZ2V0RGFpbHlIb3Jvc2NvcGVGcm9tQVBJLFxuICBmZXRjaE5hdGFsV2hlZWxDaGFydFNWRyBhcyBmZXRjaE5hdGFsV2hlZWxDaGFydFNWR0Zyb21BUEksXG59IGZyb20gXCIuL2FzdHJvbG9neS1hcGktc2VydmljZVwiXG5cbi8qKlxuICogRmV0Y2hlcyBuYXRhbCBjaGFydCBkYXRhXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBmZXRjaE5hdGFsQ2hhcnQoXG4gIGJpcnRoRGF0ZTogc3RyaW5nLFxuICBiaXJ0aFRpbWU6IHN0cmluZyxcbiAgbGF0aXR1ZGU6IG51bWJlcixcbiAgbG9uZ2l0dWRlOiBudW1iZXIsXG4pOiBQcm9taXNlPE5hdGFsQ2hhcnQ+IHtcbiAgdHJ5IHtcbiAgICAvLyBDYWxjdWxhdGUgdGltZXpvbmUgZnJvbSBsb25naXR1ZGUgKGFwcHJveGltYXRlKVxuICAgIC8vIEluIGEgcmVhbCBhcHAsIHlvdSB3b3VsZCB1c2UgYSB0aW1lem9uZSBBUEkgb3IgbGlicmFyeVxuICAgIGNvbnN0IHRpbWV6b25lID0gTWF0aC5yb3VuZChsb25naXR1ZGUgLyAxNSlcblxuICAgIC8vIFVzZSB0aGUgQXN0cm9sb2d5QVBJIHNlcnZpY2VcbiAgICByZXR1cm4gYXdhaXQgZmV0Y2hOYXRhbENoYXJ0RnJvbUFQSShiaXJ0aERhdGUsIGJpcnRoVGltZSwgbGF0aXR1ZGUsIGxvbmdpdHVkZSwgdGltZXpvbmUpXG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihcIkVycm9yIGZldGNoaW5nIG5hdGFsIGNoYXJ0OlwiLCBlcnJvcilcbiAgICB0aHJvdyBlcnJvclxuICB9XG59XG5cbi8qKlxuICogRmV0Y2hlcyBuYXRhbCB3aGVlbCBjaGFydCBTVkdcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGZldGNoTmF0YWxXaGVlbENoYXJ0U1ZHKFxuICBiaXJ0aERhdGU6IHN0cmluZyxcbiAgYmlydGhUaW1lOiBzdHJpbmcsXG4gIGxhdGl0dWRlOiBudW1iZXIsXG4gIGxvbmdpdHVkZTogbnVtYmVyLFxuKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgdHJ5IHtcbiAgICAvLyBDYWxjdWxhdGUgdGltZXpvbmUgZnJvbSBsb25naXR1ZGUgKGFwcHJveGltYXRlKVxuICAgIGNvbnN0IHRpbWV6b25lID0gTWF0aC5yb3VuZChsb25naXR1ZGUgLyAxNSlcblxuICAgIC8vIFVzZSB0aGUgQXN0cm9sb2d5QVBJIHNlcnZpY2VcbiAgICByZXR1cm4gYXdhaXQgZmV0Y2hOYXRhbFdoZWVsQ2hhcnRTVkdGcm9tQVBJKGJpcnRoRGF0ZSwgYmlydGhUaW1lLCBsYXRpdHVkZSwgbG9uZ2l0dWRlLCB0aW1lem9uZSlcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgZmV0Y2hpbmcgbmF0YWwgd2hlZWwgY2hhcnQgU1ZHOlwiLCBlcnJvcilcbiAgICB0aHJvdyBlcnJvclxuICB9XG59XG5cbi8qKlxuICogR2VvY29kZXMgYSBsb2NhdGlvbiBzdHJpbmcgdG8gZ2V0IGxhdGl0dWRlIGFuZCBsb25naXR1ZGVcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdlb2NvZGVMb2NhdGlvbihcbiAgbG9jYXRpb25TdHJpbmc6IHN0cmluZyxcbik6IFByb21pc2U8eyBsYXRpdHVkZTogbnVtYmVyOyBsb25naXR1ZGU6IG51bWJlcjsgbmFtZTogc3RyaW5nIH0+IHtcbiAgdHJ5IHtcbiAgICAvLyBUcnkgdG8gdXNlIGEgc2ltcGxlIGdlb2NvZGluZyBhcHByb2FjaCBmaXJzdFxuICAgIGNvbnN0IHNpbXBsZUdlb2NvZGUgPSBnZXRTaW1wbGVHZW9jb2RpbmcobG9jYXRpb25TdHJpbmcpXG4gICAgaWYgKHNpbXBsZUdlb2NvZGUpIHtcbiAgICAgIGNvbnNvbGUubG9nKFwiVXNpbmcgc2ltcGxlIGdlb2NvZGluZyBmb3I6XCIsIGxvY2F0aW9uU3RyaW5nKVxuICAgICAgcmV0dXJuIHNpbXBsZUdlb2NvZGVcbiAgICB9XG5cbiAgICAvLyBUcnkgdGhlIGRpcmVjdCBBUEkgY2FsbCBmaXJzdFxuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBnZW9jb2RlTG9jYXRpb25Gcm9tQVBJKGxvY2F0aW9uU3RyaW5nKVxuICAgICAgaWYgKHJlc3VsdC5sYXRpdHVkZSAhPT0gMCB8fCByZXN1bHQubG9uZ2l0dWRlICE9PSAwKSB7XG4gICAgICAgIHJldHVybiByZXN1bHRcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS53YXJuKFwiRGlyZWN0IEFQSSBnZW9jb2RpbmcgZmFpbGVkLCB0cnlpbmcgL2FwaS9nZW9jb2RlXCIsIGVycm9yKVxuICAgIH1cblxuICAgIC8vIEZhbGxiYWNrOiB1c2UgdGhlIGN1c3RvbSAvYXBpL2dlb2NvZGUgZW5kcG9pbnQgd2l0aCBQT1NUXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goXCIvYXBpL2dlb2NvZGVcIiwge1xuICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICBoZWFkZXJzOiB7IFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiIH0sXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgbG9jYXRpb246IGxvY2F0aW9uU3RyaW5nIH0pXG4gICAgICB9KVxuICAgICAgaWYgKHJlc3BvbnNlLm9rKSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKClcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBsYXRpdHVkZTogZGF0YS5sYXRpdHVkZSxcbiAgICAgICAgICBsb25naXR1ZGU6IGRhdGEubG9uZ2l0dWRlLFxuICAgICAgICAgIG5hbWU6IGRhdGEubmFtZSB8fCBsb2NhdGlvblN0cmluZyxcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgdXNpbmcgL2FwaS9nZW9jb2RlIGZhbGxiYWNrOlwiLCBlcnJvcilcbiAgICB9XG5cbiAgICAvLyBGaW5hbCBmYWxsYmFja1xuICAgIHJldHVybiB7XG4gICAgICBsYXRpdHVkZTogMCxcbiAgICAgIGxvbmdpdHVkZTogMCxcbiAgICAgIG5hbWU6IGxvY2F0aW9uU3RyaW5nLFxuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgaW4gZ2VvY29kaW5nIHNlcnZpY2U6XCIsIGVycm9yKVxuICAgIHJldHVybiB7XG4gICAgICBsYXRpdHVkZTogMCxcbiAgICAgIGxvbmdpdHVkZTogMCxcbiAgICAgIG5hbWU6IGxvY2F0aW9uU3RyaW5nLFxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFNpbXBsZSBnZW9jb2RpbmcgZnVuY3Rpb24gZm9yIGNvbW1vbiBsb2NhdGlvbnNcbiAqIFRoaXMgc2VydmVzIGFzIGEgZmFsbGJhY2sgd2hlbiB0aGUgQVBJIGZhaWxzXG4gKi9cbmZ1bmN0aW9uIGdldFNpbXBsZUdlb2NvZGluZyhcbiAgbG9jYXRpb25TdHJpbmc6IHN0cmluZyxcbiAgZm9yY2VGYWxsYmFjayA9IGZhbHNlLFxuKTogeyBsYXRpdHVkZTogbnVtYmVyOyBsb25naXR1ZGU6IG51bWJlcjsgbmFtZTogc3RyaW5nIH0gfCBudWxsIHtcbiAgLy8gTm9ybWFsaXplIHRoZSBpbnB1dFxuICBjb25zdCBub3JtYWxpemVkSW5wdXQgPSBsb2NhdGlvblN0cmluZy50b0xvd2VyQ2FzZSgpLnRyaW0oKVxuXG4gIC8vIENvbW1vbiBjaXR5IGNvb3JkaW5hdGVzXG4gIGNvbnN0IGNpdHlDb29yZGluYXRlczogUmVjb3JkPHN0cmluZywgW251bWJlciwgbnVtYmVyXT4gPSB7XG4gICAgLy8gTm9ydGggQW1lcmljYVxuICAgIFwibmV3IHlvcmtcIjogWzQwLjcxMjgsIC03NC4wMDZdLFxuICAgIFwibG9zIGFuZ2VsZXNcIjogWzM0LjA1MjIsIC0xMTguMjQzN10sXG4gICAgY2hpY2FnbzogWzQxLjg3ODEsIC04Ny42Mjk4XSxcbiAgICB0b3JvbnRvOiBbNDMuNjUzMiwgLTc5LjM4MzJdLFxuICAgIFwibWV4aWNvIGNpdHlcIjogWzE5LjQzMjYsIC05OS4xMzMyXSxcblxuICAgIC8vIEV1cm9wZVxuICAgIGxvbmRvbjogWzUxLjUwNzQsIC0wLjEyNzhdLFxuICAgIHBhcmlzOiBbNDguODU2NiwgMi4zNTIyXSxcbiAgICBiZXJsaW46IFs1Mi41MiwgMTMuNDA1XSxcbiAgICBtYWRyaWQ6IFs0MC40MTY4LCAtMy43MDM4XSxcbiAgICByb21lOiBbNDEuOTAyOCwgMTIuNDk2NF0sXG4gICAgYW1zdGVyZGFtOiBbNTIuMzY3NiwgNC45MDQxXSxcbiAgICB2aWVubmE6IFs0OC4yMDgyLCAxNi4zNzM4XSxcbiAgICBoYW1idXJnOiBbNTMuNTUxMSwgOS45OTM3XSxcblxuICAgIC8vIEFzaWFcbiAgICB0b2t5bzogWzM1LjY3NjIsIDEzOS42NTAzXSxcbiAgICBiZWlqaW5nOiBbMzkuOTA0MiwgMTE2LjQwNzRdLFxuICAgIG11bWJhaTogWzE5LjA3NiwgNzIuODc3N10sXG4gICAgc2luZ2Fwb3JlOiBbMS4zNTIxLCAxMDMuODE5OF0sXG5cbiAgICAvLyBBdXN0cmFsaWFcbiAgICBzeWRuZXk6IFstMzMuODY4OCwgMTUxLjIwOTNdLFxuICAgIG1lbGJvdXJuZTogWy0zNy44MTM2LCAxNDQuOTYzMV0sXG5cbiAgICAvLyBTb3V0aCBBbWVyaWNhXG4gICAgXCJyaW8gZGUgamFuZWlyb1wiOiBbLTIyLjkwNjgsIC00My4xNzI5XSxcbiAgICBcImJ1ZW5vcyBhaXJlc1wiOiBbLTM0LjYwMzcsIC01OC4zODE2XSxcblxuICAgIC8vIEFmcmljYVxuICAgIGNhaXJvOiBbMzAuMDQ0NCwgMzEuMjM1N10sXG4gICAgXCJjYXBlIHRvd25cIjogWy0zMy45MjQ5LCAxOC40MjQxXSxcbiAgfVxuXG4gIC8vIENoZWNrIGZvciBleGFjdCBtYXRjaGVzXG4gIGZvciAoY29uc3QgW2NpdHksIGNvb3JkaW5hdGVzXSBvZiBPYmplY3QuZW50cmllcyhjaXR5Q29vcmRpbmF0ZXMpKSB7XG4gICAgaWYgKG5vcm1hbGl6ZWRJbnB1dC5pbmNsdWRlcyhjaXR5KSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbGF0aXR1ZGU6IGNvb3JkaW5hdGVzWzBdLFxuICAgICAgICBsb25naXR1ZGU6IGNvb3JkaW5hdGVzWzFdLFxuICAgICAgICBuYW1lOiBsb2NhdGlvblN0cmluZyxcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBJZiB3ZSdyZSBmb3JjaW5nIGEgZmFsbGJhY2sgb3IgdGhlIGlucHV0IGlzIHZlcnkgc2hvcnQsIHVzZSBhIGRlZmF1bHRcbiAgaWYgKGZvcmNlRmFsbGJhY2sgfHwgbm9ybWFsaXplZElucHV0Lmxlbmd0aCA8IDMpIHtcbiAgICAvLyBEZWZhdWx0IHRvIGEgY2VudHJhbCBsb2NhdGlvbiAoMCwwIGlzIGluIHRoZSBBdGxhbnRpYyBPY2VhbilcbiAgICByZXR1cm4ge1xuICAgICAgbGF0aXR1ZGU6IDAsXG4gICAgICBsb25naXR1ZGU6IDAsXG4gICAgICBuYW1lOiBsb2NhdGlvblN0cmluZyxcbiAgICB9XG4gIH1cblxuICAvLyBObyBtYXRjaCBmb3VuZFxuICByZXR1cm4gbnVsbFxufVxuXG4vKipcbiAqIEdldHMgaW50ZXJwcmV0YXRpb25zIGZvciBhIG5hdGFsIGNoYXJ0XG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXROYXRhbENoYXJ0SW50ZXJwcmV0YXRpb24obmF0YWxDaGFydDogTmF0YWxDaGFydCk6IFByb21pc2U8Q2hhcnRJbnRlcnByZXRhdGlvbj4ge1xuICB0cnkge1xuICAgIC8vIFVzZSB0aGUgQXN0cm9sb2d5QVBJIGludGVycHJldGF0aW9uIHNlcnZpY2VcbiAgICByZXR1cm4gYXdhaXQgZ2V0SW50ZXJwcmV0YXRpb25Gcm9tQVBJKG5hdGFsQ2hhcnQpXG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihcIkVycm9yIGdldHRpbmcgY2hhcnQgaW50ZXJwcmV0YXRpb246XCIsIGVycm9yKVxuICAgIHRocm93IGVycm9yXG4gIH1cbn1cblxuLyoqXG4gKiBHZXRzIGEgZGFpbHkgaG9yb3Njb3BlIGZvciBhIHpvZGlhYyBzaWduXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXREYWlseUhvcm9zY29wZShzaWduOiBab2RpYWNTaWduKTogUHJvbWlzZTxhbnk+IHtcbiAgdHJ5IHtcbiAgICAvLyBVc2UgdGhlIEFzdHJvbG9neUFQSSBob3Jvc2NvcGUgc2VydmljZVxuICAgIHJldHVybiBhd2FpdCBnZXREYWlseUhvcm9zY29wZUZyb21BUEkoc2lnbilcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgZ2V0dGluZyBkYWlseSBob3Jvc2NvcGU6XCIsIGVycm9yKVxuICAgIHRocm93IGVycm9yXG4gIH1cbn1cblxuLy8gRGVmaW5lIHpvZGlhY1N5bWJvbHNcbmNvbnN0IHpvZGlhY1N5bWJvbHM6IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH0gPSB7XG4gIGFyaWVzOiBcIuKZiFwiLFxuICB0YXVydXM6IFwi4pmJXCIsXG4gIGdlbWluaTogXCLimYpcIixcbiAgY2FuY2VyOiBcIuKZi1wiLFxuICBsZW86IFwi4pmMXCIsXG4gIHZpcmdvOiBcIuKZjVwiLFxuICBsaWJyYTogXCLimY5cIixcbiAgc2NvcnBpbzogXCLimY9cIixcbiAgc2FnaXR0YXJpdXM6IFwi4pmQXCIsXG4gIGNhcHJpY29ybjogXCLimZFcIixcbiAgYXF1YXJpdXM6IFwi4pmSXCIsXG4gIHBpc2NlczogXCLimZNcIixcbn1cblxuLy8gRGVmaW5lIHRoZSBQbGFuZXRQb3NpdGlvbiB0eXBlXG5pbnRlcmZhY2UgUGxhbmV0UG9zaXRpb24ge1xuICBuYW1lOiBzdHJpbmdcbiAgc2lnbjogc3RyaW5nXG4gIGRlZ3JlZTogbnVtYmVyXG4gIGhvdXNlOiBudW1iZXJcbiAgcmV0cm9ncmFkZTogYm9vbGVhblxufVxuXG4vLyBBZGQgYSBmdW5jdGlvbiB0byBjcmVhdGUgYSBwbGFjZWhvbGRlciBjaGFydCB3aGVuIHRoZSBBUEkgZmFpbHNcbmZ1bmN0aW9uIGNyZWF0ZVBsYWNlaG9sZGVyQ2hhcnQoYmlydGhEYXRlOiBzdHJpbmcsIGJpcnRoVGltZTogc3RyaW5nLCBsYXRpdHVkZTogbnVtYmVyLCBsb25naXR1ZGU6IG51bWJlcik6IE5hdGFsQ2hhcnQge1xuICAvLyBDcmVhdGUgYSBiYXNpYyBwbGFjZWhvbGRlciBjaGFydCB3aXRoIG1pbmltYWwgZGF0YVxuICBjb25zdCBbeWVhciwgbW9udGgsIGRheV0gPSBiaXJ0aERhdGUuc3BsaXQoXCItXCIpLm1hcChOdW1iZXIpXG4gIGNvbnN0IFtob3VyLCBtaW51dGVdID0gYmlydGhUaW1lLnNwbGl0KFwiOlwiKS5tYXAoTnVtYmVyKVxuXG4gIC8vIEdlbmVyYXRlIHNvbWUgcGxhY2Vob2xkZXIgcGxhbmV0c1xuICBjb25zdCBwbGFuZXRzOiBQbGFuZXRQb3NpdGlvbltdID0gW1xuICAgIHsgbmFtZTogXCJzdW5cIiwgc2lnbjogXCJhcmllc1wiLCBkZWdyZWU6IDE1LCBob3VzZTogMSwgcmV0cm9ncmFkZTogZmFsc2UgfSxcbiAgICB7IG5hbWU6IFwibW9vblwiLCBzaWduOiBcInRhdXJ1c1wiLCBkZWdyZWU6IDI1LCBob3VzZTogMiwgcmV0cm9ncmFkZTogZmFsc2UgfSxcbiAgICB7IG5hbWU6IFwibWVyY3VyeVwiLCBzaWduOiBcImdlbWluaVwiLCBkZWdyZWU6IDUsIGhvdXNlOiAzLCByZXRyb2dyYWRlOiBmYWxzZSB9LFxuICAgIHsgbmFtZTogXCJ2ZW51c1wiLCBzaWduOiBcImNhbmNlclwiLCBkZWdyZWU6IDEwLCBob3VzZTogNCwgcmV0cm9ncmFkZTogZmFsc2UgfSxcbiAgICB7IG5hbWU6IFwibWFyc1wiLCBzaWduOiBcImxlb1wiLCBkZWdyZWU6IDIwLCBob3VzZTogNSwgcmV0cm9ncmFkZTogZmFsc2UgfSxcbiAgICB7IG5hbWU6IFwianVwaXRlclwiLCBzaWduOiBcInZpcmdvXCIsIGRlZ3JlZTogMTUsIGhvdXNlOiA2LCByZXRyb2dyYWRlOiBmYWxzZSB9LFxuICAgIHsgbmFtZTogXCJzYXR1cm5cIiwgc2lnbjogXCJsaWJyYVwiLCBkZWdyZWU6IDUsIGhvdXNlOiA3LCByZXRyb2dyYWRlOiB0cnVlIH0sXG4gIF1cblxuICAvLyBHZW5lcmF0ZSBwbGFjZWhvbGRlciBob3VzZXNcbiAgY29uc3QgaG91c2VzID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogMTIgfSwgKF8sIGkpID0+ICh7XG4gICAgbnVtYmVyOiBpICsgMSxcbiAgICBzaWduOiBPYmplY3Qua2V5cyh6b2RpYWNTeW1ib2xzKVtpICUgMTJdIGFzIFpvZGlhY1NpZ24sXG4gICAgZGVncmVlOiAoaSAqIDMwKSAlIDM2MCxcbiAgICBjdXNwOiB0cnVlLFxuICB9KSlcblxuICAvLyBHZW5lcmF0ZSBwbGFjZWhvbGRlciBhbmdsZXNcbiAgY29uc3QgYW5nbGVzID0ge1xuICAgIGFzY2VuZGFudDogeyBzaWduOiBcImFyaWVzXCIsIGRlZ3JlZTogMCB9LFxuICAgIG1pZGhlYXZlbjogeyBzaWduOiBcImNhcHJpY29yblwiLCBkZWdyZWU6IDI3MCB9LFxuICAgIGRlc2NlbmRhbnQ6IHsgc2lnbjogXCJsaWJyYVwiLCBkZWdyZWU6IDE4MCB9LFxuICAgIGltdW1Db2VsaTogeyBzaWduOiBcImNhbmNlclwiLCBkZWdyZWU6IDkwIH0sXG4gIH1cblxuICByZXR1cm4ge1xuICAgIHBsYW5ldHMsXG4gICAgaG91c2VzLFxuICAgIGFuZ2xlcyxcbiAgICBhc3BlY3RzOiBbXSxcbiAgICBiaXJ0aERldGFpbHM6IHtcbiAgICAgIGRhdGU6IGJpcnRoRGF0ZSxcbiAgICAgIHRpbWU6IGJpcnRoVGltZSxcbiAgICAgIGxvY2F0aW9uOiB7XG4gICAgICAgIGxhdGl0dWRlLFxuICAgICAgICBsb25naXR1ZGUsXG4gICAgICAgIG5hbWU6IFwiTG9jYXRpb24gZGF0YSB1bmF2YWlsYWJsZVwiLFxuICAgICAgfSxcbiAgICB9LFxuICB9XG59XG5cbiJdLCJuYW1lcyI6WyJmZXRjaE5hdGFsQ2hhcnQiLCJmZXRjaE5hdGFsQ2hhcnRGcm9tQVBJIiwiZ2VvY29kZUxvY2F0aW9uIiwiZ2VvY29kZUxvY2F0aW9uRnJvbUFQSSIsImdldE5hdGFsQ2hhcnRJbnRlcnByZXRhdGlvbiIsImdldEludGVycHJldGF0aW9uRnJvbUFQSSIsImdldERhaWx5SG9yb3Njb3BlIiwiZ2V0RGFpbHlIb3Jvc2NvcGVGcm9tQVBJIiwiZmV0Y2hOYXRhbFdoZWVsQ2hhcnRTVkciLCJmZXRjaE5hdGFsV2hlZWxDaGFydFNWR0Zyb21BUEkiLCJiaXJ0aERhdGUiLCJiaXJ0aFRpbWUiLCJsYXRpdHVkZSIsImxvbmdpdHVkZSIsInRpbWV6b25lIiwiTWF0aCIsInJvdW5kIiwiZXJyb3IiLCJjb25zb2xlIiwibG9jYXRpb25TdHJpbmciLCJzaW1wbGVHZW9jb2RlIiwiZ2V0U2ltcGxlR2VvY29kaW5nIiwibG9nIiwicmVzdWx0Iiwid2FybiIsInJlc3BvbnNlIiwiZmV0Y2giLCJtZXRob2QiLCJoZWFkZXJzIiwiYm9keSIsIkpTT04iLCJzdHJpbmdpZnkiLCJsb2NhdGlvbiIsIm9rIiwiZGF0YSIsImpzb24iLCJuYW1lIiwiZm9yY2VGYWxsYmFjayIsIm5vcm1hbGl6ZWRJbnB1dCIsInRvTG93ZXJDYXNlIiwidHJpbSIsImNpdHlDb29yZGluYXRlcyIsImNoaWNhZ28iLCJ0b3JvbnRvIiwibG9uZG9uIiwicGFyaXMiLCJiZXJsaW4iLCJtYWRyaWQiLCJyb21lIiwiYW1zdGVyZGFtIiwidmllbm5hIiwiaGFtYnVyZyIsInRva3lvIiwiYmVpamluZyIsIm11bWJhaSIsInNpbmdhcG9yZSIsInN5ZG5leSIsIm1lbGJvdXJuZSIsImNhaXJvIiwiY2l0eSIsImNvb3JkaW5hdGVzIiwiT2JqZWN0IiwiZW50cmllcyIsImluY2x1ZGVzIiwibGVuZ3RoIiwibmF0YWxDaGFydCIsInNpZ24iLCJ6b2RpYWNTeW1ib2xzIiwiYXJpZXMiLCJ0YXVydXMiLCJnZW1pbmkiLCJjYW5jZXIiLCJsZW8iLCJ2aXJnbyIsImxpYnJhIiwic2NvcnBpbyIsInNhZ2l0dGFyaXVzIiwiY2Fwcmljb3JuIiwiYXF1YXJpdXMiLCJwaXNjZXMiLCJjcmVhdGVQbGFjZWhvbGRlckNoYXJ0IiwieWVhciIsIm1vbnRoIiwiZGF5Iiwic3BsaXQiLCJtYXAiLCJOdW1iZXIiLCJob3VyIiwibWludXRlIiwicGxhbmV0cyIsImRlZ3JlZSIsImhvdXNlIiwicmV0cm9ncmFkZSIsImhvdXNlcyIsIkFycmF5IiwiZnJvbSIsIl8iLCJpIiwibnVtYmVyIiwia2V5cyIsImN1c3AiLCJhbmdsZXMiLCJhc2NlbmRhbnQiLCJtaWRoZWF2ZW4iLCJkZXNjZW5kYW50IiwiaW11bUNvZWxpIiwiYXNwZWN0cyIsImJpcnRoRGV0YWlscyIsImRhdGUiLCJ0aW1lIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./services/astrology-service.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./utils/fallback-chart.ts":
/*!*********************************!*\
  !*** ./utils/fallback-chart.ts ***!
  \*********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getFallbackChartSVG: () => (/* binding */ getFallbackChartSVG),\n/* harmony export */   getFallbackNatalChart: () => (/* binding */ getFallbackNatalChart),\n/* harmony export */   loadFallbackNatalChart: () => (/* binding */ loadFallbackNatalChart),\n/* harmony export */   preloadFallbackNatalChart: () => (/* binding */ preloadFallbackNatalChart),\n/* harmony export */   sanitizeSvg: () => (/* binding */ sanitizeSvg)\n/* harmony export */ });\n/* harmony import */ var _utils_safe_storage__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/utils/safe-storage */ \"(app-pages-browser)/./utils/safe-storage.ts\");\n\nconst getFallbackChartSVG = ()=>{\n    return '<svg \\n    xmlns=\"http://www.w3.org/2000/svg\" \\n    viewBox=\"0 0 800 800\" \\n    width=\"100%\" \\n    height=\"100%\"\\n  >\\n    <!-- Outer circle -->\\n    <circle cx=\"400\" cy=\"400\" r=\"350\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" />\\n    \\n    <!-- Inner circle -->\\n    <circle cx=\"400\" cy=\"400\" r=\"300\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"1\" />\\n    \\n    <!-- Zodiac divisions - 12 segments -->\\n    '.concat(Array.from({\n        length: 12\n    }).map((_, i)=>{\n        const angle = i * 30 * Math.PI / 180;\n        const x1 = 400 + 350 * Math.cos(angle);\n        const y1 = 400 + 350 * Math.sin(angle);\n        const x2 = 400 + 300 * Math.cos(angle);\n        const y2 = 400 + 300 * Math.sin(angle);\n        return '<line x1=\"'.concat(x1, '\" y1=\"').concat(y1, '\" x2=\"').concat(x2, '\" y2=\"').concat(y2, '\" stroke=\"currentColor\" stroke-width=\"1\" />');\n    }).join(\"\"), \"\\n    \\n    <!-- Zodiac symbols -->\\n    \").concat([\n        {\n            symbol: \"\",\n            name: \"Aries\",\n            angle: 15\n        },\n        {\n            symbol: \"\",\n            name: \"Taurus\",\n            angle: 45\n        },\n        {\n            symbol: \"\",\n            name: \"Gemini\",\n            angle: 75\n        },\n        {\n            symbol: \"\",\n            name: \"Cancer\",\n            angle: 105\n        },\n        {\n            symbol: \"\",\n            name: \"Leo\",\n            angle: 135\n        },\n        {\n            symbol: \"\",\n            name: \"Virgo\",\n            angle: 165\n        },\n        {\n            symbol: \"\",\n            name: \"Libra\",\n            angle: 195\n        },\n        {\n            symbol: \"\",\n            name: \"Scorpio\",\n            angle: 225\n        },\n        {\n            symbol: \"\",\n            name: \"Sagittarius\",\n            angle: 255\n        },\n        {\n            symbol: \"\",\n            name: \"Capricorn\",\n            angle: 285\n        },\n        {\n            symbol: \"\",\n            name: \"Aquarius\",\n            angle: 315\n        },\n        {\n            symbol: \"\",\n            name: \"Pisces\",\n            angle: 345\n        }\n    ].map((sign)=>{\n        const angle = sign.angle * Math.PI / 180;\n        const x = 400 + 325 * Math.cos(angle);\n        const y = 400 + 325 * Math.sin(angle);\n        return '\\n        <text \\n          x=\"'.concat(x, '\" \\n          y=\"').concat(y, '\" \\n          text-anchor=\"middle\" \\n          dominant-baseline=\"middle\" \\n          fill=\"currentColor\" \\n          font-size=\"20\"\\n          font-family=\"Arial, sans-serif\"\\n        >\\n          ').concat(sign.symbol, \"\\n        </text>\\n      \");\n    }).join(\"\"), '\\n    \\n    <!-- Center point -->\\n    <circle cx=\"400\" cy=\"400\" r=\"5\" fill=\"currentColor\" />\\n  </svg>').trim();\n};\n// Keep the existing functions for backward compatibility\nfunction getFallbackNatalChart() {\n    return getFallbackChartSVG();\n}\nasync function loadFallbackNatalChart() {\n    // This function simulates loading the fallback chart.\n    return getFallbackChartSVG();\n}\nasync function preloadFallbackNatalChart() {\n    console.log(\"Preloading fallback natal chart\");\n    try {\n        // Try to load from public folder first\n        const response = await fetch(\"/images/fallback-natal-chart.svg\");\n        if (response.ok) {\n            const svgText = await response.text();\n            console.log(\"Preloaded SVG from public folder, length:\", svgText.length);\n            // Sanitize the SVG before storing\n            const sanitizedSvg = sanitizeSvg(svgText);\n            // Store in sessionStorage for quick access\n            (0,_utils_safe_storage__WEBPACK_IMPORTED_MODULE_0__.safeSetSessionItem)(\"fallbackNatalChartSVG\", sanitizedSvg);\n        } else {\n            throw new Error(\"SVG file not found\");\n        }\n    } catch (error) {\n        console.log(\"Error preloading SVG, generating fallback:\", error);\n        // Generate fallback\n        const fallbackSvg = getFallbackChartSVG();\n        // Store in sessionStorage\n        (0,_utils_safe_storage__WEBPACK_IMPORTED_MODULE_0__.safeSetSessionItem)(\"fallbackNatalChartSVG\", fallbackSvg);\n    }\n}\n// Helper function to sanitize SVG content\nfunction sanitizeSvg(svgContent) {\n    if (false) {}\n    try {\n        const parser = new DOMParser();\n        const svgDoc = parser.parseFromString(svgContent, \"image/svg+xml\");\n        const svgElement = svgDoc.documentElement;\n        // Fix invalid attributes - specifically the \"hidden\" attribute\n        const elementsWithHidden = svgElement.querySelectorAll(\"[hidden]\");\n        elementsWithHidden.forEach((el)=>{\n            const hiddenValue = el.getAttribute(\"hidden\");\n            if (hiddenValue === \"\" || hiddenValue === null) {\n                // Set a valid value for the hidden attribute\n                el.setAttribute(\"hidden\", \"true\");\n            }\n        });\n        return svgElement.outerHTML;\n    } catch (error) {\n        console.error(\"Error sanitizing SVG:\", error);\n        return svgContent;\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3V0aWxzL2ZhbGxiYWNrLWNoYXJ0LnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUF5RDtBQUVsRCxNQUFNQyxzQkFBc0I7SUFDakMsT0FBTyx1YUF5QkgsT0FaQUMsTUFBTUMsSUFBSSxDQUFDO1FBQUVDLFFBQVE7SUFBRyxHQUN2QkMsR0FBRyxDQUFDLENBQUNDLEdBQUdDO1FBQ1AsTUFBTUMsUUFBUSxJQUFLLEtBQUtDLEtBQUtDLEVBQUUsR0FBSTtRQUNuQyxNQUFNQyxLQUFLLE1BQU0sTUFBTUYsS0FBS0csR0FBRyxDQUFDSjtRQUNoQyxNQUFNSyxLQUFLLE1BQU0sTUFBTUosS0FBS0ssR0FBRyxDQUFDTjtRQUNoQyxNQUFNTyxLQUFLLE1BQU0sTUFBTU4sS0FBS0csR0FBRyxDQUFDSjtRQUNoQyxNQUFNUSxLQUFLLE1BQU0sTUFBTVAsS0FBS0ssR0FBRyxDQUFDTjtRQUNoQyxPQUFPLGFBQXdCSyxPQUFYRixJQUFHLFVBQW1CSSxPQUFYRixJQUFHLFVBQW1CRyxPQUFYRCxJQUFHLFVBQVcsT0FBSEMsSUFBRztJQUMxRCxHQUNDQyxJQUFJLENBQUMsS0FBSSw2Q0FtQ0EsT0FoQ1Y7UUFDQTtZQUFFQyxRQUFRO1lBQUtDLE1BQU07WUFBU1gsT0FBTztRQUFHO1FBQ3hDO1lBQUVVLFFBQVE7WUFBS0MsTUFBTTtZQUFVWCxPQUFPO1FBQUc7UUFDekM7WUFBRVUsUUFBUTtZQUFLQyxNQUFNO1lBQVVYLE9BQU87UUFBRztRQUN6QztZQUFFVSxRQUFRO1lBQUtDLE1BQU07WUFBVVgsT0FBTztRQUFJO1FBQzFDO1lBQUVVLFFBQVE7WUFBS0MsTUFBTTtZQUFPWCxPQUFPO1FBQUk7UUFDdkM7WUFBRVUsUUFBUTtZQUFLQyxNQUFNO1lBQVNYLE9BQU87UUFBSTtRQUN6QztZQUFFVSxRQUFRO1lBQUtDLE1BQU07WUFBU1gsT0FBTztRQUFJO1FBQ3pDO1lBQUVVLFFBQVE7WUFBS0MsTUFBTTtZQUFXWCxPQUFPO1FBQUk7UUFDM0M7WUFBRVUsUUFBUTtZQUFLQyxNQUFNO1lBQWVYLE9BQU87UUFBSTtRQUMvQztZQUFFVSxRQUFRO1lBQUtDLE1BQU07WUFBYVgsT0FBTztRQUFJO1FBQzdDO1lBQUVVLFFBQVE7WUFBS0MsTUFBTTtZQUFZWCxPQUFPO1FBQUk7UUFDNUM7WUFBRVUsUUFBUTtZQUFLQyxNQUFNO1lBQVVYLE9BQU87UUFBSTtLQUMzQyxDQUNFSCxHQUFHLENBQUMsQ0FBQ2U7UUFDSixNQUFNWixRQUFRLEtBQU1BLEtBQUssR0FBR0MsS0FBS0MsRUFBRSxHQUFJO1FBQ3ZDLE1BQU1XLElBQUksTUFBTSxNQUFNWixLQUFLRyxHQUFHLENBQUNKO1FBQy9CLE1BQU1jLElBQUksTUFBTSxNQUFNYixLQUFLSyxHQUFHLENBQUNOO1FBQy9CLE9BQU8sa0NBR0FjLE9BREFELEdBQUUscUJBUUxELE9BUEdFLEdBQUUsME1BT08sT0FBWkYsS0FBS0YsTUFBTSxFQUFDO0lBR2xCLEdBQ0NELElBQUksQ0FBQyxLQUFJLDJHQUlOTSxJQUFJO0FBQ2QsRUFBQztBQUVELHlEQUF5RDtBQUNsRCxTQUFTQztJQUNkLE9BQU92QjtBQUNUO0FBRU8sZUFBZXdCO0lBQ3BCLHNEQUFzRDtJQUN0RCxPQUFPeEI7QUFDVDtBQUVPLGVBQWV5QjtJQUNwQkMsUUFBUUMsR0FBRyxDQUFDO0lBQ1osSUFBSTtRQUNGLHVDQUF1QztRQUN2QyxNQUFNQyxXQUFXLE1BQU1DLE1BQU07UUFDN0IsSUFBSUQsU0FBU0UsRUFBRSxFQUFFO1lBQ2YsTUFBTUMsVUFBVSxNQUFNSCxTQUFTSSxJQUFJO1lBQ25DTixRQUFRQyxHQUFHLENBQUMsNkNBQTZDSSxRQUFRNUIsTUFBTTtZQUV2RSxrQ0FBa0M7WUFDbEMsTUFBTThCLGVBQWVDLFlBQVlIO1lBRWpDLDJDQUEyQztZQUMzQ2hDLHVFQUFrQkEsQ0FBQyx5QkFBeUJrQztRQUM5QyxPQUFPO1lBQ0wsTUFBTSxJQUFJRSxNQUFNO1FBQ2xCO0lBQ0YsRUFBRSxPQUFPQyxPQUFPO1FBQ2RWLFFBQVFDLEdBQUcsQ0FBQyw4Q0FBOENTO1FBQzFELG9CQUFvQjtRQUNwQixNQUFNQyxjQUFjckM7UUFDcEIsMEJBQTBCO1FBQzFCRCx1RUFBa0JBLENBQUMseUJBQXlCc0M7SUFDOUM7QUFDRjtBQUVBLDBDQUEwQztBQUNuQyxTQUFTSCxZQUFZSSxVQUFrQjtJQUM1QyxJQUFJLEtBQTZCLEVBQUUsRUFHbEM7SUFFRCxJQUFJO1FBQ0YsTUFBTUMsU0FBUyxJQUFJQztRQUNuQixNQUFNQyxTQUFTRixPQUFPRyxlQUFlLENBQUNKLFlBQVk7UUFDbEQsTUFBTUssYUFBYUYsT0FBT0csZUFBZTtRQUV6QywrREFBK0Q7UUFDL0QsTUFBTUMscUJBQXFCRixXQUFXRyxnQkFBZ0IsQ0FBQztRQUN2REQsbUJBQW1CRSxPQUFPLENBQUMsQ0FBQ0M7WUFDMUIsTUFBTUMsY0FBY0QsR0FBR0UsWUFBWSxDQUFDO1lBQ3BDLElBQUlELGdCQUFnQixNQUFNQSxnQkFBZ0IsTUFBTTtnQkFDOUMsNkNBQTZDO2dCQUM3Q0QsR0FBR0csWUFBWSxDQUFDLFVBQVU7WUFDNUI7UUFDRjtRQUVBLE9BQU9SLFdBQVdTLFNBQVM7SUFDN0IsRUFBRSxPQUFPaEIsT0FBTztRQUNkVixRQUFRVSxLQUFLLENBQUMseUJBQXlCQTtRQUN2QyxPQUFPRTtJQUNUO0FBQ0YiLCJzb3VyY2VzIjpbIi9Vc2Vycy9tYXJrb25vdmFrb3Zza2kvRG9jdW1lbnRzL1Zpc3VhbCBDb2RlL0FzdHJvQm9vay9Bc3Ryb0Jvb2svdXRpbHMvZmFsbGJhY2stY2hhcnQudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgc2FmZVNldFNlc3Npb25JdGVtIH0gZnJvbSBcIkAvdXRpbHMvc2FmZS1zdG9yYWdlXCJcblxuZXhwb3J0IGNvbnN0IGdldEZhbGxiYWNrQ2hhcnRTVkcgPSAoKSA9PiB7XG4gIHJldHVybiBgPHN2ZyBcbiAgICB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgXG4gICAgdmlld0JveD1cIjAgMCA4MDAgODAwXCIgXG4gICAgd2lkdGg9XCIxMDAlXCIgXG4gICAgaGVpZ2h0PVwiMTAwJVwiXG4gID5cbiAgICA8IS0tIE91dGVyIGNpcmNsZSAtLT5cbiAgICA8Y2lyY2xlIGN4PVwiNDAwXCIgY3k9XCI0MDBcIiByPVwiMzUwXCIgZmlsbD1cIm5vbmVcIiBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2Utd2lkdGg9XCIyXCIgLz5cbiAgICBcbiAgICA8IS0tIElubmVyIGNpcmNsZSAtLT5cbiAgICA8Y2lyY2xlIGN4PVwiNDAwXCIgY3k9XCI0MDBcIiByPVwiMzAwXCIgZmlsbD1cIm5vbmVcIiBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2Utd2lkdGg9XCIxXCIgLz5cbiAgICBcbiAgICA8IS0tIFpvZGlhYyBkaXZpc2lvbnMgLSAxMiBzZWdtZW50cyAtLT5cbiAgICAke0FycmF5LmZyb20oeyBsZW5ndGg6IDEyIH0pXG4gICAgICAubWFwKChfLCBpKSA9PiB7XG4gICAgICAgIGNvbnN0IGFuZ2xlID0gKGkgKiAzMCAqIE1hdGguUEkpIC8gMTgwXG4gICAgICAgIGNvbnN0IHgxID0gNDAwICsgMzUwICogTWF0aC5jb3MoYW5nbGUpXG4gICAgICAgIGNvbnN0IHkxID0gNDAwICsgMzUwICogTWF0aC5zaW4oYW5nbGUpXG4gICAgICAgIGNvbnN0IHgyID0gNDAwICsgMzAwICogTWF0aC5jb3MoYW5nbGUpXG4gICAgICAgIGNvbnN0IHkyID0gNDAwICsgMzAwICogTWF0aC5zaW4oYW5nbGUpXG4gICAgICAgIHJldHVybiBgPGxpbmUgeDE9XCIke3gxfVwiIHkxPVwiJHt5MX1cIiB4Mj1cIiR7eDJ9XCIgeTI9XCIke3kyfVwiIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS13aWR0aD1cIjFcIiAvPmBcbiAgICAgIH0pXG4gICAgICAuam9pbihcIlwiKX1cbiAgICBcbiAgICA8IS0tIFpvZGlhYyBzeW1ib2xzIC0tPlxuICAgICR7W1xuICAgICAgeyBzeW1ib2w6IFwi4pmIXCIsIG5hbWU6IFwiQXJpZXNcIiwgYW5nbGU6IDE1IH0sXG4gICAgICB7IHN5bWJvbDogXCLimYlcIiwgbmFtZTogXCJUYXVydXNcIiwgYW5nbGU6IDQ1IH0sXG4gICAgICB7IHN5bWJvbDogXCLimYpcIiwgbmFtZTogXCJHZW1pbmlcIiwgYW5nbGU6IDc1IH0sXG4gICAgICB7IHN5bWJvbDogXCLimYtcIiwgbmFtZTogXCJDYW5jZXJcIiwgYW5nbGU6IDEwNSB9LFxuICAgICAgeyBzeW1ib2w6IFwi4pmMXCIsIG5hbWU6IFwiTGVvXCIsIGFuZ2xlOiAxMzUgfSxcbiAgICAgIHsgc3ltYm9sOiBcIuKZjVwiLCBuYW1lOiBcIlZpcmdvXCIsIGFuZ2xlOiAxNjUgfSxcbiAgICAgIHsgc3ltYm9sOiBcIuKZjlwiLCBuYW1lOiBcIkxpYnJhXCIsIGFuZ2xlOiAxOTUgfSxcbiAgICAgIHsgc3ltYm9sOiBcIuKZj1wiLCBuYW1lOiBcIlNjb3JwaW9cIiwgYW5nbGU6IDIyNSB9LFxuICAgICAgeyBzeW1ib2w6IFwi4pmQXCIsIG5hbWU6IFwiU2FnaXR0YXJpdXNcIiwgYW5nbGU6IDI1NSB9LFxuICAgICAgeyBzeW1ib2w6IFwi4pmRXCIsIG5hbWU6IFwiQ2Fwcmljb3JuXCIsIGFuZ2xlOiAyODUgfSxcbiAgICAgIHsgc3ltYm9sOiBcIuKZklwiLCBuYW1lOiBcIkFxdWFyaXVzXCIsIGFuZ2xlOiAzMTUgfSxcbiAgICAgIHsgc3ltYm9sOiBcIuKZk1wiLCBuYW1lOiBcIlBpc2Nlc1wiLCBhbmdsZTogMzQ1IH0sXG4gICAgXVxuICAgICAgLm1hcCgoc2lnbikgPT4ge1xuICAgICAgICBjb25zdCBhbmdsZSA9IChzaWduLmFuZ2xlICogTWF0aC5QSSkgLyAxODBcbiAgICAgICAgY29uc3QgeCA9IDQwMCArIDMyNSAqIE1hdGguY29zKGFuZ2xlKVxuICAgICAgICBjb25zdCB5ID0gNDAwICsgMzI1ICogTWF0aC5zaW4oYW5nbGUpXG4gICAgICAgIHJldHVybiBgXG4gICAgICAgIDx0ZXh0IFxuICAgICAgICAgIHg9XCIke3h9XCIgXG4gICAgICAgICAgeT1cIiR7eX1cIiBcbiAgICAgICAgICB0ZXh0LWFuY2hvcj1cIm1pZGRsZVwiIFxuICAgICAgICAgIGRvbWluYW50LWJhc2VsaW5lPVwibWlkZGxlXCIgXG4gICAgICAgICAgZmlsbD1cImN1cnJlbnRDb2xvclwiIFxuICAgICAgICAgIGZvbnQtc2l6ZT1cIjIwXCJcbiAgICAgICAgICBmb250LWZhbWlseT1cIkFyaWFsLCBzYW5zLXNlcmlmXCJcbiAgICAgICAgPlxuICAgICAgICAgICR7c2lnbi5zeW1ib2x9XG4gICAgICAgIDwvdGV4dD5cbiAgICAgIGBcbiAgICAgIH0pXG4gICAgICAuam9pbihcIlwiKX1cbiAgICBcbiAgICA8IS0tIENlbnRlciBwb2ludCAtLT5cbiAgICA8Y2lyY2xlIGN4PVwiNDAwXCIgY3k9XCI0MDBcIiByPVwiNVwiIGZpbGw9XCJjdXJyZW50Q29sb3JcIiAvPlxuICA8L3N2Zz5gLnRyaW0oKVxufVxuXG4vLyBLZWVwIHRoZSBleGlzdGluZyBmdW5jdGlvbnMgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHlcbmV4cG9ydCBmdW5jdGlvbiBnZXRGYWxsYmFja05hdGFsQ2hhcnQoKTogc3RyaW5nIHtcbiAgcmV0dXJuIGdldEZhbGxiYWNrQ2hhcnRTVkcoKVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gbG9hZEZhbGxiYWNrTmF0YWxDaGFydCgpOiBQcm9taXNlPHN0cmluZz4ge1xuICAvLyBUaGlzIGZ1bmN0aW9uIHNpbXVsYXRlcyBsb2FkaW5nIHRoZSBmYWxsYmFjayBjaGFydC5cbiAgcmV0dXJuIGdldEZhbGxiYWNrQ2hhcnRTVkcoKVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcHJlbG9hZEZhbGxiYWNrTmF0YWxDaGFydCgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgY29uc29sZS5sb2coXCJQcmVsb2FkaW5nIGZhbGxiYWNrIG5hdGFsIGNoYXJ0XCIpXG4gIHRyeSB7XG4gICAgLy8gVHJ5IHRvIGxvYWQgZnJvbSBwdWJsaWMgZm9sZGVyIGZpcnN0XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChcIi9pbWFnZXMvZmFsbGJhY2stbmF0YWwtY2hhcnQuc3ZnXCIpXG4gICAgaWYgKHJlc3BvbnNlLm9rKSB7XG4gICAgICBjb25zdCBzdmdUZXh0ID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpXG4gICAgICBjb25zb2xlLmxvZyhcIlByZWxvYWRlZCBTVkcgZnJvbSBwdWJsaWMgZm9sZGVyLCBsZW5ndGg6XCIsIHN2Z1RleHQubGVuZ3RoKVxuXG4gICAgICAvLyBTYW5pdGl6ZSB0aGUgU1ZHIGJlZm9yZSBzdG9yaW5nXG4gICAgICBjb25zdCBzYW5pdGl6ZWRTdmcgPSBzYW5pdGl6ZVN2ZyhzdmdUZXh0KVxuXG4gICAgICAvLyBTdG9yZSBpbiBzZXNzaW9uU3RvcmFnZSBmb3IgcXVpY2sgYWNjZXNzXG4gICAgICBzYWZlU2V0U2Vzc2lvbkl0ZW0oXCJmYWxsYmFja05hdGFsQ2hhcnRTVkdcIiwgc2FuaXRpemVkU3ZnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU1ZHIGZpbGUgbm90IGZvdW5kXCIpXG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUubG9nKFwiRXJyb3IgcHJlbG9hZGluZyBTVkcsIGdlbmVyYXRpbmcgZmFsbGJhY2s6XCIsIGVycm9yKVxuICAgIC8vIEdlbmVyYXRlIGZhbGxiYWNrXG4gICAgY29uc3QgZmFsbGJhY2tTdmcgPSBnZXRGYWxsYmFja0NoYXJ0U1ZHKClcbiAgICAvLyBTdG9yZSBpbiBzZXNzaW9uU3RvcmFnZVxuICAgIHNhZmVTZXRTZXNzaW9uSXRlbShcImZhbGxiYWNrTmF0YWxDaGFydFNWR1wiLCBmYWxsYmFja1N2Zyk7XG4gIH1cbn1cblxuLy8gSGVscGVyIGZ1bmN0aW9uIHRvIHNhbml0aXplIFNWRyBjb250ZW50XG5leHBvcnQgZnVuY3Rpb24gc2FuaXRpemVTdmcoc3ZnQ29udGVudDogc3RyaW5nKTogc3RyaW5nIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAvLyBTZXJ2ZXItc2lkZSAtIHJldHVybiBhcyBpc1xuICAgIHJldHVybiBzdmdDb250ZW50XG4gIH1cblxuICB0cnkge1xuICAgIGNvbnN0IHBhcnNlciA9IG5ldyBET01QYXJzZXIoKVxuICAgIGNvbnN0IHN2Z0RvYyA9IHBhcnNlci5wYXJzZUZyb21TdHJpbmcoc3ZnQ29udGVudCwgXCJpbWFnZS9zdmcreG1sXCIpXG4gICAgY29uc3Qgc3ZnRWxlbWVudCA9IHN2Z0RvYy5kb2N1bWVudEVsZW1lbnRcblxuICAgIC8vIEZpeCBpbnZhbGlkIGF0dHJpYnV0ZXMgLSBzcGVjaWZpY2FsbHkgdGhlIFwiaGlkZGVuXCIgYXR0cmlidXRlXG4gICAgY29uc3QgZWxlbWVudHNXaXRoSGlkZGVuID0gc3ZnRWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiW2hpZGRlbl1cIilcbiAgICBlbGVtZW50c1dpdGhIaWRkZW4uZm9yRWFjaCgoZWwpID0+IHtcbiAgICAgIGNvbnN0IGhpZGRlblZhbHVlID0gZWwuZ2V0QXR0cmlidXRlKFwiaGlkZGVuXCIpXG4gICAgICBpZiAoaGlkZGVuVmFsdWUgPT09IFwiXCIgfHwgaGlkZGVuVmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgLy8gU2V0IGEgdmFsaWQgdmFsdWUgZm9yIHRoZSBoaWRkZW4gYXR0cmlidXRlXG4gICAgICAgIGVsLnNldEF0dHJpYnV0ZShcImhpZGRlblwiLCBcInRydWVcIilcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgcmV0dXJuIHN2Z0VsZW1lbnQub3V0ZXJIVE1MXG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihcIkVycm9yIHNhbml0aXppbmcgU1ZHOlwiLCBlcnJvcilcbiAgICByZXR1cm4gc3ZnQ29udGVudFxuICB9XG59XG5cbiJdLCJuYW1lcyI6WyJzYWZlU2V0U2Vzc2lvbkl0ZW0iLCJnZXRGYWxsYmFja0NoYXJ0U1ZHIiwiQXJyYXkiLCJmcm9tIiwibGVuZ3RoIiwibWFwIiwiXyIsImkiLCJhbmdsZSIsIk1hdGgiLCJQSSIsIngxIiwiY29zIiwieTEiLCJzaW4iLCJ4MiIsInkyIiwiam9pbiIsInN5bWJvbCIsIm5hbWUiLCJzaWduIiwieCIsInkiLCJ0cmltIiwiZ2V0RmFsbGJhY2tOYXRhbENoYXJ0IiwibG9hZEZhbGxiYWNrTmF0YWxDaGFydCIsInByZWxvYWRGYWxsYmFja05hdGFsQ2hhcnQiLCJjb25zb2xlIiwibG9nIiwicmVzcG9uc2UiLCJmZXRjaCIsIm9rIiwic3ZnVGV4dCIsInRleHQiLCJzYW5pdGl6ZWRTdmciLCJzYW5pdGl6ZVN2ZyIsIkVycm9yIiwiZXJyb3IiLCJmYWxsYmFja1N2ZyIsInN2Z0NvbnRlbnQiLCJwYXJzZXIiLCJET01QYXJzZXIiLCJzdmdEb2MiLCJwYXJzZUZyb21TdHJpbmciLCJzdmdFbGVtZW50IiwiZG9jdW1lbnRFbGVtZW50IiwiZWxlbWVudHNXaXRoSGlkZGVuIiwicXVlcnlTZWxlY3RvckFsbCIsImZvckVhY2giLCJlbCIsImhpZGRlblZhbHVlIiwiZ2V0QXR0cmlidXRlIiwic2V0QXR0cmlidXRlIiwib3V0ZXJIVE1MIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./utils/fallback-chart.ts\n"));

/***/ })

}]);