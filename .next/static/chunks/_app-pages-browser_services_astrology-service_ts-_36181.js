"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_services_astrology-service_ts-_36181"],{

/***/ "(app-pages-browser)/./services/astrology-service.ts":
/*!***************************************!*\
  !*** ./services/astrology-service.ts ***!
  \***************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fetchNatalChart: () => (/* binding */ fetchNatalChart),\n/* harmony export */   fetchNatalWheelChartSVG: () => (/* binding */ fetchNatalWheelChartSVG),\n/* harmony export */   geocodeLocation: () => (/* binding */ geocodeLocation),\n/* harmony export */   getDailyHoroscope: () => (/* binding */ getDailyHoroscope),\n/* harmony export */   getNatalChartInterpretation: () => (/* binding */ getNatalChartInterpretation)\n/* harmony export */ });\n/* harmony import */ var _astrology_api_service__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./astrology-api-service */ \"(app-pages-browser)/./services/astrology-api-service.ts\");\n/**\n * Astrology Service\n * Handles all interactions with astrology APIs and data processing\n */ \n/**\n * Fetches natal chart data\n */ async function fetchNatalChart(birthDate, birthTime, latitude, longitude) {\n    try {\n        // Calculate timezone from longitude (approximate)\n        // In a real app, you would use a timezone API or library\n        const timezone = Math.round(longitude / 15);\n        // Use the AstrologyAPI service\n        return await (0,_astrology_api_service__WEBPACK_IMPORTED_MODULE_0__.fetchNatalChart)(birthDate, birthTime, latitude, longitude, timezone);\n    } catch (error) {\n        console.error(\"Error fetching natal chart:\", error);\n        throw error;\n    }\n}\n/**\n * Fetches natal wheel chart SVG\n */ async function fetchNatalWheelChartSVG(birthDate, birthTime, latitude, longitude) {\n    try {\n        // Calculate timezone from longitude (approximate)\n        const timezone = Math.round(longitude / 15);\n        // Use the AstrologyAPI service\n        return await (0,_astrology_api_service__WEBPACK_IMPORTED_MODULE_0__.fetchNatalWheelChartSVG)(birthDate, birthTime, latitude, longitude, timezone);\n    } catch (error) {\n        console.error(\"Error fetching natal wheel chart SVG:\", error);\n        throw error;\n    }\n}\n// Update the geocodeLocation function to handle errors better\n/**\n * Geocodes a location string to get latitude and longitude\n */ async function geocodeLocation(locationString) {\n    try {\n        // Try to use a simple geocoding approach first\n        // This is a fallback in case the API fails\n        const simpleGeocode = getSimpleGeocoding(locationString);\n        if (simpleGeocode) {\n            console.log(\"Using simple geocoding for:\", locationString);\n            return simpleGeocode;\n        }\n        // If simple geocoding doesn't work, try the API\n        console.log(\"Attempting API geocoding for:\", locationString);\n        // Use the AstrologyAPI geocoding service\n        const result = await (0,_astrology_api_service__WEBPACK_IMPORTED_MODULE_0__.geocodeLocation)(locationString);\n        // Validate the result\n        if (result.latitude === 0 && result.longitude === 0) {\n            console.log(\"API geocoding returned default coordinates, trying fallback\");\n            // If API returned default coordinates, try our fallback\n            const fallback = getSimpleGeocoding(locationString, true);\n            if (fallback) {\n                return fallback;\n            }\n        }\n        return result;\n    } catch (error) {\n        console.error(\"Error in geocoding service:\", error);\n        // Return fallback data instead of throwing\n        return {\n            latitude: 0,\n            longitude: 0,\n            name: locationString\n        };\n    }\n}\n/**\n * Simple geocoding function for common locations\n * This serves as a fallback when the API fails\n */ function getSimpleGeocoding(locationString) {\n    let forceFallback = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;\n    // Normalize the input\n    const normalizedInput = locationString.toLowerCase().trim();\n    // Common city coordinates\n    const cityCoordinates = {\n        // North America\n        \"new york\": [\n            40.7128,\n            -74.006\n        ],\n        \"los angeles\": [\n            34.0522,\n            -118.2437\n        ],\n        chicago: [\n            41.8781,\n            -87.6298\n        ],\n        toronto: [\n            43.6532,\n            -79.3832\n        ],\n        \"mexico city\": [\n            19.4326,\n            -99.1332\n        ],\n        // Europe\n        london: [\n            51.5074,\n            -0.1278\n        ],\n        paris: [\n            48.8566,\n            2.3522\n        ],\n        berlin: [\n            52.52,\n            13.405\n        ],\n        madrid: [\n            40.4168,\n            -3.7038\n        ],\n        rome: [\n            41.9028,\n            12.4964\n        ],\n        amsterdam: [\n            52.3676,\n            4.9041\n        ],\n        vienna: [\n            48.2082,\n            16.3738\n        ],\n        hamburg: [\n            53.5511,\n            9.9937\n        ],\n        // Asia\n        tokyo: [\n            35.6762,\n            139.6503\n        ],\n        beijing: [\n            39.9042,\n            116.4074\n        ],\n        mumbai: [\n            19.076,\n            72.8777\n        ],\n        singapore: [\n            1.3521,\n            103.8198\n        ],\n        // Australia\n        sydney: [\n            -33.8688,\n            151.2093\n        ],\n        melbourne: [\n            -37.8136,\n            144.9631\n        ],\n        // South America\n        \"rio de janeiro\": [\n            -22.9068,\n            -43.1729\n        ],\n        \"buenos aires\": [\n            -34.6037,\n            -58.3816\n        ],\n        // Africa\n        cairo: [\n            30.0444,\n            31.2357\n        ],\n        \"cape town\": [\n            -33.9249,\n            18.4241\n        ]\n    };\n    // Check for exact matches\n    for (const [city, coordinates] of Object.entries(cityCoordinates)){\n        if (normalizedInput.includes(city)) {\n            return {\n                latitude: coordinates[0],\n                longitude: coordinates[1],\n                name: locationString\n            };\n        }\n    }\n    // If we're forcing a fallback or the input is very short, use a default\n    if (forceFallback || normalizedInput.length < 3) {\n        // Default to a central location (0,0 is in the Atlantic Ocean)\n        return {\n            latitude: 0,\n            longitude: 0,\n            name: locationString\n        };\n    }\n    // No match found\n    return null;\n}\n/**\n * Gets interpretations for a natal chart\n */ async function getNatalChartInterpretation(natalChart) {\n    try {\n        // Use the AstrologyAPI interpretation service\n        return await (0,_astrology_api_service__WEBPACK_IMPORTED_MODULE_0__.getNatalChartInterpretation)(natalChart);\n    } catch (error) {\n        console.error(\"Error getting chart interpretation:\", error);\n        throw error;\n    }\n}\n/**\n * Gets a daily horoscope for a zodiac sign\n */ async function getDailyHoroscope(sign) {\n    try {\n        // Use the AstrologyAPI horoscope service\n        return await (0,_astrology_api_service__WEBPACK_IMPORTED_MODULE_0__.getDailyHoroscope)(sign);\n    } catch (error) {\n        console.error(\"Error getting daily horoscope:\", error);\n        throw error;\n    }\n}\n// Define zodiacSymbols\nconst zodiacSymbols = {\n    aries: \"♈\",\n    taurus: \"♉\",\n    gemini: \"♊\",\n    cancer: \"♋\",\n    leo: \"♌\",\n    virgo: \"♍\",\n    libra: \"♎\",\n    scorpio: \"♏\",\n    sagittarius: \"♐\",\n    capricorn: \"♑\",\n    aquarius: \"♒\",\n    pisces: \"♓\"\n};\n// Add a function to create a placeholder chart when the API fails\nfunction createPlaceholderChart(birthDate, birthTime, latitude, longitude) {\n    // Create a basic placeholder chart with minimal data\n    const [year, month, day] = birthDate.split(\"-\").map(Number);\n    const [hour, minute] = birthTime.split(\":\").map(Number);\n    // Generate some placeholder planets\n    const planets = [\n        {\n            name: \"sun\",\n            sign: \"aries\",\n            degree: 15,\n            house: 1,\n            retrograde: false\n        },\n        {\n            name: \"moon\",\n            sign: \"taurus\",\n            degree: 25,\n            house: 2,\n            retrograde: false\n        },\n        {\n            name: \"mercury\",\n            sign: \"gemini\",\n            degree: 5,\n            house: 3,\n            retrograde: false\n        },\n        {\n            name: \"venus\",\n            sign: \"cancer\",\n            degree: 10,\n            house: 4,\n            retrograde: false\n        },\n        {\n            name: \"mars\",\n            sign: \"leo\",\n            degree: 20,\n            house: 5,\n            retrograde: false\n        },\n        {\n            name: \"jupiter\",\n            sign: \"virgo\",\n            degree: 15,\n            house: 6,\n            retrograde: false\n        },\n        {\n            name: \"saturn\",\n            sign: \"libra\",\n            degree: 5,\n            house: 7,\n            retrograde: true\n        }\n    ];\n    // Generate placeholder houses\n    const houses = Array.from({\n        length: 12\n    }, (_, i)=>({\n            number: i + 1,\n            sign: Object.keys(zodiacSymbols)[i % 12],\n            degree: i * 30 % 360,\n            cusp: true\n        }));\n    // Generate placeholder angles\n    const angles = {\n        ascendant: {\n            sign: \"aries\",\n            degree: 0\n        },\n        midheaven: {\n            sign: \"capricorn\",\n            degree: 270\n        },\n        descendant: {\n            sign: \"libra\",\n            degree: 180\n        },\n        imumCoeli: {\n            sign: \"cancer\",\n            degree: 90\n        }\n    };\n    return {\n        planets,\n        houses,\n        angles,\n        aspects: [],\n        birthDetails: {\n            date: birthDate,\n            time: birthTime,\n            location: {\n                latitude,\n                longitude,\n                name: \"Location data unavailable\"\n            }\n        }\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NlcnZpY2VzL2FzdHJvbG9neS1zZXJ2aWNlLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBOzs7Q0FHQyxHQVMrQjtBQUVoQzs7Q0FFQyxHQUNNLGVBQWVBLGdCQUNwQlUsU0FBaUIsRUFDakJDLFNBQWlCLEVBQ2pCQyxRQUFnQixFQUNoQkMsU0FBaUI7SUFFakIsSUFBSTtRQUNGLGtEQUFrRDtRQUNsRCx5REFBeUQ7UUFDekQsTUFBTUMsV0FBV0MsS0FBS0MsS0FBSyxDQUFDSCxZQUFZO1FBRXhDLCtCQUErQjtRQUMvQixPQUFPLE1BQU1aLHVFQUFzQkEsQ0FBQ1MsV0FBV0MsV0FBV0MsVUFBVUMsV0FBV0M7SUFDakYsRUFBRSxPQUFPRyxPQUFPO1FBQ2RDLFFBQVFELEtBQUssQ0FBQywrQkFBK0JBO1FBQzdDLE1BQU1BO0lBQ1I7QUFDRjtBQUVBOztDQUVDLEdBQ00sZUFBZVQsd0JBQ3BCRSxTQUFpQixFQUNqQkMsU0FBaUIsRUFDakJDLFFBQWdCLEVBQ2hCQyxTQUFpQjtJQUVqQixJQUFJO1FBQ0Ysa0RBQWtEO1FBQ2xELE1BQU1DLFdBQVdDLEtBQUtDLEtBQUssQ0FBQ0gsWUFBWTtRQUV4QywrQkFBK0I7UUFDL0IsT0FBTyxNQUFNSiwrRUFBOEJBLENBQUNDLFdBQVdDLFdBQVdDLFVBQVVDLFdBQVdDO0lBQ3pGLEVBQUUsT0FBT0csT0FBTztRQUNkQyxRQUFRRCxLQUFLLENBQUMseUNBQXlDQTtRQUN2RCxNQUFNQTtJQUNSO0FBQ0Y7QUFFQSw4REFBOEQ7QUFFOUQ7O0NBRUMsR0FDTSxlQUFlZixnQkFDcEJpQixjQUFzQjtJQUV0QixJQUFJO1FBQ0YsK0NBQStDO1FBQy9DLDJDQUEyQztRQUMzQyxNQUFNQyxnQkFBZ0JDLG1CQUFtQkY7UUFDekMsSUFBSUMsZUFBZTtZQUNqQkYsUUFBUUksR0FBRyxDQUFDLCtCQUErQkg7WUFDM0MsT0FBT0M7UUFDVDtRQUVBLGdEQUFnRDtRQUNoREYsUUFBUUksR0FBRyxDQUFD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eEQsTUFBTTtZQUFROEIsTUFBTTtZQUFPd0IsUUFBUTtZQUFJQyxPQUFPO1lBQUdDLFlBQVk7UUFBTTtRQUNyRTtZQUFFeEQsTUFBTTtZQUFXOEIsTUFBTTtZQUFTd0IsUUFBUTtZQUFJQyxPQUFPO1lBQUdDLFlBQVk7UUFBTTtRQUMxRTtZQUFFeEQsTUFBTTtZQUFVOEIsTUFBTTtZQUFTd0IsUUFBUTtZQUFHQyxPQUFPO1lBQUdDLFlBQVk7UUFBSztLQUN4RTtJQUVELDhCQUE4QjtJQUM5QixNQUFNQyxTQUFTQyxNQUFNQyxJQUFJLENBQUM7UUFBRS9CLFFBQVE7SUFBRyxHQUFHLENBQUNnQyxHQUFHQyxJQUFPO1lBQ25EQyxRQUFRRCxJQUFJO1lBQ1ovQixNQUFNTCxPQUFPc0MsSUFBSSxDQUFDaEMsY0FBYyxDQUFDOEIsSUFBSSxHQUFHO1lBQ3hDUCxRQUFRLElBQUssS0FBTTtZQUNuQlUsTUFBTTtRQUNSO0lBRUEsOEJBQThCO0lBQzlCLE1BQU1DLFNBQVM7UUFDYkMsV0FBVztZQUFFcEMsTUFBTTtZQUFTd0IsUUFBUTtRQUFFO1FBQ3RDYSxXQUFXO1lBQUVyQyxNQUFNO1lBQWF3QixRQUFRO1FBQUk7UUFDNUNjLFlBQVk7WUFBRXRDLE1BQU07WUFBU3dCLFFBQVE7UUFBSTtRQUN6Q2UsV0FBVztZQUFFdkMsTUFBTTtZQUFVd0IsUUFBUTtRQUFHO0lBQzFDO0lBRUEsT0FBTztRQUNMRDtRQUNBSTtRQUNBUTtRQUNBSyxTQUFTLEVBQUU7UUFDWEMsY0FBYztZQUNaQyxNQUFNdkY7WUFDTndGLE1BQU12RjtZQUNOd0YsVUFBVTtnQkFDUnZGO2dCQUNBQztnQkFDQVksTUFBTTtZQUNSO1FBQ0Y7SUFDRjtBQUNGIiwic291cmNlcyI6WyIvVXNlcnMvbWFya29ub3Zha292c2tpL0RvY3VtZW50cy9WaXN1YWwgQ29kZS9Bc3Ryb0Jvb2svQXN0cm9Cb29rL3NlcnZpY2VzL2FzdHJvbG9neS1zZXJ2aWNlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQXN0cm9sb2d5IFNlcnZpY2VcbiAqIEhhbmRsZXMgYWxsIGludGVyYWN0aW9ucyB3aXRoIGFzdHJvbG9neSBBUElzIGFuZCBkYXRhIHByb2Nlc3NpbmdcbiAqL1xuXG5pbXBvcnQgdHlwZSB7IE5hdGFsQ2hhcnQsIENoYXJ0SW50ZXJwcmV0YXRpb24sIFpvZGlhY1NpZ24gfSBmcm9tIFwiQC90eXBlcy9hc3Ryb2xvZ3lcIlxuaW1wb3J0IHtcbiAgZmV0Y2hOYXRhbENoYXJ0IGFzIGZldGNoTmF0YWxDaGFydEZyb21BUEksXG4gIGdlb2NvZGVMb2NhdGlvbiBhcyBnZW9jb2RlTG9jYXRpb25Gcm9tQVBJLFxuICBnZXROYXRhbENoYXJ0SW50ZXJwcmV0YXRpb24gYXMgZ2V0SW50ZXJwcmV0YXRpb25Gcm9tQVBJLFxuICBnZXREYWlseUhvcm9zY29wZSBhcyBnZXREYWlseUhvcm9zY29wZUZyb21BUEksXG4gIGZldGNoTmF0YWxXaGVlbENoYXJ0U1ZHIGFzIGZldGNoTmF0YWxXaGVlbENoYXJ0U1ZHRnJvbUFQSSxcbn0gZnJvbSBcIi4vYXN0cm9sb2d5LWFwaS1zZXJ2aWNlXCJcblxuLyoqXG4gKiBGZXRjaGVzIG5hdGFsIGNoYXJ0IGRhdGFcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGZldGNoTmF0YWxDaGFydChcbiAgYmlydGhEYXRlOiBzdHJpbmcsXG4gIGJpcnRoVGltZTogc3RyaW5nLFxuICBsYXRpdHVkZTogbnVtYmVyLFxuICBsb25naXR1ZGU6IG51bWJlcixcbik6IFByb21pc2U8TmF0YWxDaGFydD4ge1xuICB0cnkge1xuICAgIC8vIENhbGN1bGF0ZSB0aW1lem9uZSBmcm9tIGxvbmdpdHVkZSAoYXBwcm94aW1hdGUpXG4gICAgLy8gSW4gYSByZWFsIGFwcCwgeW91IHdvdWxkIHVzZSBhIHRpbWV6b25lIEFQSSBvciBsaWJyYXJ5XG4gICAgY29uc3QgdGltZXpvbmUgPSBNYXRoLnJvdW5kKGxvbmdpdHVkZSAvIDE1KVxuXG4gICAgLy8gVXNlIHRoZSBBc3Ryb2xvZ3lBUEkgc2VydmljZVxuICAgIHJldHVybiBhd2FpdCBmZXRjaE5hdGFsQ2hhcnRGcm9tQVBJKGJpcnRoRGF0ZSwgYmlydGhUaW1lLCBsYXRpdHVkZSwgbG9uZ2l0dWRlLCB0aW1lem9uZSlcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgZmV0Y2hpbmcgbmF0YWwgY2hhcnQ6XCIsIGVycm9yKVxuICAgIHRocm93IGVycm9yXG4gIH1cbn1cblxuLyoqXG4gKiBGZXRjaGVzIG5hdGFsIHdoZWVsIGNoYXJ0IFNWR1xuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZmV0Y2hOYXRhbFdoZWVsQ2hhcnRTVkcoXG4gIGJpcnRoRGF0ZTogc3RyaW5nLFxuICBiaXJ0aFRpbWU6IHN0cmluZyxcbiAgbGF0aXR1ZGU6IG51bWJlcixcbiAgbG9uZ2l0dWRlOiBudW1iZXIsXG4pOiBQcm9taXNlPHN0cmluZz4ge1xuICB0cnkge1xuICAgIC8vIENhbGN1bGF0ZSB0aW1lem9uZSBmcm9tIGxvbmdpdHVkZSAoYXBwcm94aW1hdGUpXG4gICAgY29uc3QgdGltZXpvbmUgPSBNYXRoLnJvdW5kKGxvbmdpdHVkZSAvIDE1KVxuXG4gICAgLy8gVXNlIHRoZSBBc3Ryb2xvZ3lBUEkgc2VydmljZVxuICAgIHJldHVybiBhd2FpdCBmZXRjaE5hdGFsV2hlZWxDaGFydFNWR0Zyb21BUEkoYmlydGhEYXRlLCBiaXJ0aFRpbWUsIGxhdGl0dWRlLCBsb25naXR1ZGUsIHRpbWV6b25lKVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBmZXRjaGluZyBuYXRhbCB3aGVlbCBjaGFydCBTVkc6XCIsIGVycm9yKVxuICAgIHRocm93IGVycm9yXG4gIH1cbn1cblxuLy8gVXBkYXRlIHRoZSBnZW9jb2RlTG9jYXRpb24gZnVuY3Rpb24gdG8gaGFuZGxlIGVycm9ycyBiZXR0ZXJcblxuLyoqXG4gKiBHZW9jb2RlcyBhIGxvY2F0aW9uIHN0cmluZyB0byBnZXQgbGF0aXR1ZGUgYW5kIGxvbmdpdHVkZVxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2VvY29kZUxvY2F0aW9uKFxuICBsb2NhdGlvblN0cmluZzogc3RyaW5nLFxuKTogUHJvbWlzZTx7IGxhdGl0dWRlOiBudW1iZXI7IGxvbmdpdHVkZTogbnVtYmVyOyBuYW1lOiBzdHJpbmcgfT4ge1xuICB0cnkge1xuICAgIC8vIFRyeSB0byB1c2UgYSBzaW1wbGUgZ2VvY29kaW5nIGFwcHJvYWNoIGZpcnN0XG4gICAgLy8gVGhpcyBpcyBhIGZhbGxiYWNrIGluIGNhc2UgdGhlIEFQSSBmYWlsc1xuICAgIGNvbnN0IHNpbXBsZUdlb2NvZGUgPSBnZXRTaW1wbGVHZW9jb2RpbmcobG9jYXRpb25TdHJpbmcpXG4gICAgaWYgKHNpbXBsZUdlb2NvZGUpIHtcbiAgICAgIGNvbnNvbGUubG9nKFwiVXNpbmcgc2ltcGxlIGdlb2NvZGluZyBmb3I6XCIsIGxvY2F0aW9uU3RyaW5nKVxuICAgICAgcmV0dXJuIHNpbXBsZUdlb2NvZGVcbiAgICB9XG5cbiAgICAvLyBJZiBzaW1wbGUgZ2VvY29kaW5nIGRvZXNuJ3Qgd29yaywgdHJ5IHRoZSBBUElcbiAgICBjb25zb2xlLmxvZyhcIkF0dGVtcHRpbmcgQVBJIGdlb2NvZGluZyBmb3I6XCIsIGxvY2F0aW9uU3RyaW5nKVxuXG4gICAgLy8gVXNlIHRoZSBBc3Ryb2xvZ3lBUEkgZ2VvY29kaW5nIHNlcnZpY2VcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBnZW9jb2RlTG9jYXRpb25Gcm9tQVBJKGxvY2F0aW9uU3RyaW5nKVxuXG4gICAgLy8gVmFsaWRhdGUgdGhlIHJlc3VsdFxuICAgIGlmIChyZXN1bHQubGF0aXR1ZGUgPT09IDAgJiYgcmVzdWx0LmxvbmdpdHVkZSA9PT0gMCkge1xuICAgICAgY29uc29sZS5sb2coXCJBUEkgZ2VvY29kaW5nIHJldHVybmVkIGRlZmF1bHQgY29vcmRpbmF0ZXMsIHRyeWluZyBmYWxsYmFja1wiKVxuICAgICAgLy8gSWYgQVBJIHJldHVybmVkIGRlZmF1bHQgY29vcmRpbmF0ZXMsIHRyeSBvdXIgZmFsbGJhY2tcbiAgICAgIGNvbnN0IGZhbGxiYWNrID0gZ2V0U2ltcGxlR2VvY29kaW5nKGxvY2F0aW9uU3RyaW5nLCB0cnVlKVxuICAgICAgaWYgKGZhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiBmYWxsYmFja1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHRcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgaW4gZ2VvY29kaW5nIHNlcnZpY2U6XCIsIGVycm9yKVxuXG4gICAgLy8gUmV0dXJuIGZhbGxiYWNrIGRhdGEgaW5zdGVhZCBvZiB0aHJvd2luZ1xuICAgIHJldHVybiB7XG4gICAgICBsYXRpdHVkZTogMCxcbiAgICAgIGxvbmdpdHVkZTogMCxcbiAgICAgIG5hbWU6IGxvY2F0aW9uU3RyaW5nLFxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFNpbXBsZSBnZW9jb2RpbmcgZnVuY3Rpb24gZm9yIGNvbW1vbiBsb2NhdGlvbnNcbiAqIFRoaXMgc2VydmVzIGFzIGEgZmFsbGJhY2sgd2hlbiB0aGUgQVBJIGZhaWxzXG4gKi9cbmZ1bmN0aW9uIGdldFNpbXBsZUdlb2NvZGluZyhcbiAgbG9jYXRpb25TdHJpbmc6IHN0cmluZyxcbiAgZm9yY2VGYWxsYmFjayA9IGZhbHNlLFxuKTogeyBsYXRpdHVkZTogbnVtYmVyOyBsb25naXR1ZGU6IG51bWJlcjsgbmFtZTogc3RyaW5nIH0gfCBudWxsIHtcbiAgLy8gTm9ybWFsaXplIHRoZSBpbnB1dFxuICBjb25zdCBub3JtYWxpemVkSW5wdXQgPSBsb2NhdGlvblN0cmluZy50b0xvd2VyQ2FzZSgpLnRyaW0oKVxuXG4gIC8vIENvbW1vbiBjaXR5IGNvb3JkaW5hdGVzXG4gIGNvbnN0IGNpdHlDb29yZGluYXRlczogUmVjb3JkPHN0cmluZywgW251bWJlciwgbnVtYmVyXT4gPSB7XG4gICAgLy8gTm9ydGggQW1lcmljYVxuICAgIFwibmV3IHlvcmtcIjogWzQwLjcxMjgsIC03NC4wMDZdLFxuICAgIFwibG9zIGFuZ2VsZXNcIjogWzM0LjA1MjIsIC0xMTguMjQzN10sXG4gICAgY2hpY2FnbzogWzQxLjg3ODEsIC04Ny42Mjk4XSxcbiAgICB0b3JvbnRvOiBbNDMuNjUzMiwgLTc5LjM4MzJdLFxuICAgIFwibWV4aWNvIGNpdHlcIjogWzE5LjQzMjYsIC05OS4xMzMyXSxcblxuICAgIC8vIEV1cm9wZVxuICAgIGxvbmRvbjogWzUxLjUwNzQsIC0wLjEyNzhdLFxuICAgIHBhcmlzOiBbNDguODU2NiwgMi4zNTIyXSxcbiAgICBiZXJsaW46IFs1Mi41MiwgMTMuNDA1XSxcbiAgICBtYWRyaWQ6IFs0MC40MTY4LCAtMy43MDM4XSxcbiAgICByb21lOiBbNDEuOTAyOCwgMTIuNDk2NF0sXG4gICAgYW1zdGVyZGFtOiBbNTIuMzY3NiwgNC45MDQxXSxcbiAgICB2aWVubmE6IFs0OC4yMDgyLCAxNi4zNzM4XSxcbiAgICBoYW1idXJnOiBbNTMuNTUxMSwgOS45OTM3XSxcblxuICAgIC8vIEFzaWFcbiAgICB0b2t5bzogWzM1LjY3NjIsIDEzOS42NTAzXSxcbiAgICBiZWlqaW5nOiBbMzkuOTA0MiwgMTE2LjQwNzRdLFxuICAgIG11bWJhaTogWzE5LjA3NiwgNzIuODc3N10sXG4gICAgc2luZ2Fwb3JlOiBbMS4zNTIxLCAxMDMuODE5OF0sXG5cbiAgICAvLyBBdXN0cmFsaWFcbiAgICBzeWRuZXk6IFstMzMuODY4OCwgMTUxLjIwOTNdLFxuICAgIG1lbGJvdXJuZTogWy0zNy44MTM2LCAxNDQuOTYzMV0sXG5cbiAgICAvLyBTb3V0aCBBbWVyaWNhXG4gICAgXCJyaW8gZGUgamFuZWlyb1wiOiBbLTIyLjkwNjgsIC00My4xNzI5XSxcbiAgICBcImJ1ZW5vcyBhaXJlc1wiOiBbLTM0LjYwMzcsIC01OC4zODE2XSxcblxuICAgIC8vIEFmcmljYVxuICAgIGNhaXJvOiBbMzAuMDQ0NCwgMzEuMjM1N10sXG4gICAgXCJjYXBlIHRvd25cIjogWy0zMy45MjQ5LCAxOC40MjQxXSxcbiAgfVxuXG4gIC8vIENoZWNrIGZvciBleGFjdCBtYXRjaGVzXG4gIGZvciAoY29uc3QgW2NpdHksIGNvb3JkaW5hdGVzXSBvZiBPYmplY3QuZW50cmllcyhjaXR5Q29vcmRpbmF0ZXMpKSB7XG4gICAgaWYgKG5vcm1hbGl6ZWRJbnB1dC5pbmNsdWRlcyhjaXR5KSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbGF0aXR1ZGU6IGNvb3JkaW5hdGVzWzBdLFxuICAgICAgICBsb25naXR1ZGU6IGNvb3JkaW5hdGVzWzFdLFxuICAgICAgICBuYW1lOiBsb2NhdGlvblN0cmluZyxcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBJZiB3ZSdyZSBmb3JjaW5nIGEgZmFsbGJhY2sgb3IgdGhlIGlucHV0IGlzIHZlcnkgc2hvcnQsIHVzZSBhIGRlZmF1bHRcbiAgaWYgKGZvcmNlRmFsbGJhY2sgfHwgbm9ybWFsaXplZElucHV0Lmxlbmd0aCA8IDMpIHtcbiAgICAvLyBEZWZhdWx0IHRvIGEgY2VudHJhbCBsb2NhdGlvbiAoMCwwIGlzIGluIHRoZSBBdGxhbnRpYyBPY2VhbilcbiAgICByZXR1cm4ge1xuICAgICAgbGF0aXR1ZGU6IDAsXG4gICAgICBsb25naXR1ZGU6IDAsXG4gICAgICBuYW1lOiBsb2NhdGlvblN0cmluZyxcbiAgICB9XG4gIH1cblxuICAvLyBObyBtYXRjaCBmb3VuZFxuICByZXR1cm4gbnVsbFxufVxuXG4vKipcbiAqIEdldHMgaW50ZXJwcmV0YXRpb25zIGZvciBhIG5hdGFsIGNoYXJ0XG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXROYXRhbENoYXJ0SW50ZXJwcmV0YXRpb24obmF0YWxDaGFydDogTmF0YWxDaGFydCk6IFByb21pc2U8Q2hhcnRJbnRlcnByZXRhdGlvbj4ge1xuICB0cnkge1xuICAgIC8vIFVzZSB0aGUgQXN0cm9sb2d5QVBJIGludGVycHJldGF0aW9uIHNlcnZpY2VcbiAgICByZXR1cm4gYXdhaXQgZ2V0SW50ZXJwcmV0YXRpb25Gcm9tQVBJKG5hdGFsQ2hhcnQpXG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihcIkVycm9yIGdldHRpbmcgY2hhcnQgaW50ZXJwcmV0YXRpb246XCIsIGVycm9yKVxuICAgIHRocm93IGVycm9yXG4gIH1cbn1cblxuLyoqXG4gKiBHZXRzIGEgZGFpbHkgaG9yb3Njb3BlIGZvciBhIHpvZGlhYyBzaWduXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXREYWlseUhvcm9zY29wZShzaWduOiBab2RpYWNTaWduKTogUHJvbWlzZTxhbnk+IHtcbiAgdHJ5IHtcbiAgICAvLyBVc2UgdGhlIEFzdHJvbG9neUFQSSBob3Jvc2NvcGUgc2VydmljZVxuICAgIHJldHVybiBhd2FpdCBnZXREYWlseUhvcm9zY29wZUZyb21BUEkoc2lnbilcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgZ2V0dGluZyBkYWlseSBob3Jvc2NvcGU6XCIsIGVycm9yKVxuICAgIHRocm93IGVycm9yXG4gIH1cbn1cblxuLy8gRGVmaW5lIHpvZGlhY1N5bWJvbHNcbmNvbnN0IHpvZGlhY1N5bWJvbHM6IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH0gPSB7XG4gIGFyaWVzOiBcIuKZiFwiLFxuICB0YXVydXM6IFwi4pmJXCIsXG4gIGdlbWluaTogXCLimYpcIixcbiAgY2FuY2VyOiBcIuKZi1wiLFxuICBsZW86IFwi4pmMXCIsXG4gIHZpcmdvOiBcIuKZjVwiLFxuICBsaWJyYTogXCLimY5cIixcbiAgc2NvcnBpbzogXCLimY9cIixcbiAgc2FnaXR0YXJpdXM6IFwi4pmQXCIsXG4gIGNhcHJpY29ybjogXCLimZFcIixcbiAgYXF1YXJpdXM6IFwi4pmSXCIsXG4gIHBpc2NlczogXCLimZNcIixcbn1cblxuLy8gRGVmaW5lIHRoZSBQbGFuZXRQb3NpdGlvbiB0eXBlXG5pbnRlcmZhY2UgUGxhbmV0UG9zaXRpb24ge1xuICBuYW1lOiBzdHJpbmdcbiAgc2lnbjogc3RyaW5nXG4gIGRlZ3JlZTogbnVtYmVyXG4gIGhvdXNlOiBudW1iZXJcbiAgcmV0cm9ncmFkZTogYm9vbGVhblxufVxuXG4vLyBBZGQgYSBmdW5jdGlvbiB0byBjcmVhdGUgYSBwbGFjZWhvbGRlciBjaGFydCB3aGVuIHRoZSBBUEkgZmFpbHNcbmZ1bmN0aW9uIGNyZWF0ZVBsYWNlaG9sZGVyQ2hhcnQoYmlydGhEYXRlOiBzdHJpbmcsIGJpcnRoVGltZTogc3RyaW5nLCBsYXRpdHVkZTogbnVtYmVyLCBsb25naXR1ZGU6IG51bWJlcik6IE5hdGFsQ2hhcnQge1xuICAvLyBDcmVhdGUgYSBiYXNpYyBwbGFjZWhvbGRlciBjaGFydCB3aXRoIG1pbmltYWwgZGF0YVxuICBjb25zdCBbeWVhciwgbW9udGgsIGRheV0gPSBiaXJ0aERhdGUuc3BsaXQoXCItXCIpLm1hcChOdW1iZXIpXG4gIGNvbnN0IFtob3VyLCBtaW51dGVdID0gYmlydGhUaW1lLnNwbGl0KFwiOlwiKS5tYXAoTnVtYmVyKVxuXG4gIC8vIEdlbmVyYXRlIHNvbWUgcGxhY2Vob2xkZXIgcGxhbmV0c1xuICBjb25zdCBwbGFuZXRzOiBQbGFuZXRQb3NpdGlvbltdID0gW1xuICAgIHsgbmFtZTogXCJzdW5cIiwgc2lnbjogXCJhcmllc1wiLCBkZWdyZWU6IDE1LCBob3VzZTogMSwgcmV0cm9ncmFkZTogZmFsc2UgfSxcbiAgICB7IG5hbWU6IFwibW9vblwiLCBzaWduOiBcInRhdXJ1c1wiLCBkZWdyZWU6IDI1LCBob3VzZTogMiwgcmV0cm9ncmFkZTogZmFsc2UgfSxcbiAgICB7IG5hbWU6IFwibWVyY3VyeVwiLCBzaWduOiBcImdlbWluaVwiLCBkZWdyZWU6IDUsIGhvdXNlOiAzLCByZXRyb2dyYWRlOiBmYWxzZSB9LFxuICAgIHsgbmFtZTogXCJ2ZW51c1wiLCBzaWduOiBcImNhbmNlclwiLCBkZWdyZWU6IDEwLCBob3VzZTogNCwgcmV0cm9ncmFkZTogZmFsc2UgfSxcbiAgICB7IG5hbWU6IFwibWFyc1wiLCBzaWduOiBcImxlb1wiLCBkZWdyZWU6IDIwLCBob3VzZTogNSwgcmV0cm9ncmFkZTogZmFsc2UgfSxcbiAgICB7IG5hbWU6IFwianVwaXRlclwiLCBzaWduOiBcInZpcmdvXCIsIGRlZ3JlZTogMTUsIGhvdXNlOiA2LCByZXRyb2dyYWRlOiBmYWxzZSB9LFxuICAgIHsgbmFtZTogXCJzYXR1cm5cIiwgc2lnbjogXCJsaWJyYVwiLCBkZWdyZWU6IDUsIGhvdXNlOiA3LCByZXRyb2dyYWRlOiB0cnVlIH0sXG4gIF1cblxuICAvLyBHZW5lcmF0ZSBwbGFjZWhvbGRlciBob3VzZXNcbiAgY29uc3QgaG91c2VzID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogMTIgfSwgKF8sIGkpID0+ICh7XG4gICAgbnVtYmVyOiBpICsgMSxcbiAgICBzaWduOiBPYmplY3Qua2V5cyh6b2RpYWNTeW1ib2xzKVtpICUgMTJdIGFzIFpvZGlhY1NpZ24sXG4gICAgZGVncmVlOiAoaSAqIDMwKSAlIDM2MCxcbiAgICBjdXNwOiB0cnVlLFxuICB9KSlcblxuICAvLyBHZW5lcmF0ZSBwbGFjZWhvbGRlciBhbmdsZXNcbiAgY29uc3QgYW5nbGVzID0ge1xuICAgIGFzY2VuZGFudDogeyBzaWduOiBcImFyaWVzXCIsIGRlZ3JlZTogMCB9LFxuICAgIG1pZGhlYXZlbjogeyBzaWduOiBcImNhcHJpY29yblwiLCBkZWdyZWU6IDI3MCB9LFxuICAgIGRlc2NlbmRhbnQ6IHsgc2lnbjogXCJsaWJyYVwiLCBkZWdyZWU6IDE4MCB9LFxuICAgIGltdW1Db2VsaTogeyBzaWduOiBcImNhbmNlclwiLCBkZWdyZWU6IDkwIH0sXG4gIH1cblxuICByZXR1cm4ge1xuICAgIHBsYW5ldHMsXG4gICAgaG91c2VzLFxuICAgIGFuZ2xlcyxcbiAgICBhc3BlY3RzOiBbXSxcbiAgICBiaXJ0aERldGFpbHM6IHtcbiAgICAgIGRhdGU6IGJpcnRoRGF0ZSxcbiAgICAgIHRpbWU6IGJpcnRoVGltZSxcbiAgICAgIGxvY2F0aW9uOiB7XG4gICAgICAgIGxhdGl0dWRlLFxuICAgICAgICBsb25naXR1ZGUsXG4gICAgICAgIG5hbWU6IFwiTG9jYXRpb24gZGF0YSB1bmF2YWlsYWJsZVwiLFxuICAgICAgfSxcbiAgICB9LFxuICB9XG59XG5cbiJdLCJuYW1lcyI6WyJmZXRjaE5hdGFsQ2hhcnQiLCJmZXRjaE5hdGFsQ2hhcnRGcm9tQVBJIiwiZ2VvY29kZUxvY2F0aW9uIiwiZ2VvY29kZUxvY2F0aW9uRnJvbUFQSSIsImdldE5hdGFsQ2hhcnRJbnRlcnByZXRhdGlvbiIsImdldEludGVycHJldGF0aW9uRnJvbUFQSSIsImdldERhaWx5SG9yb3Njb3BlIiwiZ2V0RGFpbHlIb3Jvc2NvcGVGcm9tQVBJIiwiZmV0Y2hOYXRhbFdoZWVsQ2hhcnRTVkciLCJmZXRjaE5hdGFsV2hlZWxDaGFydFNWR0Zyb21BUEkiLCJiaXJ0aERhdGUiLCJiaXJ0aFRpbWUiLCJsYXRpdHVkZSIsImxvbmdpdHVkZSIsInRpbWV6b25lIiwiTWF0aCIsInJvdW5kIiwiZXJyb3IiLCJjb25zb2xlIiwibG9jYXRpb25TdHJpbmciLCJzaW1wbGVHZW9jb2RlIiwiZ2V0U2ltcGxlR2VvY29kaW5nIiwibG9nIiwicmVzdWx0IiwiZmFsbGJhY2siLCJuYW1lIiwiZm9yY2VGYWxsYmFjayIsIm5vcm1hbGl6ZWRJbnB1dCIsInRvTG93ZXJDYXNlIiwidHJpbSIsImNpdHlDb29yZGluYXRlcyIsImNoaWNhZ28iLCJ0b3JvbnRvIiwibG9uZG9uIiwicGFyaXMiLCJiZXJsaW4iLCJtYWRyaWQiLCJyb21lIiwiYW1zdGVyZGFtIiwidmllbm5hIiwiaGFtYnVyZyIsInRva3lvIiwiYmVpamluZyIsIm11bWJhaSIsInNpbmdhcG9yZSIsInN5ZG5leSIsIm1lbGJvdXJuZSIsImNhaXJvIiwiY2l0eSIsImNvb3JkaW5hdGVzIiwiT2JqZWN0IiwiZW50cmllcyIsImluY2x1ZGVzIiwibGVuZ3RoIiwibmF0YWxDaGFydCIsInNpZ24iLCJ6b2RpYWNTeW1ib2xzIiwiYXJpZXMiLCJ0YXVydXMiLCJnZW1pbmkiLCJjYW5jZXIiLCJsZW8iLCJ2aXJnbyIsImxpYnJhIiwic2NvcnBpbyIsInNhZ2l0dGFyaXVzIiwiY2Fwcmljb3JuIiwiYXF1YXJpdXMiLCJwaXNjZXMiLCJjcmVhdGVQbGFjZWhvbGRlckNoYXJ0IiwieWVhciIsIm1vbnRoIiwiZGF5Iiwic3BsaXQiLCJtYXAiLCJOdW1iZXIiLCJob3VyIiwibWludXRlIiwicGxhbmV0cyIsImRlZ3JlZSIsImhvdXNlIiwicmV0cm9ncmFkZSIsImhvdXNlcyIsIkFycmF5IiwiZnJvbSIsIl8iLCJpIiwibnVtYmVyIiwia2V5cyIsImN1c3AiLCJhbmdsZXMiLCJhc2NlbmRhbnQiLCJtaWRoZWF2ZW4iLCJkZXNjZW5kYW50IiwiaW11bUNvZWxpIiwiYXNwZWN0cyIsImJpcnRoRGV0YWlscyIsImRhdGUiLCJ0aW1lIiwibG9jYXRpb24iXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./services/astrology-service.ts\n"));

/***/ })

}]);