/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["app/pricing/layout"],{

/***/ "(app-pages-browser)/./contexts/quiz-context.tsx":
/*!***********************************!*\
  !*** ./contexts/quiz-context.tsx ***!
  \***********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   QuizProvider: () => (/* binding */ QuizProvider),\n/* harmony export */   useQuiz: () => (/* binding */ useQuiz)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.2.4_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.2.4_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _utils_storage__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/utils/storage */ \"(app-pages-browser)/./utils/storage.ts\");\n/* __next_internal_client_entry_do_not_use__ QuizProvider,useQuiz auto */ \nvar _s = $RefreshSig$(), _s1 = $RefreshSig$();\n\n\nconst initialState = {\n    currentStep: 1,\n    totalSteps: 35,\n    gender: null,\n    astrologyLevel: null,\n    firstName: null,\n    lastName: null,\n    birthPlace: null,\n    birthTime: null,\n    birthDate: {\n        month: null,\n        day: null,\n        year: null\n    },\n    birthLocation: {\n        latitude: null,\n        longitude: null,\n        name: null\n    },\n    coverColorScheme: \"cream\",\n    email: null,\n    answers: {},\n    quizCompleted: false,\n    natalChart: null,\n    chartInterpretation: null,\n    isLoadingChart: false,\n    chartError: null\n};\nconst QuizContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(undefined);\nfunction QuizProvider(param) {\n    let { children } = param;\n    _s();\n    // Initialize state from storage or use default\n    const [state, setState] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({\n        \"QuizProvider.useState\": ()=>{\n            // This will only run on the client side\n            if (true) {\n                const savedData = (0,_utils_storage__WEBPACK_IMPORTED_MODULE_2__.getQuizData)();\n                const quizCompleted = (0,_utils_storage__WEBPACK_IMPORTED_MODULE_2__.isQuizCompleted)();\n                if (savedData) {\n                    return {\n                        ...savedData,\n                        quizCompleted\n                    };\n                }\n            }\n            return initialState;\n        }\n    }[\"QuizProvider.useState\"]);\n    // Save state to storage whenever it changes\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"QuizProvider.useEffect\": ()=>{\n            // Save state on every change, not just when completed\n            (0,_utils_storage__WEBPACK_IMPORTED_MODULE_2__.saveQuizData)(state);\n        }\n    }[\"QuizProvider.useEffect\"], [\n        state\n    ]);\n    const setCurrentStep = (step)=>{\n        setState((prev)=>({\n                ...prev,\n                currentStep: step\n            }));\n    };\n    const nextStep = ()=>{\n        setState((prev)=>({\n                ...prev,\n                currentStep: prev.currentStep + 1\n            }));\n    };\n    const prevStep = ()=>{\n        if (state.currentStep > 1) {\n            setState((prev)=>({\n                    ...prev,\n                    currentStep: prev.currentStep - 1\n                }));\n        }\n    };\n    const updateAnswer = (questionId, answer)=>{\n        setState((prev)=>({\n                ...prev,\n                answers: {\n                    ...prev.answers,\n                    [questionId]: answer\n                }\n            }));\n    };\n    const setGender = (gender)=>{\n        setState((prev)=>({\n                ...prev,\n                gender\n            }));\n    };\n    const setAstrologyLevel = (level)=>{\n        setState((prev)=>({\n                ...prev,\n                astrologyLevel: level\n            }));\n    };\n    const setBirthDate = (field, value)=>{\n        setState((prev)=>({\n                ...prev,\n                birthDate: {\n                    ...prev.birthDate,\n                    [field]: value\n                }\n            }));\n    };\n    const setFirstName = (firstName)=>{\n        setState((prev)=>({\n                ...prev,\n                firstName\n            }));\n    };\n    const setLastName = (lastName)=>{\n        setState((prev)=>({\n                ...prev,\n                lastName\n            }));\n    };\n    const setBirthPlace = (birthPlace)=>{\n        setState((prev)=>({\n                ...prev,\n                birthPlace\n            }));\n    };\n    const setBirthTime = (birthTime)=>{\n        setState((prev)=>({\n                ...prev,\n                birthTime\n            }));\n    };\n    const setBirthLocation = (latitude, longitude, name)=>{\n        setState((prev)=>({\n                ...prev,\n                birthLocation: {\n                    latitude,\n                    longitude,\n                    name\n                }\n            }));\n    };\n    const setCoverColorScheme = (coverColorScheme)=>{\n        setState((prev)=>({\n                ...prev,\n                coverColorScheme\n            }));\n    };\n    const setEmail = (email)=>{\n        setState((prev)=>({\n                ...prev,\n                email\n            }));\n    };\n    /**\n   * Mark the quiz as completed.\n   * This function must be explicitly called when the quiz is actually complete.\n   * The quizCompleted flag determines whether to show the results page.\n   */ const completeQuiz = ()=>{\n        setState((prev)=>{\n            const newState = {\n                ...prev,\n                quizCompleted: true\n            };\n            // Save to storage immediately on completion\n            (0,_utils_storage__WEBPACK_IMPORTED_MODULE_2__.saveQuizData)(newState);\n            return newState;\n        });\n    };\n    const resetQuiz = ()=>{\n        // Clear all storage first\n        if (true) {\n            // First clear our own storage\n            (0,_utils_storage__WEBPACK_IMPORTED_MODULE_2__.clearQuizData)();\n            // For a more aggressive approach, clear all local storage completely\n            try {\n                localStorage.clear();\n                sessionStorage.clear();\n                console.log(\"Complete storage wipe performed\");\n            } catch (e) {\n                console.error(\"Error during complete storage wipe:\", e);\n            }\n        }\n        // Reset the state\n        setState(initialState);\n        // Force reload the page to ensure a completely fresh state\n        if (true) {\n            window.location.href = \"/\";\n        }\n    };\n    const setNatalChart = (natalChart)=>{\n        setState((prev)=>({\n                ...prev,\n                natalChart\n            }));\n    };\n    const setChartInterpretation = (chartInterpretation)=>{\n        setState((prev)=>({\n                ...prev,\n                chartInterpretation\n            }));\n    };\n    // Function to fetch natal chart data from the API\n    const fetchNatalChart = async ()=>{\n        // Import the service dynamically to avoid server-side issues\n        const { fetchNatalChart, geocodeLocation, getNatalChartInterpretation } = await __webpack_require__.e(/*! import() */ \"_app-pages-browser_services_astrology-service_ts\").then(__webpack_require__.bind(__webpack_require__, /*! @/services/astrology-service */ \"(app-pages-browser)/./services/astrology-service.ts\"));\n        setState((prev)=>({\n                ...prev,\n                isLoadingChart: true,\n                chartError: null\n            }));\n        try {\n            // Check if we have all required data\n            if (!state.birthDate.year || !state.birthDate.month || !state.birthDate.day) {\n                throw new Error(\"Birth date is required\");\n            }\n            if (!state.birthTime) {\n                throw new Error(\"Birth time is required for accurate chart calculation\");\n            }\n            if (!state.birthPlace) {\n                throw new Error(\"Birth place is required\");\n            }\n            // Format date for API\n            const formattedDate = \"\".concat(state.birthDate.year, \"-\").concat(state.birthDate.month.padStart(2, \"0\"), \"-\").concat(state.birthDate.day.padStart(2, \"0\"));\n            // Get coordinates if we don't have them yet\n            let latitude, longitude, locationName;\n            if (!state.birthLocation.latitude || !state.birthLocation.longitude) {\n                try {\n                    const geoData = await geocodeLocation(state.birthPlace);\n                    latitude = geoData.latitude;\n                    longitude = geoData.longitude;\n                    locationName = geoData.name;\n                    // Save the location data\n                    setBirthLocation(latitude, longitude, locationName);\n                } catch (error) {\n                    console.error(\"Error geocoding location:\", error);\n                    // Use default coordinates (0,0) if geocoding fails\n                    latitude = 0;\n                    longitude = 0;\n                    locationName = state.birthPlace;\n                    // Save the default location data\n                    setBirthLocation(latitude, longitude, locationName);\n                }\n            } else {\n                latitude = state.birthLocation.latitude;\n                longitude = state.birthLocation.longitude;\n                locationName = state.birthLocation.name || state.birthPlace;\n            }\n            // Fetch the natal chart using the new AstrologyAPI service\n            const natalChart = await fetchNatalChart(formattedDate, state.birthTime, latitude, longitude);\n            // Save the natal chart\n            setNatalChart(natalChart);\n            try {\n                // Get interpretations\n                const interpretation = await getNatalChartInterpretation(natalChart);\n                setChartInterpretation(interpretation);\n            } catch (error) {\n                console.error(\"Error getting chart interpretation:\", error);\n            // Continue even if interpretation fails\n            }\n            setState((prev)=>({\n                    ...prev,\n                    isLoadingChart: false\n                }));\n        } catch (error) {\n            console.error(\"Error fetching natal chart:\", error);\n            setState((prev)=>({\n                    ...prev,\n                    isLoadingChart: false,\n                    chartError: error instanceof Error ? error.message : \"Failed to generate natal chart\"\n                }));\n        }\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(QuizContext.Provider, {\n        value: {\n            state,\n            setCurrentStep,\n            nextStep,\n            prevStep,\n            updateAnswer,\n            setGender,\n            setAstrologyLevel,\n            setBirthDate,\n            setFirstName,\n            setLastName,\n            setBirthPlace,\n            setBirthTime,\n            setBirthLocation,\n            setCoverColorScheme,\n            setEmail,\n            completeQuiz,\n            resetQuiz,\n            fetchNatalChart,\n            setNatalChart,\n            setChartInterpretation\n        },\n        children: children\n    }, void 0, false, {\n        fileName: \"/Users/markonovakovski/Documents/Visual Code/AstroBook/AstroBook/contexts/quiz-context.tsx\",\n        lineNumber: 310,\n        columnNumber: 5\n    }, this);\n}\n_s(QuizProvider, \"2fHmwTnOH+PVF+HWa+U74hC58+U=\");\n_c = QuizProvider;\nfunction useQuiz() {\n    _s1();\n    const context = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(QuizContext);\n    if (context === undefined) {\n        throw new Error(\"useQuiz must be used within a QuizProvider\");\n    }\n    return context;\n}\n_s1(useQuiz, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\nvar _c;\n$RefreshReg$(_c, \"QuizProvider\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2NvbnRleHRzL3F1aXotY29udGV4dC50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFFc0Y7QUFDSztBQTJEM0YsTUFBTVEsZUFBMEI7SUFDOUJDLGFBQWE7SUFDYkMsWUFBWTtJQUNaQyxRQUFRO0lBQ1JDLGdCQUFnQjtJQUNoQkMsV0FBVztJQUNYQyxVQUFVO0lBQ1ZDLFlBQVk7SUFDWkMsV0FBVztJQUNYQyxXQUFXO1FBQ1RDLE9BQU87UUFDUEMsS0FBSztRQUNMQyxNQUFNO0lBQ1I7SUFDQUMsZUFBZTtRQUNiQyxVQUFVO1FBQ1ZDLFdBQVc7UUFDWEMsTUFBTTtJQUNSO0lBQ0FDLGtCQUFrQjtJQUNsQkMsT0FBTztJQUNQQyxTQUFTLENBQUM7SUFDVkMsZUFBZTtJQUNmQyxZQUFZO0lBQ1pDLHFCQUFxQjtJQUNyQkMsZ0JBQWdCO0lBQ2hCQyxZQUFZO0FBQ2Q7QUFFQSxNQUFNQyw0QkFBY2pDLG9EQUFhQSxDQUE4QmtDO0FBRXhELFNBQVNDLGFBQWEsS0FBcUM7UUFBckMsRUFBRUMsUUFBUSxFQUEyQixHQUFyQzs7SUFDM0IsK0NBQStDO0lBQy9DLE1BQU0sQ0FBQ0MsT0FBT0MsU0FBUyxHQUFHcEMsK0NBQVFBO2lDQUFZO1lBQzVDLHdDQUF3QztZQUN4QyxJQUFJLElBQTZCLEVBQUU7Z0JBQ2pDLE1BQU1xQyxZQUFZbEMsMkRBQVdBO2dCQUM3QixNQUFNdUIsZ0JBQWdCdEIsK0RBQWVBO2dCQUVyQyxJQUFJaUMsV0FBVztvQkFDYixPQUFPO3dCQUFFLEdBQUdBLFNBQVM7d0JBQUVYO29CQUFjO2dCQUN2QztZQUNGO1lBQ0EsT0FBT3BCO1FBQ1Q7O0lBRUEsNENBQTRDO0lBQzVDTCxnREFBU0E7a0NBQUM7WUFDUixzREFBc0Q7WUFDdERDLDREQUFZQSxDQUFDaUM7UUFDZjtpQ0FBRztRQUFDQTtLQUFNO0lBRVYsTUFBTUcsaUJBQWlCLENBQUNDO1FBQ3RCSCxTQUFTLENBQUNJLE9BQVU7Z0JBQUUsR0FBR0EsSUFB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Q0FBQ0ksT0FBVTtvQkFBRSxHQUFHQSxJQUFJO29CQUFFWCxnQkFBZ0I7Z0JBQU07UUFDdkQsRUFBRSxPQUFPdUMsT0FBTztZQUNkSCxRQUFRRyxLQUFLLENBQUMsK0JBQStCQTtZQUM3Q2hDLFNBQVMsQ0FBQ0ksT0FBVTtvQkFDbEIsR0FBR0EsSUFBSTtvQkFDUFgsZ0JBQWdCO29CQUNoQkMsWUFBWXNDLGlCQUFpQlMsUUFBUVQsTUFBTWUsT0FBTyxHQUFHO2dCQUN2RDtRQUNGO0lBQ0Y7SUFFQSxxQkFDRSw4REFBQ3BELFlBQVlxRCxRQUFRO1FBQ25CakMsT0FBTztZQUNMaEI7WUFDQUc7WUFDQUc7WUFDQUM7WUFDQUM7WUFDQUc7WUFDQUM7WUFDQUU7WUFDQUc7WUFDQUM7WUFDQUM7WUFDQUM7WUFDQUM7WUFDQUM7WUFDQUM7WUFDQUM7WUFDQUU7WUFDQWE7WUFDQUY7WUFDQUM7UUFDRjtrQkFFQ3ZDOzs7Ozs7QUFHUDtHQW5QZ0JEO0tBQUFBO0FBcVBULFNBQVNvRDs7SUFDZCxNQUFNQyxVQUFVdkYsaURBQVVBLENBQUNnQztJQUMzQixJQUFJdUQsWUFBWXRELFdBQVc7UUFDekIsTUFBTSxJQUFJNkMsTUFBTTtJQUNsQjtJQUNBLE9BQU9TO0FBQ1Q7SUFOZ0JEIiwic291cmNlcyI6WyIvVXNlcnMvbWFya29ub3Zha292c2tpL0RvY3VtZW50cy9WaXN1YWwgQ29kZS9Bc3Ryb0Jvb2svQXN0cm9Cb29rL2NvbnRleHRzL3F1aXotY29udGV4dC50c3giXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2UgY2xpZW50XCJcblxuaW1wb3J0IHsgY3JlYXRlQ29udGV4dCwgdXNlQ29udGV4dCwgdXNlU3RhdGUsIHVzZUVmZmVjdCwgdHlwZSBSZWFjdE5vZGUgfSBmcm9tIFwicmVhY3RcIlxuaW1wb3J0IHsgc2F2ZVF1aXpEYXRhLCBnZXRRdWl6RGF0YSwgaXNRdWl6Q29tcGxldGVkLCBjbGVhclF1aXpEYXRhIH0gZnJvbSBcIkAvdXRpbHMvc3RvcmFnZVwiXG5pbXBvcnQgdHlwZSB7IE5hdGFsQ2hhcnQsIENoYXJ0SW50ZXJwcmV0YXRpb24gfSBmcm9tIFwiQC90eXBlcy9hc3Ryb2xvZ3lcIlxuXG50eXBlIEdlbmRlciA9IFwibWFsZVwiIHwgXCJmZW1hbGVcIiB8IFwibm9uLWJpbmFyeVwiIHwgbnVsbFxudHlwZSBBc3Ryb2xvZ3lMZXZlbCA9IFwiYmVnaW5uZXJcIiB8IFwiaW50ZXJtZWRpYXRlXCIgfCBcImV4cGVydFwiIHwgbnVsbFxuZXhwb3J0IHR5cGUgQ29sb3JTY2hlbWUgPSBcImJsYWNrXCIgfCBcIm5hdnlcIiB8IFwicHVycGxlXCIgfCBcImdyZWVuXCIgfCBcImJ1cmd1bmR5XCIgfCBcImNyZWFtXCJcblxuZXhwb3J0IGludGVyZmFjZSBRdWl6U3RhdGUge1xuICBjdXJyZW50U3RlcDogbnVtYmVyXG4gIHRvdGFsU3RlcHM6IG51bWJlclxuICBnZW5kZXI6IEdlbmRlclxuICBhc3Ryb2xvZ3lMZXZlbDogQXN0cm9sb2d5TGV2ZWxcbiAgZmlyc3ROYW1lOiBzdHJpbmcgfCBudWxsXG4gIGxhc3ROYW1lOiBzdHJpbmcgfCBudWxsXG4gIGJpcnRoUGxhY2U6IHN0cmluZyB8IG51bGxcbiAgYmlydGhUaW1lOiBzdHJpbmcgfCBudWxsXG4gIGJpcnRoRGF0ZToge1xuICAgIG1vbnRoOiBzdHJpbmcgfCBudWxsXG4gICAgZGF5OiBzdHJpbmcgfCBudWxsXG4gICAgeWVhcjogc3RyaW5nIHwgbnVsbFxuICB9XG4gIGJpcnRoTG9jYXRpb246IHtcbiAgICBsYXRpdHVkZTogbnVtYmVyIHwgbnVsbFxuICAgIGxvbmdpdHVkZTogbnVtYmVyIHwgbnVsbFxuICAgIG5hbWU6IHN0cmluZyB8IG51bGxcbiAgfVxuICBjb3ZlckNvbG9yU2NoZW1lOiBDb2xvclNjaGVtZVxuICBlbWFpbDogc3RyaW5nIHwgbnVsbFxuICBhbnN3ZXJzOiBSZWNvcmQ8c3RyaW5nLCBhbnk+XG4gIHF1aXpDb21wbGV0ZWQ6IGJvb2xlYW5cbiAgbmF0YWxDaGFydDogTmF0YWxDaGFydCB8IG51bGxcbiAgY2hhcnRJbnRlcnByZXRhdGlvbjogQ2hhcnRJbnRlcnByZXRhdGlvbiB8IG51bGxcbiAgaXNMb2FkaW5nQ2hhcnQ6IGJvb2xlYW5cbiAgY2hhcnRFcnJvcjogc3RyaW5nIHwgbnVsbFxufVxuXG5pbnRlcmZhY2UgUXVpekNvbnRleHRUeXBlIHtcbiAgc3RhdGU6IFF1aXpTdGF0ZVxuICBzZXRDdXJyZW50U3RlcDogKHN0ZXA6IG51bWJlcikgPT4gdm9pZFxuICBuZXh0U3RlcDogKCkgPT4gdm9pZFxuICBwcmV2U3RlcDogKCkgPT4gdm9pZFxuICB1cGRhdGVBbnN3ZXI6IChxdWVzdGlvbklkOiBzdHJpbmcsIGFuc3dlcjogYW55KSA9PiB2b2lkXG4gIHNldEdlbmRlcjogKGdlbmRlcjogR2VuZGVyKSA9PiB2b2lkXG4gIHNldEFzdHJvbG9neUxldmVsOiAobGV2ZWw6IEFzdHJvbG9neUxldmVsKSA9PiB2b2lkXG4gIHNldEJpcnRoRGF0ZTogKGZpZWxkOiBcIm1vbnRoXCIgfCBcImRheVwiIHwgXCJ5ZWFyXCIsIHZhbHVlOiBzdHJpbmcpID0+IHZvaWRcbiAgc2V0Rmlyc3ROYW1lOiAobmFtZTogc3RyaW5nKSA9PiB2b2lkXG4gIHNldExhc3ROYW1lOiAobmFtZTogc3RyaW5nKSA9PiB2b2lkXG4gIHNldEJpcnRoUGxhY2U6IChwbGFjZTogc3RyaW5nKSA9PiB2b2lkXG4gIHNldEJpcnRoVGltZTogKHRpbWU6IHN0cmluZykgPT4gdm9pZFxuICBzZXRCaXJ0aExvY2F0aW9uOiAobGF0aXR1ZGU6IG51bWJlciwgbG9uZ2l0dWRlOiBudW1iZXIsIG5hbWU6IHN0cmluZykgPT4gdm9pZFxuICBzZXRDb3ZlckNvbG9yU2NoZW1lOiAoc2NoZW1lOiBDb2xvclNjaGVtZSkgPT4gdm9pZFxuICBzZXRFbWFpbDogKGVtYWlsOiBzdHJpbmcpID0+IHZvaWRcbiAgY29tcGxldGVRdWl6OiAoKSA9PiB2b2lkXG4gIHJlc2V0UXVpejogKCkgPT4gdm9pZFxuICBmZXRjaE5hdGFsQ2hhcnQ6ICgpID0+IFByb21pc2U8dm9pZD5cbiAgc2V0TmF0YWxDaGFydDogKGNoYXJ0OiBOYXRhbENoYXJ0KSA9PiB2b2lkXG4gIHNldENoYXJ0SW50ZXJwcmV0YXRpb246IChpbnRlcnByZXRhdGlvbjogQ2hhcnRJbnRlcnByZXRhdGlvbikgPT4gdm9pZFxufVxuXG5jb25zdCBpbml0aWFsU3RhdGU6IFF1aXpTdGF0ZSA9IHtcbiAgY3VycmVudFN0ZXA6IDEsXG4gIHRvdGFsU3RlcHM6IDM1LFxuICBnZW5kZXI6IG51bGwsXG4gIGFzdHJvbG9neUxldmVsOiBudWxsLFxuICBmaXJzdE5hbWU6IG51bGwsXG4gIGxhc3ROYW1lOiBudWxsLFxuICBiaXJ0aFBsYWNlOiBudWxsLFxuICBiaXJ0aFRpbWU6IG51bGwsXG4gIGJpcnRoRGF0ZToge1xuICAgIG1vbnRoOiBudWxsLFxuICAgIGRheTogbnVsbCxcbiAgICB5ZWFyOiBudWxsLFxuICB9LFxuICBiaXJ0aExvY2F0aW9uOiB7XG4gICAgbGF0aXR1ZGU6IG51bGwsXG4gICAgbG9uZ2l0dWRlOiBudWxsLFxuICAgIG5hbWU6IG51bGwsXG4gIH0sXG4gIGNvdmVyQ29sb3JTY2hlbWU6IFwiY3JlYW1cIixcbiAgZW1haWw6IG51bGwsXG4gIGFuc3dlcnM6IHt9LFxuICBxdWl6Q29tcGxldGVkOiBmYWxzZSxcbiAgbmF0YWxDaGFydDogbnVsbCxcbiAgY2hhcnRJbnRlcnByZXRhdGlvbjogbnVsbCxcbiAgaXNMb2FkaW5nQ2hhcnQ6IGZhbHNlLFxuICBjaGFydEVycm9yOiBudWxsLFxufVxuXG5jb25zdCBRdWl6Q29udGV4dCA9IGNyZWF0ZUNvbnRleHQ8UXVpekNvbnRleHRUeXBlIHwgdW5kZWZpbmVkPih1bmRlZmluZWQpXG5cbmV4cG9ydCBmdW5jdGlvbiBRdWl6UHJvdmlkZXIoeyBjaGlsZHJlbiB9OiB7IGNoaWxkcmVuOiBSZWFjdE5vZGUgfSkge1xuICAvLyBJbml0aWFsaXplIHN0YXRlIGZyb20gc3RvcmFnZSBvciB1c2UgZGVmYXVsdFxuICBjb25zdCBbc3RhdGUsIHNldFN0YXRlXSA9IHVzZVN0YXRlPFF1aXpTdGF0ZT4oKCkgPT4ge1xuICAgIC8vIFRoaXMgd2lsbCBvbmx5IHJ1biBvbiB0aGUgY2xpZW50IHNpZGVcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgY29uc3Qgc2F2ZWREYXRhID0gZ2V0UXVpekRhdGEoKVxuICAgICAgY29uc3QgcXVpekNvbXBsZXRlZCA9IGlzUXVpekNvbXBsZXRlZCgpXG5cbiAgICAgIGlmIChzYXZlZERhdGEpIHtcbiAgICAgICAgcmV0dXJuIHsgLi4uc2F2ZWREYXRhLCBxdWl6Q29tcGxldGVkIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGluaXRpYWxTdGF0ZVxuICB9KVxuXG4gIC8vIFNhdmUgc3RhdGUgdG8gc3RvcmFnZSB3aGVuZXZlciBpdCBjaGFuZ2VzXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgLy8gU2F2ZSBzdGF0ZSBvbiBldmVyeSBjaGFuZ2UsIG5vdCBqdXN0IHdoZW4gY29tcGxldGVkXG4gICAgc2F2ZVF1aXpEYXRhKHN0YXRlKVxuICB9LCBbc3RhdGVdKVxuXG4gIGNvbnN0IHNldEN1cnJlbnRTdGVwID0gKHN0ZXA6IG51bWJlcikgPT4ge1xuICAgIHNldFN0YXRlKChwcmV2KSA9PiAoeyAuLi5wcmV2LCBjdXJyZW50U3RlcDogc3RlcCB9KSlcbiAgfVxuXG4gIGNvbnN0IG5leHRTdGVwID0gKCkgPT4ge1xuICAgIHNldFN0YXRlKChwcmV2KSA9PiAoeyAuLi5wcmV2LCBjdXJyZW50U3RlcDogcHJldi5jdXJyZW50U3RlcCArIDEgfSkpXG4gIH1cblxuICBjb25zdCBwcmV2U3RlcCA9ICgpID0+IHtcbiAgICBpZiAoc3RhdGUuY3VycmVudFN0ZXAgPiAxKSB7XG4gICAgICBzZXRTdGF0ZSgocHJldikgPT4gKHsgLi4ucHJldiwgY3VycmVudFN0ZXA6IHByZXYuY3VycmVudFN0ZXAgLSAxIH0pKVxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHVwZGF0ZUFuc3dlciA9IChxdWVzdGlvbklkOiBzdHJpbmcsIGFuc3dlcjogYW55KSA9PiB7XG4gICAgc2V0U3RhdGUoKHByZXYpID0+ICh7XG4gICAgICAuLi5wcmV2LFxuICAgICAgYW5zd2VyczogeyAuLi5wcmV2LmFuc3dlcnMsIFtxdWVzdGlvbklkXTogYW5zd2VyIH0sXG4gICAgfSkpXG4gIH1cblxuICBjb25zdCBzZXRHZW5kZXIgPSAoZ2VuZGVyOiBHZW5kZXIpID0+IHtcbiAgICBzZXRTdGF0ZSgocHJldikgPT4gKHsgLi4ucHJldiwgZ2VuZGVyIH0pKVxuICB9XG5cbiAgY29uc3Qgc2V0QXN0cm9sb2d5TGV2ZWwgPSAobGV2ZWw6IEFzdHJvbG9neUxldmVsKSA9PiB7XG4gICAgc2V0U3RhdGUoKHByZXYpID0+ICh7IC4uLnByZXYsIGFzdHJvbG9neUxldmVsOiBsZXZlbCB9KSlcbiAgfVxuXG4gIGNvbnN0IHNldEJpcnRoRGF0ZSA9IChmaWVsZDogXCJtb250aFwiIHwgXCJkYXlcIiB8IFwieWVhclwiLCB2YWx1ZTogc3RyaW5nKSA9PiB7XG4gICAgc2V0U3RhdGUoKHByZXYpID0+ICh7XG4gICAgICAuLi5wcmV2LFxuICAgICAgYmlydGhEYXRlOiB7IC4uLnByZXYuYmlydGhEYXRlLCBbZmllbGRdOiB2YWx1ZSB9LFxuICAgIH0pKVxuICB9XG5cbiAgY29uc3Qgc2V0Rmlyc3ROYW1lID0gKGZpcnN0TmFtZTogc3RyaW5nKSA9PiB7XG4gICAgc2V0U3RhdGUoKHByZXYpID0+ICh7IC4uLnByZXYsIGZpcnN0TmFtZSB9KSlcbiAgfVxuXG4gIGNvbnN0IHNldExhc3ROYW1lID0gKGxhc3ROYW1lOiBzdHJpbmcpID0+IHtcbiAgICBzZXRTdGF0ZSgocHJldikgPT4gKHsgLi4ucHJldiwgbGFzdE5hbWUgfSkpXG4gIH1cblxuICBjb25zdCBzZXRCaXJ0aFBsYWNlID0gKGJpcnRoUGxhY2U6IHN0cmluZykgPT4ge1xuICAgIHNldFN0YXRlKChwcmV2KSA9PiAoeyAuLi5wcmV2LCBiaXJ0aFBsYWNlIH0pKVxuICB9XG5cbiAgY29uc3Qgc2V0QmlydGhUaW1lID0gKGJpcnRoVGltZTogc3RyaW5nKSA9PiB7XG4gICAgc2V0U3RhdGUoKHByZXYpID0+ICh7IC4uLnByZXYsIGJpcnRoVGltZSB9KSlcbiAgfVxuXG4gIGNvbnN0IHNldEJpcnRoTG9jYXRpb24gPSAobGF0aXR1ZGU6IG51bWJlciwgbG9uZ2l0dWRlOiBudW1iZXIsIG5hbWU6IHN0cmluZykgPT4ge1xuICAgIHNldFN0YXRlKChwcmV2KSA9PiAoe1xuICAgICAgLi4ucHJldixcbiAgICAgIGJpcnRoTG9jYXRpb246IHsgbGF0aXR1ZGUsIGxvbmdpdHVkZSwgbmFtZSB9LFxuICAgIH0pKVxuICB9XG5cbiAgY29uc3Qgc2V0Q292ZXJDb2xvclNjaGVtZSA9IChjb3ZlckNvbG9yU2NoZW1lOiBDb2xvclNjaGVtZSkgPT4ge1xuICAgIHNldFN0YXRlKChwcmV2KSA9PiAoeyAuLi5wcmV2LCBjb3ZlckNvbG9yU2NoZW1lIH0pKVxuICB9XG5cbiAgY29uc3Qgc2V0RW1haWwgPSAoZW1haWw6IHN0cmluZykgPT4ge1xuICAgIHNldFN0YXRlKChwcmV2KSA9PiAoeyAuLi5wcmV2LCBlbWFpbCB9KSlcbiAgfVxuXG4gIC8qKlxuICAgKiBNYXJrIHRoZSBxdWl6IGFzIGNvbXBsZXRlZC5cbiAgICogVGhpcyBmdW5jdGlvbiBtdXN0IGJlIGV4cGxpY2l0bHkgY2FsbGVkIHdoZW4gdGhlIHF1aXogaXMgYWN0dWFsbHkgY29tcGxldGUuXG4gICAqIFRoZSBxdWl6Q29tcGxldGVkIGZsYWcgZGV0ZXJtaW5lcyB3aGV0aGVyIHRvIHNob3cgdGhlIHJlc3VsdHMgcGFnZS5cbiAgICovXG4gIGNvbnN0IGNvbXBsZXRlUXVpeiA9ICgpID0+IHtcbiAgICBzZXRTdGF0ZSgocHJldikgPT4ge1xuICAgICAgY29uc3QgbmV3U3RhdGUgPSB7IC4uLnByZXYsIHF1aXpDb21wbGV0ZWQ6IHRydWUgfVxuICAgICAgLy8gU2F2ZSB0byBzdG9yYWdlIGltbWVkaWF0ZWx5IG9uIGNvbXBsZXRpb25cbiAgICAgIHNhdmVRdWl6RGF0YShuZXdTdGF0ZSlcbiAgICAgIHJldHVybiBuZXdTdGF0ZVxuICAgIH0pXG4gIH1cblxuICBjb25zdCByZXNldFF1aXogPSAoKSA9PiB7XG4gICAgLy8gQ2xlYXIgYWxsIHN0b3JhZ2UgZmlyc3RcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgLy8gRmlyc3QgY2xlYXIgb3VyIG93biBzdG9yYWdlXG4gICAgICBjbGVhclF1aXpEYXRhKClcbiAgICAgIFxuICAgICAgLy8gRm9yIGEgbW9yZSBhZ2dyZXNzaXZlIGFwcHJvYWNoLCBjbGVhciBhbGwgbG9jYWwgc3RvcmFnZSBjb21wbGV0ZWx5XG4gICAgICB0cnkge1xuICAgICAgICBsb2NhbFN0b3JhZ2UuY2xlYXIoKVxuICAgICAgICBzZXNzaW9uU3RvcmFnZS5jbGVhcigpXG4gICAgICAgIGNvbnNvbGUubG9nKFwiQ29tcGxldGUgc3RvcmFnZSB3aXBlIHBlcmZvcm1lZFwiKVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgZHVyaW5nIGNvbXBsZXRlIHN0b3JhZ2Ugd2lwZTpcIiwgZSlcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgLy8gUmVzZXQgdGhlIHN0YXRlXG4gICAgc2V0U3RhdGUoaW5pdGlhbFN0YXRlKVxuICAgIFxuICAgIC8vIEZvcmNlIHJlbG9hZCB0aGUgcGFnZSB0byBlbnN1cmUgYSBjb21wbGV0ZWx5IGZyZXNoIHN0YXRlXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gXCIvXCI7XG4gICAgfVxuICB9XG5cbiAgY29uc3Qgc2V0TmF0YWxDaGFydCA9IChuYXRhbENoYXJ0OiBOYXRhbENoYXJ0KSA9PiB7XG4gICAgc2V0U3RhdGUoKHByZXYpID0+ICh7IC4uLnByZXYsIG5hdGFsQ2hhcnQgfSkpXG4gIH1cblxuICBjb25zdCBzZXRDaGFydEludGVycHJldGF0aW9uID0gKGNoYXJ0SW50ZXJwcmV0YXRpb246IENoYXJ0SW50ZXJwcmV0YXRpb24pID0+IHtcbiAgICBzZXRTdGF0ZSgocHJldikgPT4gKHsgLi4ucHJldiwgY2hhcnRJbnRlcnByZXRhdGlvbiB9KSlcbiAgfVxuXG4gIC8vIEZ1bmN0aW9uIHRvIGZldGNoIG5hdGFsIGNoYXJ0IGRhdGEgZnJvbSB0aGUgQVBJXG4gIGNvbnN0IGZldGNoTmF0YWxDaGFydCA9IGFzeW5jICgpID0+IHtcbiAgICAvLyBJbXBvcnQgdGhlIHNlcnZpY2UgZHluYW1pY2FsbHkgdG8gYXZvaWQgc2VydmVyLXNpZGUgaXNzdWVzXG4gICAgY29uc3QgeyBmZXRjaE5hdGFsQ2hhcnQsIGdlb2NvZGVMb2NhdGlvbiwgZ2V0TmF0YWxDaGFydEludGVycHJldGF0aW9uIH0gPSBhd2FpdCBpbXBvcnQoXG4gICAgICBcIkAvc2VydmljZXMvYXN0cm9sb2d5LXNlcnZpY2VcIlxuICAgIClcblxuICAgIHNldFN0YXRlKChwcmV2KSA9PiAoeyAuLi5wcmV2LCBpc0xvYWRpbmdDaGFydDogdHJ1ZSwgY2hhcnRFcnJvcjogbnVsbCB9KSlcblxuICAgIHRyeSB7XG4gICAgICAvLyBDaGVjayBpZiB3ZSBoYXZlIGFsbCByZXF1aXJlZCBkYXRhXG4gICAgICBpZiAoIXN0YXRlLmJpcnRoRGF0ZS55ZWFyIHx8ICFzdGF0ZS5iaXJ0aERhdGUubW9udGggfHwgIXN0YXRlLmJpcnRoRGF0ZS5kYXkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQmlydGggZGF0ZSBpcyByZXF1aXJlZFwiKVxuICAgICAgfVxuXG4gICAgICBpZiAoIXN0YXRlLmJpcnRoVGltZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJCaXJ0aCB0aW1lIGlzIHJlcXVpcmVkIGZvciBhY2N1cmF0ZSBjaGFydCBjYWxjdWxhdGlvblwiKVxuICAgICAgfVxuXG4gICAgICBpZiAoIXN0YXRlLmJpcnRoUGxhY2UpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQmlydGggcGxhY2UgaXMgcmVxdWlyZWRcIilcbiAgICAgIH1cblxuICAgICAgLy8gRm9ybWF0IGRhdGUgZm9yIEFQSVxuICAgICAgY29uc3QgZm9ybWF0dGVkRGF0ZSA9IGAke3N0YXRlLmJpcnRoRGF0ZS55ZWFyfS0ke3N0YXRlLmJpcnRoRGF0ZS5tb250aC5wYWRTdGFydCgyLCBcIjBcIil9LSR7c3RhdGUuYmlydGhEYXRlLmRheS5wYWRTdGFydCgyLCBcIjBcIil9YFxuXG4gICAgICAvLyBHZXQgY29vcmRpbmF0ZXMgaWYgd2UgZG9uJ3QgaGF2ZSB0aGVtIHlldFxuICAgICAgbGV0IGxhdGl0dWRlOiBudW1iZXIsIGxvbmdpdHVkZTogbnVtYmVyLCBsb2NhdGlvbk5hbWU6IHN0cmluZ1xuXG4gICAgICBpZiAoIXN0YXRlLmJpcnRoTG9jYXRpb24ubGF0aXR1ZGUgfHwgIXN0YXRlLmJpcnRoTG9jYXRpb24ubG9uZ2l0dWRlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgZ2VvRGF0YSA9IGF3YWl0IGdlb2NvZGVMb2NhdGlvbihzdGF0ZS5iaXJ0aFBsYWNlKVxuICAgICAgICAgIGxhdGl0dWRlID0gZ2VvRGF0YS5sYXRpdHVkZVxuICAgICAgICAgIGxvbmdpdHVkZSA9IGdlb0RhdGEubG9uZ2l0dWRlXG4gICAgICAgICAgbG9jYXRpb25OYW1lID0gZ2VvRGF0YS5uYW1lXG5cbiAgICAgICAgICAvLyBTYXZlIHRoZSBsb2NhdGlvbiBkYXRhXG4gICAgICAgICAgc2V0QmlydGhMb2NhdGlvbihsYXRpdHVkZSwgbG9uZ2l0dWRlLCBsb2NhdGlvbk5hbWUpXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGdlb2NvZGluZyBsb2NhdGlvbjpcIiwgZXJyb3IpXG4gICAgICAgICAgLy8gVXNlIGRlZmF1bHQgY29vcmRpbmF0ZXMgKDAsMCkgaWYgZ2VvY29kaW5nIGZhaWxzXG4gICAgICAgICAgbGF0aXR1ZGUgPSAwXG4gICAgICAgICAgbG9uZ2l0dWRlID0gMFxuICAgICAgICAgIGxvY2F0aW9uTmFtZSA9IHN0YXRlLmJpcnRoUGxhY2VcblxuICAgICAgICAgIC8vIFNhdmUgdGhlIGRlZmF1bHQgbG9jYXRpb24gZGF0YVxuICAgICAgICAgIHNldEJpcnRoTG9jYXRpb24obGF0aXR1ZGUsIGxvbmdpdHVkZSwgbG9jYXRpb25OYW1lKVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsYXRpdHVkZSA9IHN0YXRlLmJpcnRoTG9jYXRpb24ubGF0aXR1ZGVcbiAgICAgICAgbG9uZ2l0dWRlID0gc3RhdGUuYmlydGhMb2NhdGlvbi5sb25naXR1ZGVcbiAgICAgICAgbG9jYXRpb25OYW1lID0gc3RhdGUuYmlydGhMb2NhdGlvbi5uYW1lIHx8IHN0YXRlLmJpcnRoUGxhY2VcbiAgICAgIH1cblxuICAgICAgLy8gRmV0Y2ggdGhlIG5hdGFsIGNoYXJ0IHVzaW5nIHRoZSBuZXcgQXN0cm9sb2d5QVBJIHNlcnZpY2VcbiAgICAgIGNvbnN0IG5hdGFsQ2hhcnQgPSBhd2FpdCBmZXRjaE5hdGFsQ2hhcnQoZm9ybWF0dGVkRGF0ZSwgc3RhdGUuYmlydGhUaW1lLCBsYXRpdHVkZSwgbG9uZ2l0dWRlKVxuXG4gICAgICAvLyBTYXZlIHRoZSBuYXRhbCBjaGFydFxuICAgICAgc2V0TmF0YWxDaGFydChuYXRhbENoYXJ0KVxuXG4gICAgICB0cnkge1xuICAgICAgICAvLyBHZXQgaW50ZXJwcmV0YXRpb25zXG4gICAgICAgIGNvbnN0IGludGVycHJldGF0aW9uID0gYXdhaXQgZ2V0TmF0YWxDaGFydEludGVycHJldGF0aW9uKG5hdGFsQ2hhcnQpXG4gICAgICAgIHNldENoYXJ0SW50ZXJwcmV0YXRpb24oaW50ZXJwcmV0YXRpb24pXG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgZ2V0dGluZyBjaGFydCBpbnRlcnByZXRhdGlvbjpcIiwgZXJyb3IpXG4gICAgICAgIC8vIENvbnRpbnVlIGV2ZW4gaWYgaW50ZXJwcmV0YXRpb24gZmFpbHNcbiAgICAgIH1cblxuICAgICAgc2V0U3RhdGUoKHByZXYpID0+ICh7IC4uLnByZXYsIGlzTG9hZGluZ0NoYXJ0OiBmYWxzZSB9KSlcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGZldGNoaW5nIG5hdGFsIGNoYXJ0OlwiLCBlcnJvcilcbiAgICAgIHNldFN0YXRlKChwcmV2KSA9PiAoe1xuICAgICAgICAuLi5wcmV2LFxuICAgICAgICBpc0xvYWRpbmdDaGFydDogZmFsc2UsXG4gICAgICAgIGNoYXJ0RXJyb3I6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogXCJGYWlsZWQgdG8gZ2VuZXJhdGUgbmF0YWwgY2hhcnRcIixcbiAgICAgIH0pKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAoXG4gICAgPFF1aXpDb250ZXh0LlByb3ZpZGVyXG4gICAgICB2YWx1ZT17e1xuICAgICAgICBzdGF0ZSxcbiAgICAgICAgc2V0Q3VycmVudFN0ZXAsXG4gICAgICAgIG5leHRTdGVwLFxuICAgICAgICBwcmV2U3RlcCxcbiAgICAgICAgdXBkYXRlQW5zd2VyLFxuICAgICAgICBzZXRHZW5kZXIsXG4gICAgICAgIHNldEFzdHJvbG9neUxldmVsLFxuICAgICAgICBzZXRCaXJ0aERhdGUsXG4gICAgICAgIHNldEZpcnN0TmFtZSxcbiAgICAgICAgc2V0TGFzdE5hbWUsXG4gICAgICAgIHNldEJpcnRoUGxhY2UsXG4gICAgICAgIHNldEJpcnRoVGltZSxcbiAgICAgICAgc2V0QmlydGhMb2NhdGlvbixcbiAgICAgICAgc2V0Q292ZXJDb2xvclNjaGVtZSxcbiAgICAgICAgc2V0RW1haWwsXG4gICAgICAgIGNvbXBsZXRlUXVpeixcbiAgICAgICAgcmVzZXRRdWl6LFxuICAgICAgICBmZXRjaE5hdGFsQ2hhcnQsXG4gICAgICAgIHNldE5hdGFsQ2hhcnQsXG4gICAgICAgIHNldENoYXJ0SW50ZXJwcmV0YXRpb24sXG4gICAgICB9fVxuICAgID5cbiAgICAgIHtjaGlsZHJlbn1cbiAgICA8L1F1aXpDb250ZXh0LlByb3ZpZGVyPlxuICApXG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VRdWl6KCkge1xuICBjb25zdCBjb250ZXh0ID0gdXNlQ29udGV4dChRdWl6Q29udGV4dClcbiAgaWYgKGNvbnRleHQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcInVzZVF1aXogbXVzdCBiZSB1c2VkIHdpdGhpbiBhIFF1aXpQcm92aWRlclwiKVxuICB9XG4gIHJldHVybiBjb250ZXh0XG59XG5cbiJdLCJuYW1lcyI6WyJjcmVhdGVDb250ZXh0IiwidXNlQ29udGV4dCIsInVzZVN0YXRlIiwidXNlRWZmZWN0Iiwic2F2ZVF1aXpEYXRhIiwiZ2V0UXVpekRhdGEiLCJpc1F1aXpDb21wbGV0ZWQiLCJjbGVhclF1aXpEYXRhIiwiaW5pdGlhbFN0YXRlIiwiY3VycmVudFN0ZXAiLCJ0b3RhbFN0ZXBzIiwiZ2VuZGVyIiwiYXN0cm9sb2d5TGV2ZWwiLCJmaXJzdE5hbWUiLCJsYXN0TmFtZSIsImJpcnRoUGxhY2UiLCJiaXJ0aFRpbWUiLCJiaXJ0aERhdGUiLCJtb250aCIsImRheSIsInllYXIiLCJiaXJ0aExvY2F0aW9uIiwibGF0aXR1ZGUiLCJsb25naXR1ZGUiLCJuYW1lIiwiY292ZXJDb2xvclNjaGVtZSIsImVtYWlsIiwiYW5zd2VycyIsInF1aXpDb21wbGV0ZWQiLCJuYXRhbENoYXJ0IiwiY2hhcnRJbnRlcnByZXRhdGlvbiIsImlzTG9hZGluZ0NoYXJ0IiwiY2hhcnRFcnJvciIsIlF1aXpDb250ZXh0IiwidW5kZWZpbmVkIiwiUXVpelByb3ZpZGVyIiwiY2hpbGRyZW4iLCJzdGF0ZSIsInNldFN0YXRlIiwic2F2ZWREYXRhIiwic2V0Q3VycmVudFN0ZXAiLCJzdGVwIiwicHJldiIsIm5leHRTdGVwIiwicHJldlN0ZXAiLCJ1cGRhdGVBbnN3ZXIiLCJxdWVzdGlvbklkIiwiYW5zd2VyIiwic2V0R2VuZGVyIiwic2V0QXN0cm9sb2d5TGV2ZWwiLCJsZXZlbCIsInNldEJpcnRoRGF0ZSIsImZpZWxkIiwidmFsdWUiLCJzZXRGaXJzdE5hbWUiLCJzZXRMYXN0TmFtZSIsInNldEJpcnRoUGxhY2UiLCJzZXRCaXJ0aFRpbWUiLCJzZXRCaXJ0aExvY2F0aW9uIiwic2V0Q292ZXJDb2xvclNjaGVtZSIsInNldEVtYWlsIiwiY29tcGxldGVRdWl6IiwibmV3U3RhdGUiLCJyZXNldFF1aXoiLCJsb2NhbFN0b3JhZ2UiLCJjbGVhciIsInNlc3Npb25TdG9yYWdlIiwiY29uc29sZSIsImxvZyIsImUiLCJlcnJvciIsIndpbmRvdyIsImxvY2F0aW9uIiwiaHJlZiIsInNldE5hdGFsQ2hhcnQiLCJzZXRDaGFydEludGVycHJldGF0aW9uIiwiZmV0Y2hOYXRhbENoYXJ0IiwiZ2VvY29kZUxvY2F0aW9uIiwiZ2V0TmF0YWxDaGFydEludGVycHJldGF0aW9uIiwiRXJyb3IiLCJmb3JtYXR0ZWREYXRlIiwicGFkU3RhcnQiLCJsb2NhdGlvbk5hbWUiLCJnZW9EYXRhIiwiaW50ZXJwcmV0YXRpb24iLCJtZXNzYWdlIiwiUHJvdmlkZXIiLCJ1c2VRdWl6IiwiY29udGV4dCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./contexts/quiz-context.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/next@15.2.4_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2FUsers%2Fmarkonovakovski%2FDocuments%2FVisual%20Code%2FAstroBook%2FAstroBook%2Fcontexts%2Fquiz-context.tsx%22%2C%22ids%22%3A%5B%22QuizProvider%22%5D%7D&server=false!":
/*!**************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@15.2.4_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2FUsers%2Fmarkonovakovski%2FDocuments%2FVisual%20Code%2FAstroBook%2FAstroBook%2Fcontexts%2Fquiz-context.tsx%22%2C%22ids%22%3A%5B%22QuizProvider%22%5D%7D&server=false! ***!
  \**************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("Promise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./contexts/quiz-context.tsx */ \"(app-pages-browser)/./contexts/quiz-context.tsx\"));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE1LjIuNF9yZWFjdC1kb21AMTkuMS4wX3JlYWN0QDE5LjEuMF9fcmVhY3RAMTkuMS4wL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtZmxpZ2h0LWNsaWVudC1lbnRyeS1sb2FkZXIuanM/bW9kdWxlcz0lN0IlMjJyZXF1ZXN0JTIyJTNBJTIyJTJGVXNlcnMlMkZtYXJrb25vdmFrb3Zza2klMkZEb2N1bWVudHMlMkZWaXN1YWwlMjBDb2RlJTJGQXN0cm9Cb29rJTJGQXN0cm9Cb29rJTJGY29udGV4dHMlMkZxdWl6LWNvbnRleHQudHN4JTIyJTJDJTIyaWRzJTIyJTNBJTVCJTIyUXVpelByb3ZpZGVyJTIyJTVEJTdEJnNlcnZlcj1mYWxzZSEiLCJtYXBwaW5ncyI6IkFBQUEsZ0xBQWlLIiwic291cmNlcyI6WyIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0KC8qIHdlYnBhY2tNb2RlOiBcImVhZ2VyXCIsIHdlYnBhY2tFeHBvcnRzOiBbXCJRdWl6UHJvdmlkZXJcIl0gKi8gXCIvVXNlcnMvbWFya29ub3Zha292c2tpL0RvY3VtZW50cy9WaXN1YWwgQ29kZS9Bc3Ryb0Jvb2svQXN0cm9Cb29rL2NvbnRleHRzL3F1aXotY29udGV4dC50c3hcIik7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/next@15.2.4_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2FUsers%2Fmarkonovakovski%2FDocuments%2FVisual%20Code%2FAstroBook%2FAstroBook%2Fcontexts%2Fquiz-context.tsx%22%2C%22ids%22%3A%5B%22QuizProvider%22%5D%7D&server=false!\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/next@15.2.4_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js":
/*!*******************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@15.2.4_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js ***!
  \*******************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/**\n * @license React\n * react-jsx-dev-runtime.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n true &&\n  (function () {\n    function getComponentNameFromType(type) {\n      if (null == type) return null;\n      if (\"function\" === typeof type)\n        return type.$$typeof === REACT_CLIENT_REFERENCE\n          ? null\n          : type.displayName || type.name || null;\n      if (\"string\" === typeof type) return type;\n      switch (type) {\n        case REACT_FRAGMENT_TYPE:\n          return \"Fragment\";\n        case REACT_PORTAL_TYPE:\n          return \"Portal\";\n        case REACT_PROFILER_TYPE:\n          return \"Profiler\";\n        case REACT_STRICT_MODE_TYPE:\n          return \"StrictMode\";\n        case REACT_SUSPENSE_TYPE:\n          return \"Suspense\";\n        case REACT_SUSPENSE_LIST_TYPE:\n          return \"SuspenseList\";\n      }\n      if (\"object\" === typeof type)\n        switch (\n          (\"number\" === typeof type.tag &&\n            console.error(\n              \"Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.\"\n            ),\n          type.$$typeof)\n        ) {\n          case REACT_CONTEXT_TYPE:\n            return (type.displayName || \"Context\") + \".Provider\";\n          case REACT_CONSUMER_TYPE:\n            return (type._context.displayName || \"Context\") + \".Consumer\";\n          case REACT_FORWARD_REF_TYPE:\n            var innerType = type.render;\n            type = type.displayName;\n            type ||\n              ((type = innerType.displayName || innerType.name || \"\"),\n              (type = \"\" !== type ? \"ForwardRef(\" + type + \")\" : \"ForwardRef\"));\n            return type;\n          case REACT_MEMO_TYPE:\n            return (\n              (innerType = type.displayName || null),\n              null !== innerType\n                ? innerType\n                : getComponentNameFromType(type.type) || \"Memo\"\n            );\n          case REACT_LAZY_TYPE:\n            innerType = type._payload;\n            type = type._init;\n            try {\n              return getComponentNameFromType(type(innerType));\n            } catch (x) {}\n        }\n      return null;\n    }\n    function testStringCoercion(value) {\n      return \"\" + value;\n    }\n    function checkKeyStringCoercion(value) {\n      try {\n        testStringCoercion(value);\n        var JSCompiler_inline_result = !1;\n      } catch (e) {\n        JSCompiler_inline_result = !0;\n      }\n      if (JSCompiler_inline_result) {\n        JSCompiler_inline_result = console;\n        var JSCompiler_temp_const = JSCompiler_inline_result.error;\n        var JSCompiler_inline_result$jscomp$0 =\n          (\"function\" === typeof Symbol &&\n            Symbol.toStringTag &&\n            value[Symbol.toStringTag]) ||\n          value.constructor.name ||\n          \"Object\";\n        JSCompiler_temp_const.call(\n          JSCompiler_inline_result,\n          \"The provided key is an unsupported type %s. This value must be coerced to a string before using it here.\",\n          JSCompiler_inline_result$jscomp$0\n        );\n        return testStringCoercion(value);\n      }\n    }\n    function getTaskName(type) {\n      if (type === REACT_FRAGMENT_TYPE) return \"<>\";\n      if (\n        \"object\" === typeof type &&\n        null !== type &&\n        type.$$typeof === REACT_LAZY_TYPE\n      )\n        return \"<...>\";\n      try {\n        var name = getComponentNameFromType(type);\n        return name ? \"<\" + name + \">\" : \"<...>\";\n      } catch (x) {\n        return \"<...>\";\n      }\n    }\n    function getOwner() {\n      var dispatcher = ReactSharedInternals.A;\n      return null === dispatcher ? null : dispatcher.getOwner();\n    }\n    function hasValidKey(config) {\n      if (hasOwnProperty.call(config, \"key\")) {\n        var getter = Object.getOwnPropertyDescriptor(config, \"key\").get;\n        if (getter && getter.isReactWarning) return !1;\n      }\n      return void 0 !== config.key;\n    }\n    function defineKeyPropWarningGetter(props, displayName) {\n      function warnAboutAccessingKey() {\n        specialPropKeyWarningShown ||\n          ((specialPropKeyWarningShown = !0),\n          console.error(\n            \"%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)\",\n            displayName\n          ));\n      }\n      warnAboutAccessingKey.isReactWarning = !0;\n      Object.defineProperty(props, \"key\", {\n        get: warnAboutAccessingKey,\n        configurable: !0\n      });\n    }\n    function elementRefGetterWithDeprecationWarning() {\n      var componentName = getComponentNameFromType(this.type);\n      didWarnAboutElementRef[componentName] ||\n        ((didWarnAboutElementRef[componentName] = !0),\n        console.error(\n          \"Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release.\"\n        ));\n      componentName = this.props.ref;\n      return void 0 !== componentName ? componentName : null;\n    }\n    function ReactElement(\n      type,\n      key,\n      self,\n      source,\n      owner,\n      props,\n      debugStack,\n      debugTask\n    ) {\n      self = props.ref;\n      type = {\n        $$typeof: REACT_ELEMENT_TYPE,\n        type: type,\n        key: key,\n        props: props,\n        _owner: owner\n      };\n      null !== (void 0 !== self ? self : null)\n        ? Object.defineProperty(type, \"ref\", {\n            enumerable: !1,\n            get: elementRefGetterWithDeprecationWarning\n          })\n        : Object.defineProperty(type, \"ref\", { enumerable: !1, value: null });\n      type._store = {};\n      Object.defineProperty(type._store, \"validated\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: 0\n      });\n      Object.defineProperty(type, \"_debugInfo\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: null\n      });\n      Object.defineProperty(type, \"_debugStack\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: debugStack\n      });\n      Object.defineProperty(type, \"_debugTask\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: debugTask\n      });\n      Object.freeze && (Object.freeze(type.props), Object.freeze(type));\n      return type;\n    }\n    function jsxDEVImpl(\n      type,\n      config,\n      maybeKey,\n      isStaticChildren,\n      source,\n      self,\n      debugStack,\n      debugTask\n    ) {\n      var children = config.children;\n      if (void 0 !== children)\n        if (isStaticChildren)\n          if (isArrayImpl(children)) {\n            for (\n              isStaticChildren = 0;\n              isStaticChildren < children.length;\n              isStaticChildren++\n            )\n              validateChildKeys(children[isStaticChildren]);\n            Object.freeze && Object.freeze(children);\n          } else\n            console.error(\n              \"React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.\"\n            );\n        else validateChildKeys(children);\n      if (hasOwnProperty.call(config, \"key\")) {\n        children = getComponentNameFromType(type);\n        var keys = Object.keys(config).filter(function (k) {\n          return \"key\" !== k;\n        });\n        isStaticChildren =\n          0 < keys.length\n            ? \"{key: someKey, \" + keys.join(\": ..., \") + \": ...}\"\n            : \"{key: someKey}\";\n        didWarnAboutKeySpread[children + isStaticChildren] ||\n          ((keys =\n            0 < keys.length ? \"{\" + keys.join(\": ..., \") + \": ...}\" : \"{}\"),\n          console.error(\n            'A props object containing a \"key\" prop is being spread into JSX:\\n  let props = %s;\\n  <%s {...props} />\\nReact keys must be passed directly to JSX without using spread:\\n  let props = %s;\\n  <%s key={someKey} {...props} />',\n            isStaticChildren,\n            children,\n            keys,\n            children\n          ),\n          (didWarnAboutKeySpread[children + isStaticChildren] = !0));\n      }\n      children = null;\n      void 0 !== maybeKey &&\n        (checkKeyStringCoercion(maybeKey), (children = \"\" + maybeKey));\n      hasValidKey(config) &&\n        (checkKeyStringCoercion(config.key), (children = \"\" + config.key));\n      if (\"key\" in config) {\n        maybeKey = {};\n        for (var propName in config)\n          \"key\" !== propName && (maybeKey[propName] = config[propName]);\n      } else maybeKey = config;\n      children &&\n        defineKeyPropWarningGetter(\n          maybeKey,\n          \"function\" === typeof type\n            ? type.displayName || type.name || \"Unknown\"\n            : type\n        );\n      return ReactElement(\n        type,\n        children,\n        self,\n        source,\n        getOwner(),\n        maybeKey,\n        debugStack,\n        debugTask\n      );\n    }\n    function validateChildKeys(node) {\n      \"object\" === typeof node &&\n        null !== node &&\n        node.$$typeof === REACT_ELEMENT_TYPE &&\n        node._store &&\n        (node._store.validated = 1);\n    }\n    var React = __webpack_require__(/*! next/dist/compiled/react */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.2.4_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/next/dist/compiled/react/index.js\"),\n      REACT_ELEMENT_TYPE = Symbol.for(\"react.transitional.element\"),\n      REACT_PORTAL_TYPE = Symbol.for(\"react.portal\"),\n      REACT_FRAGMENT_TYPE = Symbol.for(\"react.fragment\"),\n      REACT_STRICT_MODE_TYPE = Symbol.for(\"react.strict_mode\"),\n      REACT_PROFILER_TYPE = Symbol.for(\"react.profiler\");\n    Symbol.for(\"react.provider\");\n    var REACT_CONSUMER_TYPE = Symbol.for(\"react.consumer\"),\n      REACT_CONTEXT_TYPE = Symbol.for(\"react.context\"),\n      REACT_FORWARD_REF_TYPE = Symbol.for(\"react.forward_ref\"),\n      REACT_SUSPENSE_TYPE = Symbol.for(\"react.suspense\"),\n      REACT_SUSPENSE_LIST_TYPE = Symbol.for(\"react.suspense_list\"),\n      REACT_MEMO_TYPE = Symbol.for(\"react.memo\"),\n      REACT_LAZY_TYPE = Symbol.for(\"react.lazy\"),\n      REACT_CLIENT_REFERENCE = Symbol.for(\"react.client.reference\"),\n      ReactSharedInternals =\n        React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,\n      hasOwnProperty = Object.prototype.hasOwnProperty,\n      isArrayImpl = Array.isArray,\n      createTask = console.createTask\n        ? console.createTask\n        : function () {\n            return null;\n          },\n      specialPropKeyWarningShown;\n    var didWarnAboutElementRef = {};\n    var didWarnAboutKeySpread = {};\n    exports.Fragment = REACT_FRAGMENT_TYPE;\n    exports.jsxDEV = function (\n      type,\n      config,\n      maybeKey,\n      isStaticChildren,\n      source,\n      self\n    ) {\n      return jsxDEVImpl(\n        type,\n        config,\n        maybeKey,\n        isStaticChildren,\n        source,\n        self,\n        Error(\"react-stack-top-frame\"),\n        createTask(getTaskName(type))\n      );\n    };\n  })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE1LjIuNF9yZWFjdC1kb21AMTkuMS4wX3JlYWN0QDE5LjEuMF9fcmVhY3RAMTkuMS4wL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7QUFDYixLQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLCtDQUErQyw2QkFBNkI7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxnQkFBZ0IsZ0RBQWdEO0FBQ2hFLGdCQUFnQixhQUFhO0FBQzdCO0FBQ0E7QUFDQSxnQ0FBZ0Msa0NBQWtDLE9BQU87QUFDekU7QUFDQSxnR0FBZ0csU0FBUyxVQUFVLHNGQUFzRixhQUFhLFVBQVUsVUFBVTtBQUMxTztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixtQkFBTyxDQUFDLGlMQUEwQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxJQUFJLGdCQUFnQjtBQUNwQixJQUFJLGNBQWM7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyIsInNvdXJjZXMiOlsiL1VzZXJzL21hcmtvbm92YWtvdnNraS9Eb2N1bWVudHMvVmlzdWFsIENvZGUvQXN0cm9Cb29rL0FzdHJvQm9vay9ub2RlX21vZHVsZXMvLnBucG0vbmV4dEAxNS4yLjRfcmVhY3QtZG9tQDE5LjEuMF9yZWFjdEAxOS4xLjBfX3JlYWN0QDE5LjEuMC9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0L2Nqcy9yZWFjdC1qc3gtZGV2LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZSBSZWFjdFxuICogcmVhY3QtanN4LWRldi1ydW50aW1lLmRldmVsb3BtZW50LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViAmJlxuICAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKSB7XG4gICAgICBpZiAobnVsbCA9PSB0eXBlKSByZXR1cm4gbnVsbDtcbiAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB0eXBlKVxuICAgICAgICByZXR1cm4gdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRVxuICAgICAgICAgID8gbnVsbFxuICAgICAgICAgIDogdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgbnVsbDtcbiAgICAgIGlmIChcInN0cmluZ1wiID09PSB0eXBlb2YgdHlwZSkgcmV0dXJuIHR5cGU7XG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBSRUFDVF9GUkFHTUVOVF9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIkZyYWdtZW50XCI7XG4gICAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIFwiUG9ydGFsXCI7XG4gICAgICAgIGNhc2UgUkVBQ1RfUFJPRklMRVJfVFlQRTpcbiAgICAgICAgICByZXR1cm4gXCJQcm9maWxlclwiO1xuICAgICAgICBjYXNlIFJFQUNUX1NUUklDVF9NT0RFX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIFwiU3RyaWN0TW9kZVwiO1xuICAgICAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIFwiU3VzcGVuc2VcIjtcbiAgICAgICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIFwiU3VzcGVuc2VMaXN0XCI7XG4gICAgICB9XG4gICAgICBpZiAoXCJvYmplY3RcIiA9PT0gdHlwZW9mIHR5cGUpXG4gICAgICAgIHN3aXRjaCAoXG4gICAgICAgICAgKFwibnVtYmVyXCIgPT09IHR5cGVvZiB0eXBlLnRhZyAmJlxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJSZWNlaXZlZCBhbiB1bmV4cGVjdGVkIG9iamVjdCBpbiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoKS4gVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiXG4gICAgICAgICAgICApLFxuICAgICAgICAgIHR5cGUuJCR0eXBlb2YpXG4gICAgICAgICkge1xuICAgICAgICAgIGNhc2UgUkVBQ1RfQ09OVEVYVF9UWVBFOlxuICAgICAgICAgICAgcmV0dXJuICh0eXBlLmRpc3BsYXlOYW1lIHx8IFwiQ29udGV4dFwiKSArIFwiLlByb3ZpZGVyXCI7XG4gICAgICAgICAgY2FzZSBSRUFDVF9DT05TVU1FUl9UWVBFOlxuICAgICAgICAgICAgcmV0dXJuICh0eXBlLl9jb250ZXh0LmRpc3BsYXlOYW1lIHx8IFwiQ29udGV4dFwiKSArIFwiLkNvbnN1bWVyXCI7XG4gICAgICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICAgICAgdmFyIGlubmVyVHlwZSA9IHR5cGUucmVuZGVyO1xuICAgICAgICAgICAgdHlwZSA9IHR5cGUuZGlzcGxheU5hbWU7XG4gICAgICAgICAgICB0eXBlIHx8XG4gICAgICAgICAgICAgICgodHlwZSA9IGlubmVyVHlwZS5kaXNwbGF5TmFtZSB8fCBpbm5lclR5cGUubmFtZSB8fCBcIlwiKSxcbiAgICAgICAgICAgICAgKHR5cGUgPSBcIlwiICE9PSB0eXBlID8gXCJGb3J3YXJkUmVmKFwiICsgdHlwZSArIFwiKVwiIDogXCJGb3J3YXJkUmVmXCIpKTtcbiAgICAgICAgICAgIHJldHVybiB0eXBlO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgKGlubmVyVHlwZSA9IHR5cGUuZGlzcGxheU5hbWUgfHwgbnVsbCksXG4gICAgICAgICAgICAgIG51bGwgIT09IGlubmVyVHlwZVxuICAgICAgICAgICAgICAgID8gaW5uZXJUeXBlXG4gICAgICAgICAgICAgICAgOiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZS50eXBlKSB8fCBcIk1lbW9cIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAgICAgIGlubmVyVHlwZSA9IHR5cGUuX3BheWxvYWQ7XG4gICAgICAgICAgICB0eXBlID0gdHlwZS5faW5pdDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZShpbm5lclR5cGUpKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKHgpIHt9XG4gICAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiBcIlwiICsgdmFsdWU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNoZWNrS2V5U3RyaW5nQ29lcmNpb24odmFsdWUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSk7XG4gICAgICAgIHZhciBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgPSAhMTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ID0gITA7XG4gICAgICB9XG4gICAgICBpZiAoSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0KSB7XG4gICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA9IGNvbnNvbGU7XG4gICAgICAgIHZhciBKU0NvbXBpbGVyX3RlbXBfY29uc3QgPSBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQuZXJyb3I7XG4gICAgICAgIHZhciBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQkanNjb21wJDAgPVxuICAgICAgICAgIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBTeW1ib2wgJiZcbiAgICAgICAgICAgIFN5bWJvbC50b1N0cmluZ1RhZyAmJlxuICAgICAgICAgICAgdmFsdWVbU3ltYm9sLnRvU3RyaW5nVGFnXSkgfHxcbiAgICAgICAgICB2YWx1ZS5jb25zdHJ1Y3Rvci5uYW1lIHx8XG4gICAgICAgICAgXCJPYmplY3RcIjtcbiAgICAgICAgSlNDb21waWxlcl90ZW1wX2NvbnN0LmNhbGwoXG4gICAgICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0LFxuICAgICAgICAgIFwiVGhlIHByb3ZpZGVkIGtleSBpcyBhbiB1bnN1cHBvcnRlZCB0eXBlICVzLiBUaGlzIHZhbHVlIG11c3QgYmUgY29lcmNlZCB0byBhIHN0cmluZyBiZWZvcmUgdXNpbmcgaXQgaGVyZS5cIixcbiAgICAgICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQkanNjb21wJDBcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldFRhc2tOYW1lKHR5cGUpIHtcbiAgICAgIGlmICh0eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFKSByZXR1cm4gXCI8PlwiO1xuICAgICAgaWYgKFxuICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2YgdHlwZSAmJlxuICAgICAgICBudWxsICE9PSB0eXBlICYmXG4gICAgICAgIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0xBWllfVFlQRVxuICAgICAgKVxuICAgICAgICByZXR1cm4gXCI8Li4uPlwiO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSk7XG4gICAgICAgIHJldHVybiBuYW1lID8gXCI8XCIgKyBuYW1lICsgXCI+XCIgOiBcIjwuLi4+XCI7XG4gICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgIHJldHVybiBcIjwuLi4+XCI7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldE93bmVyKCkge1xuICAgICAgdmFyIGRpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5BO1xuICAgICAgcmV0dXJuIG51bGwgPT09IGRpc3BhdGNoZXIgPyBudWxsIDogZGlzcGF0Y2hlci5nZXRPd25lcigpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBoYXNWYWxpZEtleShjb25maWcpIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgXCJrZXlcIikpIHtcbiAgICAgICAgdmFyIGdldHRlciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY29uZmlnLCBcImtleVwiKS5nZXQ7XG4gICAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSByZXR1cm4gITE7XG4gICAgICB9XG4gICAgICByZXR1cm4gdm9pZCAwICE9PSBjb25maWcua2V5O1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpIHtcbiAgICAgIGZ1bmN0aW9uIHdhcm5BYm91dEFjY2Vzc2luZ0tleSgpIHtcbiAgICAgICAgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24gfHxcbiAgICAgICAgICAoKHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duID0gITApLFxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIiVzOiBga2V5YCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0IGluIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgdmFsdWUgd2l0aGluIHRoZSBjaGlsZCBjb21wb25lbnQsIHlvdSBzaG91bGQgcGFzcyBpdCBhcyBhIGRpZmZlcmVudCBwcm9wLiAoaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9zcGVjaWFsLXByb3BzKVwiLFxuICAgICAgICAgICAgZGlzcGxheU5hbWVcbiAgICAgICAgICApKTtcbiAgICAgIH1cbiAgICAgIHdhcm5BYm91dEFjY2Vzc2luZ0tleS5pc1JlYWN0V2FybmluZyA9ICEwO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCBcImtleVwiLCB7XG4gICAgICAgIGdldDogd2FybkFib3V0QWNjZXNzaW5nS2V5LFxuICAgICAgICBjb25maWd1cmFibGU6ICEwXG4gICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZWxlbWVudFJlZkdldHRlcldpdGhEZXByZWNhdGlvbldhcm5pbmcoKSB7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0aGlzLnR5cGUpO1xuICAgICAgZGlkV2FybkFib3V0RWxlbWVudFJlZltjb21wb25lbnROYW1lXSB8fFxuICAgICAgICAoKGRpZFdhcm5BYm91dEVsZW1lbnRSZWZbY29tcG9uZW50TmFtZV0gPSAhMCksXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJBY2Nlc3NpbmcgZWxlbWVudC5yZWYgd2FzIHJlbW92ZWQgaW4gUmVhY3QgMTkuIHJlZiBpcyBub3cgYSByZWd1bGFyIHByb3AuIEl0IHdpbGwgYmUgcmVtb3ZlZCBmcm9tIHRoZSBKU1ggRWxlbWVudCB0eXBlIGluIGEgZnV0dXJlIHJlbGVhc2UuXCJcbiAgICAgICAgKSk7XG4gICAgICBjb21wb25lbnROYW1lID0gdGhpcy5wcm9wcy5yZWY7XG4gICAgICByZXR1cm4gdm9pZCAwICE9PSBjb21wb25lbnROYW1lID8gY29tcG9uZW50TmFtZSA6IG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFJlYWN0RWxlbWVudChcbiAgICAgIHR5cGUsXG4gICAgICBrZXksXG4gICAgICBzZWxmLFxuICAgICAgc291cmNlLFxuICAgICAgb3duZXIsXG4gICAgICBwcm9wcyxcbiAgICAgIGRlYnVnU3RhY2ssXG4gICAgICBkZWJ1Z1Rhc2tcbiAgICApIHtcbiAgICAgIHNlbGYgPSBwcm9wcy5yZWY7XG4gICAgICB0eXBlID0ge1xuICAgICAgICAkJHR5cGVvZjogUkVBQ1RfRUxFTUVOVF9UWVBFLFxuICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgcHJvcHM6IHByb3BzLFxuICAgICAgICBfb3duZXI6IG93bmVyXG4gICAgICB9O1xuICAgICAgbnVsbCAhPT0gKHZvaWQgMCAhPT0gc2VsZiA/IHNlbGYgOiBudWxsKVxuICAgICAgICA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0eXBlLCBcInJlZlwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiAhMSxcbiAgICAgICAgICAgIGdldDogZWxlbWVudFJlZkdldHRlcldpdGhEZXByZWNhdGlvbldhcm5pbmdcbiAgICAgICAgICB9KVxuICAgICAgICA6IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0eXBlLCBcInJlZlwiLCB7IGVudW1lcmFibGU6ICExLCB2YWx1ZTogbnVsbCB9KTtcbiAgICAgIHR5cGUuX3N0b3JlID0ge307XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodHlwZS5fc3RvcmUsIFwidmFsaWRhdGVkXCIsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiAhMSxcbiAgICAgICAgZW51bWVyYWJsZTogITEsXG4gICAgICAgIHdyaXRhYmxlOiAhMCxcbiAgICAgICAgdmFsdWU6IDBcbiAgICAgIH0pO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHR5cGUsIFwiX2RlYnVnSW5mb1wiLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogITEsXG4gICAgICAgIGVudW1lcmFibGU6ICExLFxuICAgICAgICB3cml0YWJsZTogITAsXG4gICAgICAgIHZhbHVlOiBudWxsXG4gICAgICB9KTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0eXBlLCBcIl9kZWJ1Z1N0YWNrXCIsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiAhMSxcbiAgICAgICAgZW51bWVyYWJsZTogITEsXG4gICAgICAgIHdyaXRhYmxlOiAhMCxcbiAgICAgICAgdmFsdWU6IGRlYnVnU3RhY2tcbiAgICAgIH0pO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHR5cGUsIFwiX2RlYnVnVGFza1wiLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogITEsXG4gICAgICAgIGVudW1lcmFibGU6ICExLFxuICAgICAgICB3cml0YWJsZTogITAsXG4gICAgICAgIHZhbHVlOiBkZWJ1Z1Rhc2tcbiAgICAgIH0pO1xuICAgICAgT2JqZWN0LmZyZWV6ZSAmJiAoT2JqZWN0LmZyZWV6ZSh0eXBlLnByb3BzKSwgT2JqZWN0LmZyZWV6ZSh0eXBlKSk7XG4gICAgICByZXR1cm4gdHlwZTtcbiAgICB9XG4gICAgZnVuY3Rpb24ganN4REVWSW1wbChcbiAgICAgIHR5cGUsXG4gICAgICBjb25maWcsXG4gICAgICBtYXliZUtleSxcbiAgICAgIGlzU3RhdGljQ2hpbGRyZW4sXG4gICAgICBzb3VyY2UsXG4gICAgICBzZWxmLFxuICAgICAgZGVidWdTdGFjayxcbiAgICAgIGRlYnVnVGFza1xuICAgICkge1xuICAgICAgdmFyIGNoaWxkcmVuID0gY29uZmlnLmNoaWxkcmVuO1xuICAgICAgaWYgKHZvaWQgMCAhPT0gY2hpbGRyZW4pXG4gICAgICAgIGlmIChpc1N0YXRpY0NoaWxkcmVuKVxuICAgICAgICAgIGlmIChpc0FycmF5SW1wbChjaGlsZHJlbikpIHtcbiAgICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICAgIGlzU3RhdGljQ2hpbGRyZW4gPSAwO1xuICAgICAgICAgICAgICBpc1N0YXRpY0NoaWxkcmVuIDwgY2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgICAgICAgICBpc1N0YXRpY0NoaWxkcmVuKytcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgdmFsaWRhdGVDaGlsZEtleXMoY2hpbGRyZW5baXNTdGF0aWNDaGlsZHJlbl0pO1xuICAgICAgICAgICAgT2JqZWN0LmZyZWV6ZSAmJiBPYmplY3QuZnJlZXplKGNoaWxkcmVuKTtcbiAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiUmVhY3QuanN4OiBTdGF0aWMgY2hpbGRyZW4gc2hvdWxkIGFsd2F5cyBiZSBhbiBhcnJheS4gWW91IGFyZSBsaWtlbHkgZXhwbGljaXRseSBjYWxsaW5nIFJlYWN0LmpzeHMgb3IgUmVhY3QuanN4REVWLiBVc2UgdGhlIEJhYmVsIHRyYW5zZm9ybSBpbnN0ZWFkLlwiXG4gICAgICAgICAgICApO1xuICAgICAgICBlbHNlIHZhbGlkYXRlQ2hpbGRLZXlzKGNoaWxkcmVuKTtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgXCJrZXlcIikpIHtcbiAgICAgICAgY2hpbGRyZW4gPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSk7XG4gICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoY29uZmlnKS5maWx0ZXIoZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICByZXR1cm4gXCJrZXlcIiAhPT0gaztcbiAgICAgICAgfSk7XG4gICAgICAgIGlzU3RhdGljQ2hpbGRyZW4gPVxuICAgICAgICAgIDAgPCBrZXlzLmxlbmd0aFxuICAgICAgICAgICAgPyBcIntrZXk6IHNvbWVLZXksIFwiICsga2V5cy5qb2luKFwiOiAuLi4sIFwiKSArIFwiOiAuLi59XCJcbiAgICAgICAgICAgIDogXCJ7a2V5OiBzb21lS2V5fVwiO1xuICAgICAgICBkaWRXYXJuQWJvdXRLZXlTcHJlYWRbY2hpbGRyZW4gKyBpc1N0YXRpY0NoaWxkcmVuXSB8fFxuICAgICAgICAgICgoa2V5cyA9XG4gICAgICAgICAgICAwIDwga2V5cy5sZW5ndGggPyBcIntcIiArIGtleXMuam9pbihcIjogLi4uLCBcIikgKyBcIjogLi4ufVwiIDogXCJ7fVwiKSxcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgJ0EgcHJvcHMgb2JqZWN0IGNvbnRhaW5pbmcgYSBcImtleVwiIHByb3AgaXMgYmVpbmcgc3ByZWFkIGludG8gSlNYOlxcbiAgbGV0IHByb3BzID0gJXM7XFxuICA8JXMgey4uLnByb3BzfSAvPlxcblJlYWN0IGtleXMgbXVzdCBiZSBwYXNzZWQgZGlyZWN0bHkgdG8gSlNYIHdpdGhvdXQgdXNpbmcgc3ByZWFkOlxcbiAgbGV0IHByb3BzID0gJXM7XFxuICA8JXMga2V5PXtzb21lS2V5fSB7Li4ucHJvcHN9IC8+JyxcbiAgICAgICAgICAgIGlzU3RhdGljQ2hpbGRyZW4sXG4gICAgICAgICAgICBjaGlsZHJlbixcbiAgICAgICAgICAgIGtleXMsXG4gICAgICAgICAgICBjaGlsZHJlblxuICAgICAgICAgICksXG4gICAgICAgICAgKGRpZFdhcm5BYm91dEtleVNwcmVhZFtjaGlsZHJlbiArIGlzU3RhdGljQ2hpbGRyZW5dID0gITApKTtcbiAgICAgIH1cbiAgICAgIGNoaWxkcmVuID0gbnVsbDtcbiAgICAgIHZvaWQgMCAhPT0gbWF5YmVLZXkgJiZcbiAgICAgICAgKGNoZWNrS2V5U3RyaW5nQ29lcmNpb24obWF5YmVLZXkpLCAoY2hpbGRyZW4gPSBcIlwiICsgbWF5YmVLZXkpKTtcbiAgICAgIGhhc1ZhbGlkS2V5KGNvbmZpZykgJiZcbiAgICAgICAgKGNoZWNrS2V5U3RyaW5nQ29lcmNpb24oY29uZmlnLmtleSksIChjaGlsZHJlbiA9IFwiXCIgKyBjb25maWcua2V5KSk7XG4gICAgICBpZiAoXCJrZXlcIiBpbiBjb25maWcpIHtcbiAgICAgICAgbWF5YmVLZXkgPSB7fTtcbiAgICAgICAgZm9yICh2YXIgcHJvcE5hbWUgaW4gY29uZmlnKVxuICAgICAgICAgIFwia2V5XCIgIT09IHByb3BOYW1lICYmIChtYXliZUtleVtwcm9wTmFtZV0gPSBjb25maWdbcHJvcE5hbWVdKTtcbiAgICAgIH0gZWxzZSBtYXliZUtleSA9IGNvbmZpZztcbiAgICAgIGNoaWxkcmVuICYmXG4gICAgICAgIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKFxuICAgICAgICAgIG1heWJlS2V5LFxuICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHR5cGVcbiAgICAgICAgICAgID8gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgXCJVbmtub3duXCJcbiAgICAgICAgICAgIDogdHlwZVxuICAgICAgICApO1xuICAgICAgcmV0dXJuIFJlYWN0RWxlbWVudChcbiAgICAgICAgdHlwZSxcbiAgICAgICAgY2hpbGRyZW4sXG4gICAgICAgIHNlbGYsXG4gICAgICAgIHNvdXJjZSxcbiAgICAgICAgZ2V0T3duZXIoKSxcbiAgICAgICAgbWF5YmVLZXksXG4gICAgICAgIGRlYnVnU3RhY2ssXG4gICAgICAgIGRlYnVnVGFza1xuICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdmFsaWRhdGVDaGlsZEtleXMobm9kZSkge1xuICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIG5vZGUgJiZcbiAgICAgICAgbnVsbCAhPT0gbm9kZSAmJlxuICAgICAgICBub2RlLiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEUgJiZcbiAgICAgICAgbm9kZS5fc3RvcmUgJiZcbiAgICAgICAgKG5vZGUuX3N0b3JlLnZhbGlkYXRlZCA9IDEpO1xuICAgIH1cbiAgICB2YXIgUmVhY3QgPSByZXF1aXJlKFwibmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0XCIpLFxuICAgICAgUkVBQ1RfRUxFTUVOVF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnRyYW5zaXRpb25hbC5lbGVtZW50XCIpLFxuICAgICAgUkVBQ1RfUE9SVEFMX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QucG9ydGFsXCIpLFxuICAgICAgUkVBQ1RfRlJBR01FTlRfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5mcmFnbWVudFwiKSxcbiAgICAgIFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3Quc3RyaWN0X21vZGVcIiksXG4gICAgICBSRUFDVF9QUk9GSUxFUl9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnByb2ZpbGVyXCIpO1xuICAgIFN5bWJvbC5mb3IoXCJyZWFjdC5wcm92aWRlclwiKTtcbiAgICB2YXIgUkVBQ1RfQ09OU1VNRVJfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5jb25zdW1lclwiKSxcbiAgICAgIFJFQUNUX0NPTlRFWFRfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5jb250ZXh0XCIpLFxuICAgICAgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5mb3J3YXJkX3JlZlwiKSxcbiAgICAgIFJFQUNUX1NVU1BFTlNFX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3Quc3VzcGVuc2VcIiksXG4gICAgICBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3Quc3VzcGVuc2VfbGlzdFwiKSxcbiAgICAgIFJFQUNUX01FTU9fVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5tZW1vXCIpLFxuICAgICAgUkVBQ1RfTEFaWV9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LmxhenlcIiksXG4gICAgICBSRUFDVF9DTElFTlRfUkVGRVJFTkNFID0gU3ltYm9sLmZvcihcInJlYWN0LmNsaWVudC5yZWZlcmVuY2VcIiksXG4gICAgICBSZWFjdFNoYXJlZEludGVybmFscyA9XG4gICAgICAgIFJlYWN0Ll9fQ0xJRU5UX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1dBUk5fVVNFUlNfVEhFWV9DQU5OT1RfVVBHUkFERSxcbiAgICAgIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSxcbiAgICAgIGlzQXJyYXlJbXBsID0gQXJyYXkuaXNBcnJheSxcbiAgICAgIGNyZWF0ZVRhc2sgPSBjb25zb2xlLmNyZWF0ZVRhc2tcbiAgICAgICAgPyBjb25zb2xlLmNyZWF0ZVRhc2tcbiAgICAgICAgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9LFxuICAgICAgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd247XG4gICAgdmFyIGRpZFdhcm5BYm91dEVsZW1lbnRSZWYgPSB7fTtcbiAgICB2YXIgZGlkV2FybkFib3V0S2V5U3ByZWFkID0ge307XG4gICAgZXhwb3J0cy5GcmFnbWVudCA9IFJFQUNUX0ZSQUdNRU5UX1RZUEU7XG4gICAgZXhwb3J0cy5qc3hERVYgPSBmdW5jdGlvbiAoXG4gICAgICB0eXBlLFxuICAgICAgY29uZmlnLFxuICAgICAgbWF5YmVLZXksXG4gICAgICBpc1N0YXRpY0NoaWxkcmVuLFxuICAgICAgc291cmNlLFxuICAgICAgc2VsZlxuICAgICkge1xuICAgICAgcmV0dXJuIGpzeERFVkltcGwoXG4gICAgICAgIHR5cGUsXG4gICAgICAgIGNvbmZpZyxcbiAgICAgICAgbWF5YmVLZXksXG4gICAgICAgIGlzU3RhdGljQ2hpbGRyZW4sXG4gICAgICAgIHNvdXJjZSxcbiAgICAgICAgc2VsZixcbiAgICAgICAgRXJyb3IoXCJyZWFjdC1zdGFjay10b3AtZnJhbWVcIiksXG4gICAgICAgIGNyZWF0ZVRhc2soZ2V0VGFza05hbWUodHlwZSkpXG4gICAgICApO1xuICAgIH07XG4gIH0pKCk7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/next@15.2.4_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/.pnpm/next@15.2.4_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/next/dist/compiled/react/jsx-dev-runtime.js":
/*!*********************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@15.2.4_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/next/dist/compiled/react/jsx-dev-runtime.js ***!
  \*********************************************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-jsx-dev-runtime.development.js */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.2.4_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDE1LjIuNF9yZWFjdC1kb21AMTkuMS4wX3JlYWN0QDE5LjEuMF9fcmVhY3RAMTkuMS4wL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvanN4LWRldi1ydW50aW1lLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLElBQUksS0FBcUMsRUFBRSxFQUUxQyxDQUFDO0FBQ0YsRUFBRSx5UUFBc0U7QUFDeEUiLCJzb3VyY2VzIjpbIi9Vc2Vycy9tYXJrb25vdmFrb3Zza2kvRG9jdW1lbnRzL1Zpc3VhbCBDb2RlL0FzdHJvQm9vay9Bc3Ryb0Jvb2svbm9kZV9tb2R1bGVzLy5wbnBtL25leHRAMTUuMi40X3JlYWN0LWRvbUAxOS4xLjBfcmVhY3RAMTkuMS4wX19yZWFjdEAxOS4xLjAvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9yZWFjdC9qc3gtZGV2LXJ1bnRpbWUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5wcm9kdWN0aW9uLmpzJyk7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcycpO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/next@15.2.4_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/next/dist/compiled/react/jsx-dev-runtime.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./utils/storage.ts":
/*!**************************!*\
  !*** ./utils/storage.ts ***!
  \**************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   clearQuizData: () => (/* binding */ clearQuizData),\n/* harmony export */   getQuizData: () => (/* binding */ getQuizData),\n/* harmony export */   isQuizCompleted: () => (/* binding */ isQuizCompleted),\n/* harmony export */   saveQuizData: () => (/* binding */ saveQuizData)\n/* harmony export */ });\n// Keys for storage\nconst QUIZ_DATA_KEY = \"astrovela_quiz_data\";\nconst QUIZ_COMPLETED_KEY = \"astrovela_quiz_completed\";\n/**\n * Save quiz data to local storage\n */ function saveQuizData(data) {\n    try {\n        localStorage.setItem(QUIZ_DATA_KEY, JSON.stringify(data));\n        // Only set quiz as completed if the quizCompleted flag in the data is true\n        if (data.quizCompleted) {\n            localStorage.setItem(QUIZ_COMPLETED_KEY, \"true\");\n        }\n    } catch (error) {\n        console.error(\"Failed to save quiz data:\", error);\n    }\n}\n/**\n * Retrieve quiz data from local storage\n */ function getQuizData() {\n    try {\n        const data = localStorage.getItem(QUIZ_DATA_KEY);\n        return data ? JSON.parse(data) : null;\n    } catch (error) {\n        console.error(\"Failed to retrieve quiz data:\", error);\n        return null;\n    }\n}\n/**\n * Check if quiz has been completed\n */ function isQuizCompleted() {\n    try {\n        // Check both the completion flag and the data\n        const completedFlag = localStorage.getItem(QUIZ_COMPLETED_KEY) === \"true\";\n        // For extra safety, also check the quiz data\n        if (completedFlag) {\n            const quizData = getQuizData();\n            // Only return true if both the flag and the quizCompleted property in the data are true\n            return quizData ? quizData.quizCompleted : completedFlag;\n        }\n        return false;\n    } catch (error) {\n        return false;\n    }\n}\n/**\n * Clear quiz data from storage\n */ function clearQuizData() {\n    try {\n        // Clear specific quiz keys\n        localStorage.removeItem(QUIZ_DATA_KEY);\n        localStorage.removeItem(QUIZ_COMPLETED_KEY);\n        // Clear all localStorage items with astrovela prefix\n        Object.keys(localStorage).forEach((key)=>{\n            if (key.startsWith('astrovela')) {\n                localStorage.removeItem(key);\n            }\n        });\n        // Clear all sessionStorage items with astrovela prefix\n        if (typeof sessionStorage !== 'undefined') {\n            Object.keys(sessionStorage).forEach((key)=>{\n                if (key.startsWith('astrovela')) {\n                    sessionStorage.removeItem(key);\n                }\n            });\n        }\n        // Clear cookies with astrovela prefix\n        document.cookie.split(';').forEach((cookie)=>{\n            const cookieName = cookie.split('=')[0].trim();\n            if (cookieName.startsWith('astrovela')) {\n                document.cookie = \"\".concat(cookieName, \"=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;\");\n            }\n        });\n        console.log('All quiz data completely cleared from browser storage');\n    } catch (error) {\n        console.error(\"Failed to clear quiz data:\", error);\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3V0aWxzL3N0b3JhZ2UudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUVBLG1CQUFtQjtBQUNuQixNQUFNQSxnQkFBZ0I7QUFDdEIsTUFBTUMscUJBQXFCO0FBRTNCOztDQUVDLEdBQ00sU0FBU0MsYUFBYUMsSUFBZTtJQUMxQyxJQUFJO1FBQ0ZDLGFBQWFDLE9BQU8sQ0FBQ0wsZUFBZU0sS0FBS0MsU0FBUyxDQUFDSjtRQUVuRCwyRUFBMkU7UUFDM0UsSUFBSUEsS0FBS0ssYUFBYSxFQUFFO1lBQ3RCSixhQUFhQyxPQUFPLENBQUNKLG9CQUFvQjtRQUMzQztJQUNGLEVBQUUsT0FBT1EsT0FBTztRQUNkQyxRQUFRRCxLQUFLLENBQUMsNkJBQTZCQTtJQUM3QztBQUNGO0FBRUE7O0NBRUMsR0FDTSxTQUFTRTtJQUNkLElBQUk7UUFDRixNQUFNUixPQUFPQyxhQUFhUSxPQUFPLENBQUNaO1FBQ2xDLE9BQU9HLE9BQU9HLEtBQUtPLEtBQUssQ0FBQ1YsUUFBUTtJQUNuQyxFQUFFLE9BQU9NLE9BQU87UUFDZEMsUUFBUUQsS0FBSyxDQUFDLGlDQUFpQ0E7UUFDL0MsT0FBTztJQUNUO0FBQ0Y7QUFFQTs7Q0FFQyxHQUNNLFNBQVNLO0lBQ2QsSUFBSTtRQUNGLDhDQUE4QztRQUM5QyxNQUFNQyxnQkFBZ0JYLGFBQWFRLE9BQU8sQ0FBQ1gsd0JBQXdCO1FBRW5FLDZDQUE2QztRQUM3QyxJQUFJYyxlQUFlO1lBQ2pCLE1BQU1DLFdBQVdMO1lBQ2pCLHdGQUF3RjtZQUN4RixPQUFPSyxXQUFXQSxTQUFTUixhQUFhLEdBQUdPO1FBQzdDO1FBRUEsT0FBTztJQUNULEVBQUUsT0FBT04sT0FBTztRQUNkLE9BQU87SUFDVDtBQUNGO0FBRUE7O0NBRUMsR0FDTSxTQUFTUTtJQUNkLElBQUk7UUFDRiwyQkFBMkI7UUFDM0JiLGFBQWFjLFVBQVUsQ0FBQ2xCO1FBQ3hCSSxhQUFhYyxVQUFVLENBQUNqQjtRQUV4QixxREFBcUQ7UUFDckRrQixPQUFPQyxJQUFJLENBQUNoQixjQUFjaUIsT0FBTyxDQUFDQyxDQUFBQTtZQUNoQyxJQUFJQSxJQUFJQyxVQUFVLENBQUMsY0FBYztnQkFDL0JuQixhQUFhYyxVQUFVLENBQUNJO1lBQzFCO1FBQ0Y7UUFFQSx1REFBdUQ7UUFDdkQsSUFBSSxPQUFPRSxtQkFBbUIsYUFBYTtZQUN6Q0wsT0FBT0MsSUFBSSxDQUFDSSxnQkFBZ0JILE9BQU8sQ0FBQ0MsQ0FBQUE7Z0JBQ2xDLElBQUlBLElBQUlDLFVBQVUsQ0FBQyxjQUFjO29CQUMvQkMsZUFBZU4sVUFBVSxDQUFDSTtnQkFDNUI7WUFDRjtRQUNGO1FBRUEsc0NBQXNDO1FBQ3RDRyxTQUFTQyxNQUFNLENBQUNDLEtBQUssQ0FBQyxLQUFLTixPQUFPLENBQUNLLENBQUFBO1lBQ2pDLE1BQU1FLGFBQWFGLE9BQU9DLEtBQUssQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDRSxJQUFJO1lBQzVDLElBQUlELFdBQVdMLFVBQVUsQ0FBQyxjQUFjO2dCQUN0Q0UsU0FBU0MsTUFBTSxHQUFHLEdBQWMsT0FBWEUsWUFBVztZQUNsQztRQUNGO1FBRUFsQixRQUFRb0IsR0FBRyxDQUFDO0lBQ2QsRUFBRSxPQUFPckIsT0FBTztRQUNkQyxRQUFRRCxLQUFLLENBQUMsOEJBQThCQTtJQUM5QztBQUNGIiwic291cmNlcyI6WyIvVXNlcnMvbWFya29ub3Zha292c2tpL0RvY3VtZW50cy9WaXN1YWwgQ29kZS9Bc3Ryb0Jvb2svQXN0cm9Cb29rL3V0aWxzL3N0b3JhZ2UudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHR5cGUgeyBRdWl6U3RhdGUgfSBmcm9tIFwiQC9jb250ZXh0cy9xdWl6LWNvbnRleHRcIlxuXG4vLyBLZXlzIGZvciBzdG9yYWdlXG5jb25zdCBRVUlaX0RBVEFfS0VZID0gXCJhc3Ryb3ZlbGFfcXVpel9kYXRhXCJcbmNvbnN0IFFVSVpfQ09NUExFVEVEX0tFWSA9IFwiYXN0cm92ZWxhX3F1aXpfY29tcGxldGVkXCJcblxuLyoqXG4gKiBTYXZlIHF1aXogZGF0YSB0byBsb2NhbCBzdG9yYWdlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzYXZlUXVpekRhdGEoZGF0YTogUXVpelN0YXRlKTogdm9pZCB7XG4gIHRyeSB7XG4gICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oUVVJWl9EQVRBX0tFWSwgSlNPTi5zdHJpbmdpZnkoZGF0YSkpXG4gICAgXG4gICAgLy8gT25seSBzZXQgcXVpeiBhcyBjb21wbGV0ZWQgaWYgdGhlIHF1aXpDb21wbGV0ZWQgZmxhZyBpbiB0aGUgZGF0YSBpcyB0cnVlXG4gICAgaWYgKGRhdGEucXVpekNvbXBsZXRlZCkge1xuICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oUVVJWl9DT01QTEVURURfS0VZLCBcInRydWVcIilcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihcIkZhaWxlZCB0byBzYXZlIHF1aXogZGF0YTpcIiwgZXJyb3IpXG4gIH1cbn1cblxuLyoqXG4gKiBSZXRyaWV2ZSBxdWl6IGRhdGEgZnJvbSBsb2NhbCBzdG9yYWdlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRRdWl6RGF0YSgpOiBRdWl6U3RhdGUgfCBudWxsIHtcbiAgdHJ5IHtcbiAgICBjb25zdCBkYXRhID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oUVVJWl9EQVRBX0tFWSlcbiAgICByZXR1cm4gZGF0YSA/IEpTT04ucGFyc2UoZGF0YSkgOiBudWxsXG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihcIkZhaWxlZCB0byByZXRyaWV2ZSBxdWl6IGRhdGE6XCIsIGVycm9yKVxuICAgIHJldHVybiBudWxsXG4gIH1cbn1cblxuLyoqXG4gKiBDaGVjayBpZiBxdWl6IGhhcyBiZWVuIGNvbXBsZXRlZFxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNRdWl6Q29tcGxldGVkKCk6IGJvb2xlYW4ge1xuICB0cnkge1xuICAgIC8vIENoZWNrIGJvdGggdGhlIGNvbXBsZXRpb24gZmxhZyBhbmQgdGhlIGRhdGFcbiAgICBjb25zdCBjb21wbGV0ZWRGbGFnID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oUVVJWl9DT01QTEVURURfS0VZKSA9PT0gXCJ0cnVlXCJcbiAgICBcbiAgICAvLyBGb3IgZXh0cmEgc2FmZXR5LCBhbHNvIGNoZWNrIHRoZSBxdWl6IGRhdGFcbiAgICBpZiAoY29tcGxldGVkRmxhZykge1xuICAgICAgY29uc3QgcXVpekRhdGEgPSBnZXRRdWl6RGF0YSgpXG4gICAgICAvLyBPbmx5IHJldHVybiB0cnVlIGlmIGJvdGggdGhlIGZsYWcgYW5kIHRoZSBxdWl6Q29tcGxldGVkIHByb3BlcnR5IGluIHRoZSBkYXRhIGFyZSB0cnVlXG4gICAgICByZXR1cm4gcXVpekRhdGEgPyBxdWl6RGF0YS5xdWl6Q29tcGxldGVkIDogY29tcGxldGVkRmxhZ1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gZmFsc2VcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG4vKipcbiAqIENsZWFyIHF1aXogZGF0YSBmcm9tIHN0b3JhZ2VcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNsZWFyUXVpekRhdGEoKTogdm9pZCB7XG4gIHRyeSB7XG4gICAgLy8gQ2xlYXIgc3BlY2lmaWMgcXVpeiBrZXlzXG4gICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oUVVJWl9EQVRBX0tFWSlcbiAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShRVUlaX0NPTVBMRVRFRF9LRVkpXG4gICAgXG4gICAgLy8gQ2xlYXIgYWxsIGxvY2FsU3RvcmFnZSBpdGVtcyB3aXRoIGFzdHJvdmVsYSBwcmVmaXhcbiAgICBPYmplY3Qua2V5cyhsb2NhbFN0b3JhZ2UpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgIGlmIChrZXkuc3RhcnRzV2l0aCgnYXN0cm92ZWxhJykpIHtcbiAgICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oa2V5KVxuICAgICAgfVxuICAgIH0pXG4gICAgXG4gICAgLy8gQ2xlYXIgYWxsIHNlc3Npb25TdG9yYWdlIGl0ZW1zIHdpdGggYXN0cm92ZWxhIHByZWZpeFxuICAgIGlmICh0eXBlb2Ygc2Vzc2lvblN0b3JhZ2UgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBPYmplY3Qua2V5cyhzZXNzaW9uU3RvcmFnZSkuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICBpZiAoa2V5LnN0YXJ0c1dpdGgoJ2FzdHJvdmVsYScpKSB7XG4gICAgICAgICAgc2Vzc2lvblN0b3JhZ2UucmVtb3ZlSXRlbShrZXkpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICAgIFxuICAgIC8vIENsZWFyIGNvb2tpZXMgd2l0aCBhc3Ryb3ZlbGEgcHJlZml4XG4gICAgZG9jdW1lbnQuY29va2llLnNwbGl0KCc7JykuZm9yRWFjaChjb29raWUgPT4ge1xuICAgICAgY29uc3QgY29va2llTmFtZSA9IGNvb2tpZS5zcGxpdCgnPScpWzBdLnRyaW0oKVxuICAgICAgaWYgKGNvb2tpZU5hbWUuc3RhcnRzV2l0aCgnYXN0cm92ZWxhJykpIHtcbiAgICAgICAgZG9jdW1lbnQuY29va2llID0gYCR7Y29va2llTmFtZX09OyBleHBpcmVzPVRodSwgMDEgSmFuIDE5NzAgMDA6MDA6MDAgVVRDOyBwYXRoPS87YFxuICAgICAgfVxuICAgIH0pXG4gICAgXG4gICAgY29uc29sZS5sb2coJ0FsbCBxdWl6IGRhdGEgY29tcGxldGVseSBjbGVhcmVkIGZyb20gYnJvd3NlciBzdG9yYWdlJylcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiRmFpbGVkIHRvIGNsZWFyIHF1aXogZGF0YTpcIiwgZXJyb3IpXG4gIH1cbn1cblxuIl0sIm5hbWVzIjpbIlFVSVpfREFUQV9LRVkiLCJRVUlaX0NPTVBMRVRFRF9LRVkiLCJzYXZlUXVpekRhdGEiLCJkYXRhIiwibG9jYWxTdG9yYWdlIiwic2V0SXRlbSIsIkpTT04iLCJzdHJpbmdpZnkiLCJxdWl6Q29tcGxldGVkIiwiZXJyb3IiLCJjb25zb2xlIiwiZ2V0UXVpekRhdGEiLCJnZXRJdGVtIiwicGFyc2UiLCJpc1F1aXpDb21wbGV0ZWQiLCJjb21wbGV0ZWRGbGFnIiwicXVpekRhdGEiLCJjbGVhclF1aXpEYXRhIiwicmVtb3ZlSXRlbSIsIk9iamVjdCIsImtleXMiLCJmb3JFYWNoIiwia2V5Iiwic3RhcnRzV2l0aCIsInNlc3Npb25TdG9yYWdlIiwiZG9jdW1lbnQiLCJjb29raWUiLCJzcGxpdCIsImNvb2tpZU5hbWUiLCJ0cmltIiwibG9nIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./utils/storage.ts\n"));

/***/ })

},
/******/ __webpack_require__ => { // webpackRuntimeModules
/******/ var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
/******/ __webpack_require__.O(0, ["main-app"], () => (__webpack_exec__("(app-pages-browser)/./node_modules/.pnpm/next@15.2.4_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2FUsers%2Fmarkonovakovski%2FDocuments%2FVisual%20Code%2FAstroBook%2FAstroBook%2Fcontexts%2Fquiz-context.tsx%22%2C%22ids%22%3A%5B%22QuizProvider%22%5D%7D&server=false!")));
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ _N_E = __webpack_exports__;
/******/ }
]);